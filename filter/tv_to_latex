#!/usr/bin/perl -w
# $Id: tv_to_latex,v 1.4 2002/03/06 16:01:53 epaepa Exp $

=head1 NAME

tv_to_latex - Convert XMLTV listings to LaTeX source.

=head1 SYNOPSIS

tv_to_latex [--help] [--output FILE] [FILE]

=head1 DESCRIPTION

Read an XMLTV file and output LaTeX source for a summary of listings.
The programme titles, subtitles, times and channels are shown.

B<--output FILE> write to FILE rather than standard output

=head1 SEE ALSO

L<xmltv(5)>.

=head1 AUTHOR

Ed Avis, epa98@doc.ic.ac.uk

=head1 BUGS

The LaTeX source generated is not perfect, it sometimes produces
spurious blank lines in the output.

=cut

use strict;
use XML::DOM;
use IO::File;
use Date::Manip;
use POSIX 'tmpnam';
use XMLTV qw(best_name);
use XMLTV::TZ qw(gettz ParseDate_PreservingTZ);
use Log::TraceMessages qw(t d); Log::TraceMessages::check_argv();
use Getopt::Long;
use Unicode::String;

# Prototype declarations
sub chunk( $$ );
sub start_date( $ );
sub u8_to_latin1( $ );
sub quote( $ );
sub find_channel_names( $ );
sub usage( ;$ );

my ($opt_help, $opt_output);
GetOptions('help' => \$opt_help, 'output=s' => \$opt_output);
usage(1) if $opt_help;
my $filename;
if (@ARGV == 0) {
    $filename = '-';
}
elsif (@ARGV == 1) {
    $filename = $ARGV[0];
}
elsif (@ARGV >= 2) {
    usage();
}
else { die }
if (defined $opt_output) {
    open(STDOUT, ">$opt_output")
      or die "cannot write to $opt_output: $!";
}


########
# Configuration
#

# Width of programme title
my $WIDTH = '0.7\textwidth';

# Number of programmes in each table (should fit onto a page)
my $CHUNK_SIZE = 30;

# List of preferred languages.  Hopefully the environment variable
# $LANG will be set.
#
my @PREF_LANGS;
my $el = $ENV{LANG};
if (defined $el and $el =~ /\S/) {
    $el =~ s/\..+$//; # remove character set
    @PREF_LANGS = ($el);
}
else {
    @PREF_LANGS = ('en'); # change for your language - or just set $LANG
}

########
# End of configuration
#

# Memoize some subroutines if possible
eval { require Memoize };
if ($@) {
    warn "could not load Memoize module, things will run slowly";
}
else {
    foreach (qw/start_date ParseDate UnixDate gettz ParseDate_PreservingTZ
	     u8_to_latin1/) {
	Memoize::memoize($_) or die "cannot memoize $_: $!";
    }
}

# Comparison function for choosing what string to use in the printout.
my $shorter = sub { length($_[0]) <=> length($_[1]) };

# Print the start of the LaTeX document
print <<'END';
\documentclass[a4paper]{article}
\usepackage[latin1]{inputenc}
\begin{document}
\sf
\begin{flushleft}
END

# Parse stdin and make it into chunks of programmes
my ($encoding, $credits, $ch, $progs) = @{XMLTV::parsefile($filename)};
die if $encoding ne 'UTF-8';
my $ch_name = find_channel_names($ch);
t 'preferred names: ' . d $ch_name;
my @chunks = @{chunk($CHUNK_SIZE, $progs)};

# Print each chunk as a table
my ($curr_date, $curr_tz);
foreach (@chunks) {
    my @programmes = @$_;

    my $chunk_date = start_date($programmes[0]);
    if (not defined $curr_date or $curr_date ne $chunk_date) {
	my $df = UnixDate($chunk_date, "%m-%d (%A)");
	print "\\section*{\\sf $df}\n";
	$curr_date = $chunk_date;
    }

    print "\\begin{tabular}{r\@{--}lp{$WIDTH}r} \n";
    my $top_of_table = 1;
    foreach (@programmes) {
	t 'doing programme: ' . d $_;
	my %h = %$_;
	my ($start, $stop, $channel) = @h{qw(start stop channel)};

	t 'possible titles: ' . d $h{title};
	my $title = best_name(\@PREF_LANGS, $h{title}, $shorter)->[0];
	t 'chosen: ' . d $title;
	warn "programme has no title" if not defined $title;

	my $sub_title;
	for ($h{'sub-title'}) {
	    if (defined) {
		t 'possible sub-titles: ' . d $h{'sub-title'};
		warn "list of sub-titles but empty" if not @$_;
		$sub_title = best_name(\@PREF_LANGS, $_, $shorter)->[0];
		t 'chosen: ' . d $sub_title;
		warn "could not find sub-title" if not defined $sub_title;
	    }
	}
	
	# Convert date-and-time to just hhmm, adding explicit timezone
	# whenever it changes.
	#
	my $start_tz = gettz($start) || 'UT';
	my $start_p = ParseDate_PreservingTZ($start)
	  or die "bad date '$start'";
	my $start_h = UnixDate($start_p, '%R');

	if ($top_of_table and not defined $curr_tz) {
	    # Assume that the first listing on a page doesn't need an
	    # explicit timezone.  (FIXME not perfect)
	    #
	    $curr_tz = $start_tz;
	}
	$top_of_table = 0;

	my $stop_h;
	if (defined $stop) {
	    # Stop time is defined, sort out its timezone too
	    my $stop_tz = gettz($stop) || 'UT';
	    my $stop_p = ParseDate_PreservingTZ($stop)
	      or die "bad date '$stop'";
	    $stop_h = UnixDate($stop_p, '%R');

	    if ((not defined $curr_tz)
		or ($curr_tz ne $start_tz)
		or ($start_tz ne $stop_tz) )
	    {
		  # The timezone has changed somehow - make it explicit.
		  $start_h .= " $start_tz";
		  $stop_h .= " $stop_tz";
		  undef $curr_tz;
	    }

	    if ($start_tz eq $stop_tz) {
		# The programme starts and stops in the same TZ - we
		# can assume that this is the one to use from now on.
		#
		$curr_tz = $start_tz;
	    }
	}
	else {
	    # Missing stop time.  Still need to check the timezone.
	    if ((not defined $curr_tz) or ($curr_tz ne $start_tz)) {
		$start_h .= " $start_tz";
		undef $curr_tz;
	    }
	}

	# Look up pretty name of channel.
	if (defined $ch_name->{$channel}) {
	    $channel = $ch_name->{$channel};
	}

	$channel = quote(u8_to_latin1($channel));
	$title .= " // $sub_title" if defined $sub_title;
	$title = quote(u8_to_latin1($title));

	# Apparently, you have to put \smallskip _before_ each line
	# (even the first) in order to get consistent spacing.  The
	# blank line after $title is to explicitly end the paragraph,
	# so that \raggedright takes effect.
	#
	# Er, this needs fixing.  See my post to comp.text.tex.
	#
	die 'no start'   if not defined $start_h;
	$stop_h = '' if not defined $stop_h;
	die 'no title'   if not defined $title;
	die 'no channel' if not defined $channel;

	print <<END;
\\smallskip
$start_h & $stop_h &
{ \\small \\raggedright
$title
} & $channel \\\\
END
    }

print "\\end{tabular} \\\\ \n";
}
print "\\end{flushleft}\n";

# Acknowledgements
my $g = $credits->{'generator-info-name'};
$g =~ s!/(\d)! $1! if defined $g;
my $s = $credits->{'source-info-name'};
if (not defined $g and not defined $s) {
    # No acknowledgement since unknown source.
}
elsif (not defined $g and defined $s) {
    print 'Generated from \textbf{', quote(u8_to_latin1($s)), "}.\n";
}
elsif (defined $g and not defined $s) {
    print 'Generated by \textbf{', quote(u8_to_latin1($g)),  "}.\n";
}
elsif (defined $g and defined $s) {
    print 'Generated from \textbf{', quote(u8_to_latin1($s)), '} by \textbf{', quote(u8_to_latin1($g)), "}.\n";
}
else { die }
print "\\end{document}\n";


# chunk()
#
# Split up a list of programmes into chunks of a certain maximum size,
# also starting a new chunk for each day.
#
sub chunk( $$ ) {
    die 'usage: chunk(chunk size, ref to list of programmes)'
      if @_ != 2;
    my ($chunksize, $list) = @_;

    my @r;
    my @currchunk = ();
    while (@$list) {
	push @currchunk, scalar (shift @$list);

	if (@currchunk == $chunksize
	    or @$list == 0
	    or start_date($currchunk[-1]) ne start_date($list->[0]) )
        {
	    push @r, [ @currchunk ];
	    @currchunk = ();
	}
    }
    return \@r;
}


# start_date()
#
# Returns the day on which a programme starts, in the form YYYYMMDD.
#
sub start_date( $ ) {
    my $prog = shift;
    die "bad programme" if not defined $prog->{title};
    die "no start date for $prog->{title}"
      if not defined $prog->{start};

    my $p = ParseDate_PreservingTZ($prog->{start});
    die "bad start date for programme" if not defined $p or $p eq '';
    return UnixDate($p, '%Q');
}


# quote()
# 
# Quote at least some characters which do funny things in LaTeX
# 
# Parameters: string to quote
# Returns: quoted version
# 
# Copied from <http://www.doc.ic.ac.uk/~epa98/work/apps/dtd2latex/>;
# should put something like this into a 'LaTeX' module some day.
# 
sub quote( $ ) {
    die 'usage: quote(string)' if @_ != 1;
    local $_ = shift;

    # Quote characters
    s/\\/\\(\\backslash\\)/g;
    foreach my $ch ('_', '#', '%', '{', '}', '&', '|') {
	s/\Q$ch\E/\\$ch/g;
    }
    s/\$/\\\$/g;
    foreach my $ch ('<', '>') {
	s/$ch/\\($ch\\)/g;
    }
    s/~/\\(\\sim\\)/g;
    s/\^/\\(\\hat{}\\)/g;
    s/¦/\|/g;

    # Lines of dots
    s/\.{3,}\s*$/\\dotfill/mg;

    return $_;
}

# find_channel_names()
#
# Parameter: refhash of channels data from parsefile()
# Returns: ref to hash mapping channel id to printable channel name
#
sub find_channel_names( $ ) {
    my $h = shift;
    t 'channels hash: ' . d $h;
    my %r;
    foreach my $id (keys %$h) {
	t 'doing id: ' . d $id;
	my @names = @{$h->{$id}->{'display-name'}};
	t 'names: ' . d \@names;
	if (not @names) {
	    warn "channels hash has no name for $id";
	    next;
	}
	my $best = best_name(\@PREF_LANGS, \@names, $shorter)->[0];
	t 'best name: ' . d $best;
	if (not defined $best) {
	    warn "couldn't get name for channel $id";
	    $best = $id;
	}

	# There's no need to warn about more than one channel having
	# the same human-readable name: that's deliberate (eg regional
	# variants of the same channel may all have the same number).
	# Maybe it could be checked when the channel id is actually
	# looked up to get the name, that the name hasn't been used
	# for a different channel id.  But we won't even do that for
	# now.
	#
	$r{$id} = $best;
    }
    return \%r;
}


# If optional parameter true, is 'help message'.
sub usage( ;$ ) {
    my $is_help = shift;
    my $msg = <<END
$0: convert listings to LaTeX source for printing
usage: $0 [--help] [--output FILE] [FILE]
END
;
    if ($is_help) {
	print $msg;
	exit(0);
    }
    else {
	print STDERR $msg;
	exit(1);
    }
}


# Convert UTF-8 to Latin-1.
sub u8_to_latin1( $ ) { Unicode::String::utf8($_[0])->latin1() }
