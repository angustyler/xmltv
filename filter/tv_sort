#!/usr/bin/perl -w
# $Id: tv_sort,v 1.11 2002/09/13 14:29:07 epaepa Exp $

=head1 NAME

tv_sort - Sort XMLTV listings files by date, and add stop times.

=head1 SYNOPSIS

tv_sort [--help] [--by-channel] [--output FILE] [FILE]

=head1 DESCRIPTION

Read an XMLTV file and write out the same data sorted in date order.
Where stop times of programmes are missing, guess them from the start
time of the next programme on the same channel.

Tv_sort also performs some sanity checks such as making sure no
two programmes on the same channel overlap.

B<--output FILE> write to FILE rather than standard output

B<--by-channel> sort first by channel id, then by date within each
                channel.

The time sorting is by start time, then by stop time.  Without
B<--by-channel>, if start times and stop times are equal then two
programmes are sorted by internal channel id.  With B<--by-channel>,
channel id is compared first and then times.

You can think of tv_sort as converting an XMLTV file into a canonical
form, useful for diffing two files.

=head1 SEE ALSO

L<xmltv(5)>.

=head1 AUTHOR

Ed Avis, ed@membled.com

=cut

use strict;
use Date::Manip; Date_Init('TZ=UTC');
use Data::Dumper;
use Getopt::Long;

# Use Log::TraceMessages if installed.
BEGIN {
    eval { require Log::TraceMessages };
    if ($@) {
	*t = sub {};
	*d = sub { '' };
    }
    else {
	*t = \&Log::TraceMessages::t;
	*d = \&Log::TraceMessages::d;
	Log::TraceMessages::check_argv();
    }
}

use XMLTV;
use XMLTV::Usage <<END
$0: sort listings by time, sanity-check and add stop time to programmes
usage: $0 [--help] [--by-channel] [--output FILE] [FILE]
END
;

# Memoize some subroutines if possible
eval { require Memoize };
unless ($@) {
    foreach (qw/Date_Cmp ParseDate programme_eq/) {
	Memoize::memoize($_) or die "cannot memoize $_: $!";
    }
    # clumpidx_cmp() isn't memoized, since it uses undef arguments and
    # they cause warnings.
    #
}

# Prototype declarations
sub programme_cmp();
sub chan_cmp( $$ );
sub clumpidx_cmp( $$ );
sub overlap( $$ );
sub add_stop( $ );
sub programme_eq( $$ );

my ($opt_help, $opt_output, $opt_by_channel);
GetOptions('help' => \$opt_help, 'output=s' => \$opt_output,
	   'by-channel' => \$opt_by_channel)
  or usage(0);
usage(1) if $opt_help;
my $filename;
if (@ARGV == 0) {
    $filename = '-';
}
elsif (@ARGV == 1) {
    $filename = $ARGV[0];
}
elsif (@ARGV >= 2) {
    usage();
}
else { die }

my ($encoding, $credits, $channels, $progs) = @{XMLTV::parsefile($filename)};
my @progs = @$progs;

# Split up programmes according to channel
my %chan;
foreach (@progs) {
    push @{$chan{$_->{channel}}}, $_;
}

# Sort each channel individually, and guess stop times.
foreach (keys %chan) {
    @{$chan{$_}} = sort programme_cmp @{$chan{$_}};
    add_stop($chan{$_});
}

# Remove duplicates and sanity-check that there is no overlap on a
# channel.
#
foreach (keys %chan) {
    my $progs = $chan{$_};
    my @new_progs;
    die if not @$progs;
    my $first = shift @$progs;
    while (@$progs) {
	my $second = shift @$progs;
	die if not defined $first or not defined $second;
	if (overlap($first, $second)) {
	    if (programme_eq($first, $second)) {
		# Quietly drop the duplicate.  We could have done the
		# programme_eq() step first but I thought (perhaps
		# wrongly) that it would be expensive, and best called
		# only when we know there is an overlap.  No overlap
		# implies not equal.
		#
		next;
	    }
	    else {
		local $^W = 0;
		warn <<END
overlapping programmes on channel $_:
    $first->{title}->[0]->[0]\tat $first->{start}-|$first->{stop}
and $second->{title}->[0]->[0]\tat $second->{start}-|$second->{stop}
END
  ;
	    }
	}
	push @new_progs, $first;
	$first = $second;
    }
    # Got to the last element.
    push @new_progs, $first;
    $chan{$_} = \@new_progs;
}

# Combine the channels back into a big list.
@progs = ();
foreach (sort keys %chan) {
    push @progs, @{$chan{$_}};
}
unless ($opt_by_channel) {
    # Sort again.  (Could use merge sort.)
    @progs = sort programme_cmp @progs;
}

# Write out the new document
t 'writing out data';
t 'new programmes list: ' . d \@progs;
my %w_args = ();
if (defined $opt_output) {
    my $fh = new IO::File ">$opt_output";
    die "cannot write to $opt_output\n" if not $fh;
    %w_args = (OUTPUT => $fh);
}
XMLTV::write_data([ $encoding, $credits, $channels, \@progs ], %w_args);
exit();


# Compare two programme hashes.
sub programme_cmp() {
    my $xa = $a; my $xb = $b;
    my $r;

    # Assume that {start} is always there, as it should be.
    my ($a_start, $b_start) = (ParseDate($xa->{start}), ParseDate($xb->{start}));
    if (not defined $a_start) {
	die "cannot parse start time: $xa->{start}";
    }
    if (not defined $b_start) {
	die "cannot parse start time: $xb->{start}";
    }
    $r = Date_Cmp($a_start, $b_start);
    t "compare start times: " . d $r;
    return $r if $r;

    # But {stop} is optional.  If both progs have stop we sort on it,
    # otherwise it is not used.  (It doesn't seem right to have
    # undefined values taking part in sort comparisons, and besides,
    # it stops tv_sort from being idempotent.)
    #
    my ($a_stop_u, $b_stop_u) = ($xa->{stop}, $xb->{stop});
    if (defined $a_stop_u and defined $b_stop_u) {
	my ($a_stop, $b_stop) = (ParseDate($a_stop_u), ParseDate($b_stop_u));
	if (not defined $a_stop) {
	    die "cannot parse stop time: $a_stop_u";
	}
	if (not defined $b_stop) {
	    die "cannot parse stop time: $b_stop_u";
	}
	$r = Date_Cmp($a_stop, $b_stop);
	t "compare stop times: " . d $r;
	return $r if $r;
    }

    # Channel.  Ideally would sort on pretty name, but no big deal.
    $r = $xa->{channel} cmp $xb->{channel};
    t "compare channels: " . d $r;
    return $r if $r;

    $r = clumpidx_cmp($xa->{clumpidx}, $xb->{clumpidx});
    t "compare clumpidxes: " . d $r;
    return $r if $r;

    t 'do not sort';
    # No warning, because we'll be weeding out duplicates later.  This
    # routine should just do what it's told and compare.
    #
    return 0;
}


# Compare indexes-within-clump
sub clumpidx_cmp( $$ ) {
    my ($A, $B) = @_;

    if (not defined $A and not defined $B) {
	return 0; # equal
    }
    elsif ((not defined $A and defined $B)
	   or (defined $A and not defined $B)) {
	warn "mismatching clumpidxs: one programme has, one doesn't";
	return undef;
    }
    elsif (defined $A and defined $B) {
	$A =~ m!^(\d+)/(\d+)$! or die "bad clumpidx $A";
	my ($ai, $num_in_clump) = ($1, $2);
	$B =~ m!^(\d+)/(\d+)$! or die "bad clumpidx $B";
	my $bi = $1;
	if ($2 != $num_in_clump) {
	    warn "clumpidx's $A and $B don't match";
	    return undef;
	}
	
	return $ai <=> $bi;
    }
    else { die }
}


# Test whether two programmes overlap in time.  This takes account of
# start time and stop time, and clumpidx (so two programmes with the same
# start and stop times, but different places within the clump, are not
# considered to overlap).
#
sub overlap( $$ ) {
    my ($xa, $xb) = @_;

    my ($xa_start, $xb_start) = (ParseDate($xa->{start}), ParseDate($xb->{start}));
    die "cannot parse start time: $xa->{start}" if not defined $xa_start;
    die "cannot parse start time: $xb->{start}" if not defined $xb_start;
    my ($xa_stop, $xb_stop);	
    for ($xa->{stop}) {
	if (defined) {
	    $xa_stop = ParseDate($_);
	    die "cannot parse stop time: $_" if not defined $xa_stop;
	}
    }
    for ($xb->{stop}) {
	if (defined) {
	    $xb_stop = ParseDate($_);
	    die "cannot parse stop time: $_" if not defined $xb_stop;
	}
    }

    # If we don't know the stop times we can't do an overlap test; if
    # we know only one stop time we can do only one half of the
    # test.  We assume no overlap if we can't prove otherwise.
    #
    # However, obviously two _identical_ start times on the same
    # channel must overlap, if we make the sensible assumption of
    # nonzero length.
    #
    { local $^W = 0;
      t "xa: $xa_start -| $xa_stop"; t "xb: $xb_start -| $xb_stop" }
    if ((
	 # XB starts while XA on
	 defined $xa_stop and Date_Cmp($xa_start, $xb_start) <= 0
	 and Date_Cmp($xb_start, $xa_stop) < 0
	)
	or (
	    # XA starts while XB on
	    defined $xb_stop and Date_Cmp($xb_start, $xa_start) <= 0
	    and Date_Cmp($xa_start, $xb_stop) < 0
	   )
	or (
	    # XB starts while XA on - because it starts at the same time
	    Date_Cmp($xa_start, $xb_start) == 0
	   )
       ) {
	my $cmp = clumpidx_cmp($xa->{clumpidx}, $xb->{clumpidx});
	if (not defined $cmp) {
	    # No clumpidxes, so must overlap.  (Also happens if
	    # the two indexes were not comparable - but that will
	    # have been warned about already.)
	    #
	    t 'no clumpidxes, overlap';
	    return 1;
	}
	t 'compared clumpidxes: same? ' . not $cmp;
	return not $cmp;
    }
    t 'no time overlap, returning 0';
    return 0;
}


# Add 'stop time' to a list of programmes (hashrefs).
# The stop time of a programme is the start time of the next.
#
# Parameters: reference to list of programmes, sorted by date, to be
# shown consecutively (except for 'clumps').
#
# Modifies the list passed in.
#
sub add_stop( $ ) {
    die 'usage: add_stop(ref to list of programme hashrefs)' if @_ != 1;
    my $l = shift;

    my $this_start; # Start time of current clump
    my $next_start; # Start time of next clump
    my $next_next_start; # Start time of next-but-one clump
    for (my $i = $#$l; $i >= 0; $i--) {
	my $this = $l->[$i];
	my $clumpidx = $this->{clumpidx};
	$clumpidx = '0/1' if not defined $clumpidx;
	$clumpidx =~ s!/\d+$!!; # not interested in clump size
	$clumpidx =~ m!^\d+$! or die "bad clumpidx '$_->{clumpidx}'";
	
	$this_start = $this->{start};
	if (not defined $this->{stop} and defined $next_start) {
	    if ($next_start ne $this_start) {
		$this->{stop} = $next_start;
	    }
	    else {
		# Special handling for overlapping programmes: going
		# backwards in time and finding one programme
		# immediately before another with the same start time.
		# We should guess the stop time to be the same as the
		# stop time for the overlapping programme.
		#
		# This is for the case you have the following three
		# programmes:
		#   A from 00 to ?
		#   A from 00 to ?
		#   B from 01 to 02
		# We need to make the two As have the same stop time.
		#
		$this->{stop} = $next_next_start
		  if defined $next_next_start;
	    }
	}

	if ($clumpidx == 0) {
	    # First programme in clump - we're going backwards, so
	    # next time we will move on to the previous clump.
	    #
	    if (not defined $next_start
		or $this_start ne $next_start) {
		($next_start, $next_next_start) = ($this_start, $next_start);
	    }
	}
    }
}


# Equality of two programmes.  The programme details are just text, so
# we can stringify the whole data structure and compare that.  We do
# assume that Data::Dumper will list hashes in a consistent order.  We
# don't care what the order is, just as long as it's the same each
# time.
#
sub programme_eq( $$ ) {
    t 'comparing programmes ' . d($_[0]) . ' and ' . d($_[1]);
    my $r = Dumper($_[0]) eq Dumper($_[1]);
    t "equal? $r";
    return $r;
}
