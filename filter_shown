#!/usr/bin/perl -w
# 
# filter_shown
# 
# Filter TV listings, removing programmes that would have already
# finished at a given date and time (defaults to now).
# 
# Usage: filter_shown [-d date] [filename]
# 
# Reads from filename, or stdin if no filename given, and writes
# filtered XML to stdout.
# 
# -- Ed Avis, epa98@doc.ic.ac.uk, 2000-06-27
# 

use strict;
use XML::DOM;
use Date::Manip;
use Getopt::Std;

use vars '$opt_d';
getopt('d');
$opt_d = 'today' if not defined $opt_d;
my $now = ParseDate($opt_d);

die "usage: $0 [-d date] [filename]" if @ARGV >= 2;
@ARGV = ('-') if not @ARGV;

my $p = new XML::DOM::Parser;
my $doc = $p->parsefile($ARGV[0]);
my $nodes = $doc->getElementsByTagName('programme');
my $n = $nodes->getLength();

my %missing_stop;
for (my $i = 0; $i < $n; $i++) {
    my $node = $nodes->item($i);
    my $stop = $node->getAttribute('stop');
    if (not defined $stop or $stop eq '') {
	# This programme has no stop time, we cannot filter it.  The
	# user may have forgotten to add the stop times with
	# sort_listings, so we should give a warning.  But OTOH, the
	# last programme on each channel will never have a stop time
	# added by sort_listings.  So the heuristic is: warn if we get
	# more than one programme on a channel without stop time.
	# 
	if ($missing_stop{$node->getAttribute('channel')}++) {
	    warn('programme at ' . $node->getAttribute('start') .
		 ' on ' . $node->getAttribute('channel') .
		 ' has no stop time, not filtering ' .
		 '(maybe use sort_listings to add stop time?)');
	}
	next;
    }
    my $stop_d = ParseDate($stop);
    if (Date_Cmp($now, $stop_d) >= 0) {
	# Programme has already finished, remove it.
	$doc->getDocumentElement()->removeChild($node);
    }
}

$doc->printToFileHandle(\*STDOUT);
