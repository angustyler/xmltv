#!/usr/bin/perl -w

=head1 NAME

tv_grab_nl - Grab TV listings for Holland.

=head1 SYNOPSIS

tv_grab_fi --help

tv_grab_fi [--config-file FILE] --configure

tv_grab_fi [--config-file FILE] [--output FILE] [--days N]
           [--offset N] [--quiet] [--slow]

=head1 DESCRIPTION

Output TV listings for several channels available in Holland.
The data comes from www.tvgids.nl. The grabber relies on
parsing HTML so it might stop working at any time.

First run B<tv_grab_nl --configure> to choose, which channels you want
to download. Then running B<tv_grab_nl> with no arguments will output
listings in XML format to standard output.

B<--configure> Prompt for which channels,
and write the configuration file.

B<--config-file FILE> Set the name of the configuration file, the
default is B<~/.xmltv/tv_grab_nl.conf>.  This is the file written by
B<--configure> and read when grabbing.

B<--output FILE> write to FILE rather than standard output.

B<--days N> grab N days.  The default is five.

B<--offset N> start N days in the future.  The default is to start
from today.

B<--slow> Fetch full programme details from the site.  This gives
richer output but involves many more page fetches.

B<--quiet> suppress the progress messages normally written to standard
error.

=head1 SEE ALSO

L<xmltv(5)>.

=head1 AUTHOR

Guido Diepen and Ed Avis (ed@membled.com).  Originally based on
tv_grab_fi by Matti Airas.

=head1 BUGS

The data source does not include full channels information and the
channels are identified by short names rather than the RFC2838 form
recommended by the XMLTV DTD.

Further more the program will not be able to parse programs that are
not having both start and end time defined. This will be something
that I will look at

I havenE<39>t even considered what happens with DST issues.

=cut

######################################################################
# initializations

use strict;
use Getopt::Long;
use LWP::Simple ();
use HTML::TreeBuilder;
use HTML::Entities; # parse entities
use IO::File;

use Date::Manip;
# We do this so that the dates appearing in web pages can be parsed.
# But this means we have to use Dutch in _all_ calls to ParseDate().
# Aargh!
#
Date_Init('Language=Dutch');

use XMLTV;
use XMLTV::Memoize;
use XMLTV::Ask;
# Todo: perhaps we should internationalize messages and docs?
use XMLTV::Usage <<END
$0: get Dutch television listings in XMLTV format
To configure: $0 --configure [--config-file FILE]
To grab listings: $0 [--config-file FILE] [--output FILE] [--days N]
        [--offset N] [--quiet] [--slow]
END
  ;

# Use Log::TraceMessages if installed.
BEGIN {
    eval { require Log::TraceMessages };
    if ($@) {
	*t = sub {};
	*d = sub { '' };
    }
    else {
	*t = \&Log::TraceMessages::t;
	*d = \&Log::TraceMessages::d;
	Log::TraceMessages::check_argv();
    }
}

# Use Term::ProgressBar if installed.
use constant Have_bar => eval { require Term::ProgressBar; 1 };

# Whether zero-length programmes should be included in the output.
my $WRITE_ZERO_LENGTH = 0;

# Timezone string appended to all dates.  FIXME this will break with a
# change to daylight saving time.
#
my $TZ = '+0100';

# default language
my $LANG = 'nl';

######################################################################
# get options

# Get options, including undocumented --cache option.
XMLTV::Memoize::check_argv('get_courteous_aux');
my ($opt_days, $opt_offset, $opt_help, $opt_output,
    $opt_configure, $opt_config_file, $opt_quiet,
    $opt_list_channels, $opt_slow);
$opt_days   = 5; # default
$opt_offset = 0; # default
GetOptions('days=i'        => \$opt_days,
	   'offset=i'      => \$opt_offset,
	   'help'          => \$opt_help,
	   'configure'     => \$opt_configure,
	   'config-file=s' => \$opt_config_file,
	   'output=s'      => \$opt_output,
	   'quiet'         => \$opt_quiet,
	   'slow'	   => \$opt_slow,
	   'list-channels' => \$opt_list_channels,
	  )
  or usage(0);
die 'number of days must not be negative'
  if (defined $opt_days && $opt_days < 0);
usage(1) if $opt_help;

# File that stores which channels to download.
my $CONFIG_FILE = $opt_config_file;
if (not defined $CONFIG_FILE) {
    if (defined($ENV{HOME})) {
	my $conf_dir = "$ENV{HOME}/.xmltv";
	(-d $conf_dir) or mkdir($conf_dir, 0777)
	  or die "cannot mkdir $conf_dir: $!";
	$CONFIG_FILE = "$conf_dir/tv_grab_nl.conf";
    }
    else {
	# $HOME not set, use current directory.
	$CONFIG_FILE = 'tv_grab_nl.conf';
    }
}

# FIXME commonize this configuration stuff within the XMLTV project.
if ($opt_configure) {
    if (-e $CONFIG_FILE) {
	print <<END
The configuration file $CONFIG_FILE already exists.  There is
currently no support for altering an existing configuration, you have
to reconfigure from scratch.

END
  ;
	if (not askBooleanQuestion
	    ('Do you wish to overwrite the old configuration?', 0)) {
	    print "Exiting.\n";
	    exit 0;
	}
    }

    open(CONF, ">$CONFIG_FILE") or die "cannot write to $CONFIG_FILE: $!";
    # find list of available channels
    my $bar = new Term::ProgressBar('getting list of channels', 1)
      if Have_bar && not $opt_quiet;
    my %channels = get_channels();
    die 'no channels could be found' if (scalar(keys(%channels)) == 0);
    update $bar if Have_bar && not $opt_quiet;

    my $answer;
    my $answer_all;

    foreach my $ch_did (sort(keys %channels)) {
	my $ch_name = $channels{$ch_did};
	if ($answer_all) {
	    print($answer eq 'yes' ? 'adding' : 'ignoring',
		  " new channel $ch_name\n");
	}
	else {
	    $answer = askQuestion("add channel $ch_name?", 'yes',
				'yes', 'no', 'all', 'none');
	    if ( $answer eq 'all' ) {
		$answer_all = 1;
		$answer = 'yes';
	    }
	    elsif ( $answer eq 'none' ) {
		$answer_all = 1;
		$answer = 'no';
	    }
	}
	
	if ($answer eq 'yes') {
	    print CONF "channel $ch_did $ch_name\n";
	}
	else {
	    print CONF "# channel $ch_did $ch_name\n";
	}
    }
    close CONF or warn "cannot close $CONFIG_FILE: $!";
    print "All done, run with no arguments to grab listings.\n";

    exit();
}

# Not configuring, we will need to write some output.
my %w_args;
if (defined $opt_output) {
    my $fh = new IO::File(">$opt_output");
    die "cannot write to $opt_output: $!" if not defined $fh;
    $w_args{OUTPUT} = $fh;
}
$w_args{encoding} = 'ISO-8859-1';
my $writer = new XMLTV::Writer(%w_args);
# TODO: standardize these things between grabbers.
$writer->start
  ({ 'source-info-url'     => 'http://www.tvgids.nl/',
     'source-data-url'     => 'http://www.tvgids.nl/',
     'generator-info-name' => 'XMLTV',
     'generator-info-url'  => 'http://membled.com/work/apps/xmltv/',
   });

if ($opt_list_channels) {
    my $bar = new Term::ProgressBar('getting list of channels', 1)
      if Have_bar && not $opt_quiet;
    my %channels = get_channels();
    die 'no channels could be found' if (scalar(keys(%channels)) == 0);
    update $bar if Have_bar && not $opt_quiet;

    foreach my $ch_did (sort(keys %channels)) {
	my $ch_name = $channels{$ch_did};
	my $ch_xid = "$ch_did.tvgids.nl";
	$writer->write_channel({ id => $ch_xid,
				 'display-name' => [ [ $ch_name ] ] });
    }
    $writer->end();
    exit();
}

# Not configuring or writing channels, must be grabbing listings.
if (-e $CONFIG_FILE) {
    print STDERR "using config file $CONFIG_FILE\n" unless $opt_quiet;
}
else {
    die "config file $CONFIG_FILE does not exist, run me with --configure\n";
}
my (%channels, @channels, $ch_did, $ch_name);
open(CONF, $CONFIG_FILE) or die "cannot read $CONFIG_FILE: $!\n";
while (<CONF>) {
    s/\#.*//; s/^\s+//; s/\s+$//;
    next if not length;

    # FIXME channel data should be read from the site, and then the
    # config file only gives the XMLTV ids that are interesting.
    #
    if (/^channel:?\s+(\S+)\s+([^\#]+)/) {
	$ch_did = $1;
	$ch_name = $2;
	$ch_name =~ s/\s*$//;
	push @channels, $ch_did;
	$channels{$ch_did} = $ch_name;
    }
    elsif (/^\#/) {
	# just ignore comments
    }
    else {
	warn "$CONFIG_FILE:$.: bad line\n";
    }
}
close(CONF); # close the configuration file as well

######################################################################
# begin main program

my $now = DateCalc(ParseDate('nu'), "+ $opt_offset dagen");
die if not defined $now;

my @to_get;

# the order in which we fetch the channels matters
my $today = UnixDate($now, '%Y-%m-%d'); die if not defined $today;
foreach $ch_did (@channels) {
    $ch_name = $channels{$ch_did};
    my $ch_xid = "$ch_did.tvgids.nl";
    $writer->write_channel({ id => $ch_xid,
			     'display-name' => [ [ $ch_name ] ] });
    for (my $i = $opt_offset;$i<($opt_offset + $opt_days);$i++) {
	push @to_get, [ $i, $ch_xid, $ch_did ];
    }
}

my %warned_ch_name; # suppress duplicate warnings
if (not $opt_slow) {
    my $bar = new Term::ProgressBar('downloading listings', scalar @to_get)
      if Have_bar && not $opt_quiet;
    foreach (@to_get) {
	my ($day_num, $ch_xmltv_id, $ch_tvgids_id) = @$_;

	my $day_offset = $day_num - 1; die unless $day_offset >= 0;
	my $date = DateCalc($today, "+ $day_offset dagen");
	die if not defined $date;
	my $day = UnixDate($date, '%Y-%m-%d'); die if not defined $day;
	my $url = "http://www.tvgids.nl/zoekprogramma.php?station=$ch_tvgids_id&interval=$day_num";
	local $SIG{__WARN__} = sub {
	    warn "$url: $_[0]";
	};
	local $SIG{__DIE__} = sub {
	    die "$url: $_[0]";
	};
	my $t = new HTML::TreeBuilder;
	$t->parse(get_courteous($url));
	my %interesting; ++ $interesting{$_} foreach
	  qw(lijst_zender lijst_tijd details_programma);
	my @elems = $t->look_down(sub { die if not defined $_[0];
					my $c = $_[0]->attr('class');
					return 0 if not defined $c;
					return $interesting{$c} });
	if (not @elems) {
	    warn 'did not find any programmes in page';
	    next;
	}
	my @bits;
	foreach (@elems) {
	    my $class = $_->attr('class');
	    my @cont = $_->content_list();
	  check_content:
	    if (not @cont) {
		warn "found $class elem without content, ignoring"
		  unless $class eq 'lijst_zender';
		next;
	    }
	    elsif (@cont == 1) {
		for ($cont[0]) {
		    if (ref) {
			# Unpack this extra layer of element.
			@cont = $_->content_list();
			goto check_content;
		    }
		    s/^\s+//; s/\s+$//;
		    push @bits, [ $class, $_ ];
		}
	    }
	    elsif (@cont > 1) {
		warn "found $class elem with more than one elem inside, ignoring";
		next;
	    }
	}
	$t->delete();
	if ($bits[0]->[0] eq 'lijst_zender') {
	    my $d = ParseDate($bits[0]->[1]);
	    if (defined $d) {
		die "date in page $d doesn't match expected $day"
		  if UnixDate($d, '%Q') ne UnixDate($day, '%Q');
		shift @bits;
	    }
	    # otherwise, leave it for later processing
	}
#	use Log::TraceMessages qw(t d);
#	$Log::TraceMessages::On = 1;
#	t 'bits: ' . d \@bits;
	while (@bits >= 3) {
	    my $ch_bit = shift @bits;
	    my $ch_class = $ch_bit->[0];
	    if ($ch_class ne 'lijst_zender') {
		warn "bit expected to be channel name has class $ch_class not lijst_zender, skipping";
		next;
	    }
	    my $ch = $ch_bit->[1];
	    
	    my $times_bit = shift @bits;
	    my $times_class = $times_bit->[0];
	    if ($times_class ne 'lijst_tijd') {
		warn "bit expected to be times has class $times_class not lijst_tijd, skipping";
		next;
	    }
	    my $times = $times_bit->[1];
	    
	    my $title_bit = shift @bits;
	    my $title_class = $title_bit->[0];
	    if ($title_class ne 'details_programma') {
		warn "bit expected to be title has class $title_class not details_programma, skipping";
		next;
	    }
	    my $title = $title_bit->[1];
	    
	    # Right, got channel name, times, and title.
	    # FIXME should check channel name (among other things).
	    unless ($times =~ /^(\d\d):(\d\d)-(\d\d):(\d\d)$/
		    and 0 <= $1 and $1 < 24 and 0 <= $2 and $2 < 60
		    and 0 <= $3 and $3 < 24 and 0 <= $4 and $4 < 60) {
		warn "bad programme times $times, skipping ($ch, $times, $title)";
		next;
	    }
	    my ($start_hh, $start_mm, $stop_hh, $stop_mm) = ($1, $2, $3, $4);
	    die if not defined $day;
	    my $start = ParseDate("$day $start_hh:$start_mm");
	    die if not defined $start;
	    my $stop = ParseDate("$day $stop_hh:$stop_mm");
	    die if not defined $stop;
	    if (Date_Cmp($start, $stop) > 0) {
		$day = UnixDate(DateCalc($day, '+ 1 dag'), '%Y-%m-%d');
		my $stop = ParseDate("$day $stop_hh:$stop_mm");
		die if not defined $stop;
		die unless Date_Cmp($start, $stop) < 0;
	    }
	    
	    $writer->write_programme({ start => UnixDate($start, '%q') . " $TZ",
				       stop => UnixDate($stop, '%q') . " $TZ",
				       channel => $ch_xmltv_id,
				       title => [ [ $title, $LANG ] ] });
	}
	foreach (@bits) {
	    my ($type, $text) = @$_;
	    if ($type eq 'lijst_zender' and $text eq 'Volgende') {
		# To be expected.
	    }
	    else {
		warn "discarding leftover $type: $text";
	    }
	}
	update $bar if Have_bar and not $opt_quiet;
    }
}
else {
    # Slow mode, get details separately.
    # FIXME should check consistency between details and summary.
    #
    my $bar = new Term::ProgressBar('first pass', scalar @to_get)
      if Have_bar && not $opt_quiet;
    my @to_get_detailed;
    my $num_detailed = 0;
    foreach (@to_get) {
	my ($date, $ch_xmltv_id, $ch_tvgids_id) = @$_;
	my $today = UnixDate($date, '%Y-%m-%d');
	my $url = "http://www.tvgids.nl/zoekprogramma.php?station=$ch_tvgids_id&interval=$date";
	my @detail_urls = detail_urls(get_courteous($url), $url);
	push @to_get_detailed, [ $ch_xmltv_id, \@detail_urls ];
	$num_detailed += @detail_urls;
	update $bar if Have_bar && not $opt_quiet;
    }
    $bar = new Term::ProgressBar('getting details', $num_detailed)
      if Have_bar && not $opt_quiet;
    my @got_detailed;
    foreach (@to_get_detailed) {
	write_details($writer, $_->[0], $_->[1], $bar);
    }
}

$writer->end();

######################################################################
# subroutine definitions

my (%warned_regel, $warned_discarding_parts); # suppress duplicate warnings

sub detail_urls {
    my ($data, $url) = @_;
    local $SIG{__WARN__} = sub {
	warn "$url: $_[0]";
    };
    local $SIG{__DIE__} = sub {
	die "$url: $_[0]";
    };
    my $t = new HTML::TreeBuilder;
    $t->parse($data);
    my @elems = $t->look_down('_tag' => 'A', 'class' => 'details_programma');
    if (not @elems) {
	local $Log::TraceMessages::On = 1;
	t "did not see details_programma <A>s in HTML:\n$data\n";
	die 'did not see any programmes in page';
    }
    my @r;
    foreach (@elems) {
	for ($_->attr('href')) {
	    die "<A> element $_ without 'href' attribute" if not defined;
	    s!^/+!!;
	    push @r, "http://www.tvgids.nl/$_";
	}
    }
    $t->delete();
    return @r;
}

# arguments:
#    XMLTV::Writer object to write to
#    xmltv id of channel
#    ref to list of URLs for programme detail pages
#    progress bar object to update (or undef)
#
# The list of URLs should correspond to a single page for one channel
# (at the moment).
#
sub write_details {
    my ($writer, $ch_xmltv_id, $urls, $bar) = @_;
    my $next_day = 0;
    my $last_van;

    foreach my $url (@$urls) {
	local $SIG{__WARN__} = sub {
	    warn "$url: $_[0]";
	};

	# We make an HTML::TreeBuilder object, get the information
	# from it and them delete it.
	#
	my $t = new HTML::TreeBuilder();
	$t->parse(get_courteous($url));
	my @elems = $t->look_down(class => 'detailDeel');
	if (not @elems) {
	    warn "did not see any 'detailDeel' elements, skipping page";
	    next;
	}
	my @info;
	foreach (@elems) {
	    my @cont = grep { ref } $_->content_list();
	    my $n = scalar @cont;
	    if ($n != 2) {
		warn "'detailDeel' has $n elements instead of 2";
		next;
	    }
	    my ($k, $v) = @cont;
	    for ($k->attr('class')) {
		if (not defined or $_ ne 'detailLabel2') {
		    warn "didn't see 'detailLabel2' in 'detailDeel'";
		    next;
		}
	    }
	    for ($v->attr('class')) {
		if (not defined or $_ ne 'detailContent2') {
		    warn "didn't see 'detailContent2' in 'detailDeel'";
		    next;
		}
	    }
	    push @info, [ $k->as_text(), $v->as_text() ];
	}
	$t->delete();

	# Process the list of [ heading, data ] pairs.
	my ($van, $tot, # exactly one
	    $naam, $sub_title, $genre, $date,               #
	    $episode_num, $actors, $writers, $commentators, #
	    $director, $previously_shown,                   # at most one
	    @presenter, @url # zero or more
	   );
	# NB 'at most one' $actors but that one entry can give several

	my $teletext_sub = 0;  # boolean
	my @desc;              # accumulate bits
	my $seen_tijdstip = 0;
   	my $last; 
      ELEM: foreach (@info) {
	    my ($regel, $text) = @$_;
	    foreach ($regel, $text) {
		s/^\s+//; s/\s+$//;
	    }
	    if ($regel eq '') {
		# Continuation of the previous one, hopefully.
		$regel = $last;
	    }
	    else {
		# They usually end with a colon but not always.
		$regel =~ s/:$//;
		$last = $regel;
	    }
	    if ($regel eq 'Tijdstip') {
		warn "seen 'Tijdstip' twice\n" if $seen_tijdstip++;
		if (length($text)<=16) {
		    # 'onvolledig' condition is true, nothing more to
		    # write. 
		    #
		    return;
		}
		else {
		    $van = time_van_str($text);
		    warn if not defined $van;
		    $tot = time_tot_str($text);
		    warn if not defined $tot;
		}
	    }
	    elsif ($regel eq 'Inhoud') {
		# Empty text for this happens often, just skip it.
		push @desc, $text if $text ne '';
	    }
	    elsif ($regel eq 'Programma') {
		warn "seen 'Programma' twice\n" if defined $naam;
		# FIXME should really look for 'herhaling' in italics.
		if ($text =~ s/\bherhaling\s+van\s+(\d\d?)-(\d\d?)-(\d{4})//) {
		    warn "seen previously-shown information twice\n"
		      if $previously_shown;
		    my ($dd, $mm, $yyyy) = ($1, $2, $3);
		    $previously_shown = { start => "$yyyy$mm$dd" };
		    $text =~ s/^\s+//; $text =~ s/\s+$//;
		}
		elsif ($text =~ s/\bherhaling\b//) {
		    # Repeat, but no previous date given.
		    $previously_shown = {};
		    $text =~ s/^\s+//; $text =~ s/\s+$//;
		}
		$naam = $text; 
	    }
	    elsif ($regel eq 'Genre') {
		warn "seen 'Genre' twice\n" if defined $genre;
		$genre = $text; 
	    }
	    elsif ($regel eq 'Zender') {
		# I think this means 'broadcaster' but the information
		# is rendundant because we already know the channel.
		#
		# Then we should check it and warn if it differs!  But
		# it does differ - every programme on the channel
		# Nederland 1, it seems, has Zender of 'Nederland
		# 2'. So we just ignore this information.
		#
	    }
	    elsif ($regel eq 'Omroep') {
		# FIXME I don't know what this means (the dictionary
		# says 'wireless telegraph' but that's no help) so
		# just ignore it.
		#
	    }
	    elsif ($regel eq 'Kenmerken') {
		foreach (split /,\s*/, $text) {
		    if ($_ eq 'Teletekst ondertiteld') {
			# I'm guessing this means teletext subtitles :-).
			$teletext_sub++
			  && warn 'seen teletext subtitles twice';
		    }
		    elsif ($_ eq 'Breedbeeld uitzending') {
			# FIXME I don't know what this means.
			push @desc, $_;
		    }
		    else {
			warn "unknown 'Kenmerken' bit $_"
			  unless $warned_regel{"Kenmerken: $_"}++;	
			push @desc, $_;
		    }
		}
	    }
	    elsif ($regel eq 'Presentatie') {
		push @presenter, $text;
	    }
	    elsif ($regel eq 'Afleverings nummer') {
		warn "seen 'Afleverings nummer' twice"
		  if defined $episode_num;
		if ($text eq 'Slot') {
		    # I don't really know what this means but assume
		    # it means the same as no episode number at all.
		    #
		}
		elsif ($text =~ /^\d+$/) {
		    if ($text == 0) {
			warn "I thought episode nums on the site were from 1";
		    }
		    else {
			$episode_num = $text - 1;
		    }
		}
		else {
		    warn "bad episode number $text";
		}
	    }
	    elsif ($regel eq 'Titel aflevering') {
		warn "seen 'Titel aflevering' twice"
		  if defined $sub_title;
		$sub_title = $text;
	    }
	    elsif ($regel eq 'Webpagina') {
		# We have to turn the string given, which is normally
		# just a hostname, into a URL.  I don't see why they
		# don't just link to it directly, this is a web site
		# after all.
		#
		# Anyway, the URI library doesn't seem to have any way
		# to take a string and turn it into a URL adding
		# 'http:' if necessary, so we do this by hand.
		#
		if ($text !~ tr/://) {
		    $text = "http://$text";
		}
		push @url, $text;
	    }
	    elsif ($regel eq 'Rolverdeling') {
		warn "seen 'Rolverdeling' twice" if $actors;

		# Maybe 'e.a' is Latin for 'and others' or something.
		$text =~ s/\s*e\.a\s*$//;
	    
		while (length $text) {
		    if ($text =~ s/\s*([^:]+):\s*([^.]+)(?:$|\.)//) {
			warn "discarding information about the parts played by each actor\n"
			  unless $warned_discarding_parts++;
			push @$actors, $2;
		    }
		    elsif ($text =~ s/\s*([^,]+)(?:$|,)//) {
			push @$actors, $1;
		    }
		    else {
			warn "unknown remnamt 'Rolverdeling' text '$text'";
			last;
		    }
		}
	    }
	    elsif ($regel eq 'Scenario schrijver') {
		warn "seen 'Scenario schrijver' twice" if $writers;
		push @$writers, $text;
	    }
	    elsif ($regel eq 'E-mail') {
		push @url, "mailto:$text";
	    }
	    elsif ($regel eq 'Bron') {
		# FIXME cannot do anything special with this.  It
		# means 'source' and perhaps by parsing the text we
		# could find the names of writers or whatever.
		#
		push @desc, "$regel: $text";
	    }
	    elsif ($regel eq 'Commentaar') {
		push @$commentators, $text;
	    }
	    elsif ($regel eq 'Jaar van premiere') {
		# Year of release, I think.
		warn "seen 'Jaar van premiere' twice"
		  if defined $date;
		$date = $text;
	    }
	    elsif ($regel eq 'Regisseur') {
		warn "seen 'Regisseur' twice" if defined $director;
		$director = $text;
	    }
	    else {
		# Unknown key, but let's add it to the desc so we
		# don't lose information.  These newlines are just for
		# the benefit of someone reading the XML by hand.
		#
		push @desc, "$regel: $text";
		warn "unknown programme info key $regel\n"
		  unless $warned_regel{$regel}++;
	    }
	}

	if (not defined $naam) {
	    warn "did not see programme title, skipping programme\n";
	    next;
	}
	if (not defined $van) {
	    warn "did not see programme times, skipping programme\n";
	    next;
	}
	die if not defined $tot;

	$van = DateCalc($van, '+ 1 dag') if $next_day;
	$tot = DateCalc($tot, '+ 1 dag') if $next_day;
	if (Date_Cmp($van, $tot) > 0) {
	    # Programme appears to end after it began.  Must span
	    # days. 
	    #
	    if ($next_day++) {
		warn "seeming to span more than one midnight, skipping rest of page";
		return;
	    }
	    $tot = DateCalc($tot, '+ 1 dag');
	}
	if (defined $last_van and Date_Cmp($last_van, $van) > 0) {
	    # Appear to have gone backwards since the last programme.
	    # Again, must have crossed midnight.
	    #
	    if ($next_day++) {
		warn "seeming to span more than one midnight, skipping rest of page";
		return;
	    }
	    $van = DateCalc($van, '+ 1 dag');
	    $tot = DateCalc($tot, '+ 1 dag');
	}
	$last_van = $van;

	my %prog
	  = (channel  => $ch_xmltv_id,
	     title    => [ [ $naam,  $LANG ] ],
	     start    => UnixDate($van, '%q') . " $TZ",
	     stop     => UnixDate($tot, '%q') . " $TZ",
	    );
	
	# We have lots of bits of description.  But we make them
	# into a single <desc> element because they probably give
	# different information, rather than stating the same
	# information in different ways.
	#
	$prog{desc} = [ [ join("\n\n", @desc), $LANG ] ] if @desc;
	
	$prog{'sub-title'} = [ [ $sub_title, $LANG ] ] if defined $sub_title;
	$prog{subtitles} = [ { type => 'teletext' } ] if $teletext_sub;
	$prog{credits} = { presenter => \@presenter } if @presenter;
	$prog{'episode-num'} = [ $episode_num ] if defined $episode_num;
	$prog{url} = \@url if @url;
	$prog{date} = $date if defined $date;
	$prog{category} = [ [ $genre, $LANG ] ] if defined $genre;
	$prog{'previously-shown'} = $previously_shown if $previously_shown;
	
	my %c;
	$c{actor} = $actors if $actors;
	$c{writer} = $writers if $writers;
	$c{commentator} = $commentators if $commentators;
	$c{director} = [ $director ] if $director;
	$prog{credits} = \%c if %c;
	
	$writer->write_programme(\%prog);
	update $bar if $bar;
    }
}

sub time_tot_str {
    my $input = shift; 
    if (length($input) == 15) {
	$input .= '05:00'; 
    }
    my $datum = substr($input,0,length($input)-11); 
    my $tot   = substr($input,-5); 

    $datum =~ /(\d\d?)-(\d\d?)-(\d+)/
      or die "cannot find year in '$datum'";
    my ($dd, $mm, $yyyy) = ($1, $2, $3);
    foreach ($dd, $mm) { $_ = "0$_" if length == 1 }
    $tot =~ /(\d\d):(\d\d)/
      or die "cannot find time in '$tot'";
    my ($HH, $MM) = ($1, $2);

    my $str = "$yyyy-$mm-$dd $HH:$MM:00";
    my $p = ParseDate($str);
    die "could not parse date $str" if not defined $p or not length $p;
    my $r = UnixDate($p, '%q');
    die "could not call UnixDate() on $p" if not defined $r;
    return $r;
}
sub time_van_str {
    my $input = shift; 
    if (length($input) == 15) {
	$input .= '06:00'; 
    }
    my $datum = substr($input,0,length($input)-11); 
    my $van = substr($input,-11); 
    $van = substr($van,0,5); 

    $datum =~ /(\d\d?)-(\d\d?)-(\d{4})/
      or die "cannot find year in '$datum'";
    my ($dd, $mm, $yyyy) = ($1, $2, $3);
    foreach ($dd, $mm) { $_ = "0$_" if length == 1 }
    $van =~ /(\d\d):(\d\d)/
      or die "cannot find time in '$van'";
    my ($HH, $MM) = ($1, $2);
    my $str = "$yyyy-$mm-$dd $HH:$MM:00";
    my $p = ParseDate($str);
    die "could not parse date $str" if not defined $p or not length $p;
    my $r = UnixDate($p, '%q');
    die "could not call UnixDate() on $p" if not defined $r;
    return $r;
}


# get channel listing
sub get_channels {
    my %channels;
    my $url = 'http://www.tvgids.nl';

    #All stations are in the select box.
    #The station ID is the option value
    my $t = new HTML::TreeBuilder();
    $t->parse(get_courteous($url));
    my @conts = map { [ $_->content_list() ] }
      $t->look_down('_tag' => 'select', 'name' => 'station');
    foreach my $cont (@conts) {
	my @children =@$cont;
	if (scalar(@children) == 0) {
	    warn 'No stations are defined'; 
	    next; 
	}
	foreach my $station_line (@children) {
	    if ($station_line ne ' ') {     
		#This if statement is to prevent parsing the last 
		#empty element from the list.
			
		my $channel_id = $station_line->attr('value'); 
		
		#I am only interested in the normal channels.
		#tvgids.nl has some pages for the regional stations also
		#All normal channels have id <0,100>
		#That is at the moment... Could change in future...
		if ($channel_id > 0 && $channel_id < 100) {
		    my $channel_name = $station_line->as_text(); 
		    $channels{$channel_id} = $channel_name
		}
	    }

	}
    }	
    $t->delete();
    return %channels;
}

sub get_courteous {
    # This is to ensure scalar context, to work around weirdnesses
    # with Memoize (I just can't figure out how SCALAR_CACHE and
    # LIST_CACHE relate to each other, with or without MERGE).
    #
    return scalar get_courteous_aux(@_);
}
# FIXME replace with LWP::RobotUI.
sub get_courteous_aux {
    my $url = shift;
    my $r = LWP::Simple::get($url);

    # At the moment download failures seem rare, so the script dies if
    # any page cannot be fetched.  We could later change this routine
    # to return undef on failure.  But dying here makes sure that a
    # failed page fetch doesn't get stored in XMLTV::Memoize's cache.
    #
    die "could not fetch $url, aborting\n" if not defined $r;

    # Be nice to the server.  Technically we don't need to do this
    # after the very last fetch, but sleeping every time is simpler.
    #
    sleep(rand 5);

    return $r;
}
