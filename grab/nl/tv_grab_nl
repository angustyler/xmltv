#!/usr/bin/perl -w

=head1 NAME

tv_grab_nl - Grab TV listings for Holland.

=head1 SYNOPSIS

tv_grab_fi --help

tv_grab_fi [--config-file FILE] --configure

tv_grab_fi [--config-file FILE] [--output FILE] [--days N]
           [--offset N] [--quiet] [--slow]

=head1 DESCRIPTION

Output TV listings for several channels available in Holland.
The data comes from www.tvgids.nl. The grabber relies on
parsing HTML so it might stop working at any time.

First run B<tv_grab_nl --configure> to choose, which channels you want
to download. Then running B<tv_grab_nl> with no arguments will output
listings in XML format to standard output.

B<--configure> Prompt for which channels,
and write the configuration file.

B<--config-file FILE> Set the name of the configuration file, the
default is B<~/.xmltv/tv_grab_nl.conf>.  This is the file written by
B<--configure> and read when grabbing.

B<--output FILE> write to FILE rather than standard output.

B<--days N> grab N days.  The default is one week.

B<--offset N> start N days in the future.  The default is to start
from today.

B<--slow> Fetch full programme details from the site.  This gives
richer output but involves many more page fetches.

B<--quiet> suppress the progress messages normally written to standard
error.

=head1 SEE ALSO

L<xmltv(5)>.

=head1 AUTHOR

Guido Diepen and Ed Avis (ed@membled.com).  Originally based on
tv_grab_fi by Matti Airas.

=head1 BUGS

The data source does not include full channels information and the
channels are identified by short names rather than the RFC2838 form
recommended by the XMLTV DTD.

Further more the program will not be able to parse programs that are
not having both start and end time defined. This will be something
that I will look at

=cut

######################################################################
# initializations

use strict;
use Getopt::Long;
use HTML::TreeBuilder;
use HTML::Entities; # parse entities
use IO::File;
use URI;
use Date::Manip;
use XMLTV;
use XMLTV::Memoize;
use XMLTV::Ask;
use XMLTV::Config_file;
use XMLTV::Europe_TZ;
use XMLTV::Get_nice;
# Todo: perhaps we should internationalize messages and docs?
use XMLTV::Usage <<END
$0: get Dutch television listings in XMLTV format
To configure: $0 --configure [--config-file FILE]
To grab listings: $0 [--config-file FILE] [--output FILE] [--days N]
        [--offset N] [--quiet] [--slow]
END
  ;

# Use Log::TraceMessages if installed.
BEGIN {
    eval { require Log::TraceMessages };
    if ($@) {
	*t = sub {};
	*d = sub { '' };
    }
    else {
	*t = \&Log::TraceMessages::t;
	*d = \&Log::TraceMessages::d;
	Log::TraceMessages::check_argv();
    }
}

# Use Term::ProgressBar if installed.
use constant Have_bar => eval { require Term::ProgressBar; 1 };

# Function prototypes.
sub detail_urls( $$ );
sub write_details( $$$$$ );
sub time_tot_str( $ );
sub time_van_str( $ );
sub get_channels();
sub process_summary_page( $$$ );
sub parse_dutch_date( $ );

# Whether zero-length programmes should be included in the output.
my $WRITE_ZERO_LENGTH = 0;

# Base timezone for the Netherlands.  Summer time is one hour ahead of
# this.
#
my $TZ = '+0100';

# default language
my $LANG = 'nl';

######################################################################
# get options

# Get options, including undocumented --cache option.
XMLTV::Memoize::check_argv('XMLTV::Get_nice::get_nice_aux');
my ($opt_days, $opt_offset, $opt_help, $opt_output,
    $opt_configure, $opt_config_file, $opt_quiet,
    $opt_list_channels, $opt_slow);
$opt_days   = 7; # default
$opt_offset = 0; # default
GetOptions('days=i'        => \$opt_days,
	   'offset=i'      => \$opt_offset,
	   'help'          => \$opt_help,
	   'configure'     => \$opt_configure,
	   'config-file=s' => \$opt_config_file,
	   'output=s'      => \$opt_output,
	   'quiet'         => \$opt_quiet,
	   'slow'	   => \$opt_slow,
	   'list-channels' => \$opt_list_channels,
	  )
  or usage(0);
die 'number of days must not be negative'
  if (defined $opt_days && $opt_days < 0);
usage(1) if $opt_help;

# File that stores which channels to download.
my $config_file
  = XMLTV::Config_file::filename($opt_config_file, 'tv_grab_nl', $opt_quiet);

if ($opt_configure) {
    XMLTV::Config_file::check_no_overwrite($config_file);
    open(CONF, ">$config_file") or die "cannot write to $config_file: $!";
    # find list of available channels
    my $bar = new Term::ProgressBar('getting list of channels', 1)
      if Have_bar && not $opt_quiet;
    my %channels = get_channels();
    die 'no channels could be found' if (scalar(keys(%channels)) == 0);
    update $bar if Have_bar && not $opt_quiet;

    my $answer;
    my $answer_all;

    foreach my $ch_did (sort(keys %channels)) {
	my $ch_name = $channels{$ch_did};
	if ($answer_all) {
	    print($answer eq 'yes' ? 'adding' : 'ignoring',
		  " new channel $ch_name\n");
	}
	else {
	    $answer = askQuestion("add channel $ch_name?", 'yes',
				'yes', 'no', 'all', 'none');
	    if ( $answer eq 'all' ) {
		$answer_all = 1;
		$answer = 'yes';
	    }
	    elsif ( $answer eq 'none' ) {
		$answer_all = 1;
		$answer = 'no';
	    }
	}
	
	if ($answer eq 'yes') {
	    print CONF "channel $ch_did $ch_name\n";
	}
	else {
	    print CONF "# channel $ch_did $ch_name\n";
	}
    }
    close CONF or warn "cannot close $config_file: $!";
    print "All done, run with no arguments to grab listings.\n";

    exit();
}

# Not configuring, we will need to write some output.
my %w_args;
if (defined $opt_output) {
    my $fh = new IO::File(">$opt_output");
    die "cannot write to $opt_output: $!" if not defined $fh;
    $w_args{OUTPUT} = $fh;
}
$w_args{encoding} = 'ISO-8859-1';
my $writer = new XMLTV::Writer(%w_args);
# TODO: standardize these things between grabbers.
$writer->start
  ({ 'source-info-url'     => 'http://www.tvgids.nl/',
     'source-data-url'     => 'http://www.tvgids.nl/',
     'generator-info-name' => 'XMLTV',
     'generator-info-url'  => 'http://membled.com/work/apps/xmltv/',
   });

if ($opt_list_channels) {
    my $bar = new Term::ProgressBar('getting list of channels', 1)
      if Have_bar && not $opt_quiet;
    my %channels = get_channels();
    die 'no channels could be found' if (scalar(keys(%channels)) == 0);
    update $bar if Have_bar && not $opt_quiet;

    foreach my $ch_did (sort(keys %channels)) {
	my $ch_name = $channels{$ch_did};
	my $ch_xid = "$ch_did.tvgids.nl";
	$writer->write_channel({ id => $ch_xid,
				 'display-name' => [ [ $ch_name ] ] });
    }
    $writer->end();
    exit();
}

# Not configuring or writing channels, must be grabbing listings.
my (%channels, @channels, $ch_did, $ch_name);
my $line_num = 0;
foreach (XMLTV::Config_file::read_lines($config_file)) {
    ++ $line_num;
    next if not defined;

    # FIXME channel data should be read from the site, and then the
    # config file only gives the XMLTV ids that are interesting.
    #
    if (/^channel:?\s+(\S+)\s+(.+)/) {
	$ch_did = $1;
	$ch_name = $2;
	$ch_name =~ s/\s*$//;
	push @channels, $ch_did;
	$channels{$ch_did} = $ch_name;
    }
    else {
	warn "$config_file:$line_num: bad line\n";
    }
}

######################################################################
# begin main program

my $now = DateCalc(ParseDate('now'), "+ $opt_offset days");
die if not defined $now;

my @to_get;

# the order in which we fetch the channels matters
my $today = UnixDate($now, '%Y-%m-%d'); die if not defined $today;
foreach $ch_did (@channels) {
    $ch_name = $channels{$ch_did};
    my $ch_xid = "$ch_did.tvgids.nl";
    $writer->write_channel({ id => $ch_xid,
			     'display-name' => [ [ $ch_name ] ] });
    for (my $i = $opt_offset;$i<($opt_offset + $opt_days);$i++) {
	my $url = 'http://www.tvgids.nl/zoekprogramma.php'
	  . "?station=$ch_did&interval=$i";
	my $day = UnixDate(DateCalc($today, "+ $i days"), '%Y-%m-%d');
	die if not defined $day;
	push @to_get, [ $url, $day, $ch_xid, $ch_did ];
    }
}

my %warned_ch_name; # suppress duplicate warnings
if (not $opt_slow) {
    my $bar = new Term::ProgressBar('downloading listings', scalar @to_get)
      if Have_bar && not $opt_quiet;
    foreach (@to_get) {
	my ($url, $day, $ch_xmltv_id, $ch_tvgids_id) = @$_;
	die if not defined $day;
	foreach (process_summary_page($url, $day, $day)) {
	    my ($start, $stop, $title, $url) = @$_;
	    my ($start_base, $start_tz) = @{date_to_eur($start, $TZ)};
	    my ($stop_base, $stop_tz) = @{date_to_eur($stop, $TZ)};

	    $writer->write_programme
	      ({ start => UnixDate($start_base, '%q') . " $start_tz",
		 stop => UnixDate($stop_base, '%q') . " $stop_tz",
		 channel => $ch_xmltv_id,
		 title => [ [ $title, $LANG ] ],
	       });
	}

	update $bar if Have_bar and not $opt_quiet;
    }
}
else {
    # Slow mode, get details separately.
    # FIXME should check consistency between details and summary.
    #
    my $bar = new Term::ProgressBar('first pass', scalar @to_get)
      if Have_bar && not $opt_quiet;
    my @to_get_detailed;
    my $num_detailed = 0;
    foreach (@to_get) {
	my ($url, $date, $ch_xmltv_id, $ch_tvgids_id) = @$_;
	my @detail_urls = map { $_->[3] } process_summary_page($url, $date, $date);
	push @to_get_detailed, [ $ch_xmltv_id, \@detail_urls, $url ];
	$num_detailed += @detail_urls;
	update $bar if Have_bar && not $opt_quiet;
    }
    $bar = new Term::ProgressBar('getting details', $num_detailed)
      if Have_bar && not $opt_quiet;
    my @got_detailed;
    foreach (@to_get_detailed) {
	write_details($writer, $_->[0], $_->[1], $_->[2], $bar);
    }
}

$writer->end();

######################################################################
# subroutine definitions

my (%warned_regel, $warned_discarding_parts); # suppress duplicate warnings

sub detail_urls( $$ ) {
    my ($data, $url) = @_;
    local $SIG{__WARN__} = sub {
	warn "$url: $_[0]";
    };
    local $SIG{__DIE__} = sub {
	die "$url: $_[0]";
    };
    my $t = new HTML::TreeBuilder;
    $t->parse($data);
    my @elems = $t->look_down('_tag' => 'A', 'class' => 'details_programma');
    if (not @elems) {
	local $Log::TraceMessages::On = 1;
	t "did not see details_programma <A>s in HTML:\n$data\n";
	die 'did not see any programmes in page';
    }
    my @r;
    foreach (@elems) {
	for ($_->attr('href')) {
	    die "<A> element $_ without 'href' attribute" if not defined;
	    s!^/+!!;
	    push @r, "http://www.tvgids.nl/$_";
	}
    }
    $t->delete(); undef $t;
    return @r;
}

# arguments:
#    XMLTV::Writer object to write to
#    xmltv id of channel
#    ref to list of URLs for programme detail pages
#    URL this list was found from (for debugging)
#    progress bar object to update (or undef)
#
# The list of URLs should correspond to a single page for one channel
# (at the moment).
#
sub write_details( $$$$$ ) {
    my ($writer, $ch_xmltv_id, $urls, $master_url, $bar) = @_;
    my $next_day = 0;

    foreach my $url (@$urls) {
	local $SIG{__WARN__} = sub {
	    warn "$url (from $master_url): $_[0]";
	};

	# We make an HTML::TreeBuilder object, get the information
	# from it and them delete it.
	#
	my $t = new HTML::TreeBuilder();
	$t->parse(get_nice($url));
	my @elems = $t->look_down(class => 'detailDeel');
	if (not @elems) {
	    warn "did not see any 'detailDeel' elements, skipping page";
	    next;
	}
	my @info;
	foreach (@elems) {
	    my @cont = grep { ref } $_->content_list();
	    my $n = scalar @cont;
	    if ($n != 2) {
		warn "'detailDeel' has $n elements instead of 2";
		next;
	    }
	    my ($k, $v) = @cont;
	    for ($k->attr('class')) {
		if (not defined or $_ ne 'detailLabel2') {
		    warn "didn't see 'detailLabel2' in 'detailDeel'";
		    next;
		}
	    }
	    for ($v->attr('class')) {
		if (not defined or $_ ne 'detailContent2') {
		    warn "didn't see 'detailContent2' in 'detailDeel'";
		    next;
		}
	    }
	    push @info, [ $k->as_text(), $v->as_text() ];
	}
	$t->delete(); undef $t;

	# Process the list of [ heading, data ] pairs.
	my ($van, $tot, # exactly one
	    $naam, $sub_title, $genre, $date,               #
	    $episode_num, $actors, $writers, $commentators, #
	    $director, $previously_shown, $orig_title,      # at most one
	    @presenter, @url # zero or more
	   );
	# NB 'at most one' $actors but that one entry can give several

	my $teletext_sub = 0;  # boolean
	my @desc;              # accumulate bits
	my $seen_tijdstip = 0;
   	my $last; 
      ELEM: foreach (@info) {
	    my ($regel, $text) = @$_;
	    foreach ($regel, $text) {
		s/^\s+//; s/\s+$//;
	    }
	    if ($regel eq '') {
		# Continuation of the previous one, hopefully.
		$regel = $last;
	    }
	    else {
		# They usually end with a colon but not always.
		$regel =~ s/:$//;
		$last = $regel;
	    }
	    if ($regel eq 'Tijdstip') {
		warn "seen 'Tijdstip' twice\n" if $seen_tijdstip++;
		if (length($text)<=16) {
		    # 'onvolledig' condition is true, nothing more to
		    # write. 
		    #
		    return;
		}
		else {
		    $van = time_van_str($text);
		    warn if not defined $van;
		    $tot = time_tot_str($text);
		    warn if not defined $tot;
		}
	    }
	    elsif ($regel eq 'Inhoud') {
		# Empty text for this happens often, just skip it.
		push @desc, $text if $text ne '';
	    }
	    elsif ($regel eq 'Programma') {
		warn "seen 'Programma' twice\n" if defined $naam;
		# FIXME should really look for 'herhaling' in italics.
		if ($text =~ s/\bherhaling\s+van\s+(\d\d?)-(\d\d?)-(\d{4})//) {
		    warn "seen previously-shown information twice\n"
		      if $previously_shown;
		    my ($dd, $mm, $yyyy) = ($1, $2, $3);
		    $previously_shown = { start => "$yyyy$mm$dd" };
		    $text =~ s/^\s+//; $text =~ s/\s+$//;
		}
		elsif ($text =~ s/herhaling\b//) {
		    # Repeat, but no previous date given.  NB
		    # sometimes we see 'herhaling' without a space
		    # before it, as in the redundant
		    #
		    # 'Netwerk herhalingenherhaling'
		    #
		    # Hence no \b at the start of the regexp.  We just
		    # have to hope there aren't too many compound
		    # words ending in 'herhaling'.
		    #
		    $previously_shown = {};
		    $text =~ s/^\s+//; $text =~ s/\s+$//;
		}
		$naam = $text; 
	    }
	    elsif ($regel eq 'Genre') {
		warn "seen 'Genre' twice\n" if defined $genre;
		$genre = $text; 
	    }
	    elsif ($regel eq 'Zender') {
		# I think this means 'broadcaster' but the information
		# is rendundant because we already know the channel.
		#
		# Then we should check it and warn if it differs!  But
		# it does differ - every programme on the channel
		# Nederland 1, it seems, has Zender of 'Nederland
		# 2'. So we just ignore this information.
		#
	    }
	    elsif ($regel eq 'Omroep') {
		# FIXME I don't know what this means (the dictionary
		# says 'wireless telegraph' but that's no help) so
		# just ignore it.
		#
	    }
	    elsif ($regel eq 'Kenmerken') {
		foreach (split /,\s*/, $text) {
		    if ($_ eq 'Teletekst ondertiteld') {
			# I'm guessing this means teletext subtitles :-).
			$teletext_sub++
			  && warn 'seen teletext subtitles twice';
		    }
		    elsif ($_ eq 'Breedbeeld uitzending') {
			# FIXME I don't know what this means.
			push @desc, $_;
		    }
		    else {
			warn "unknown 'Kenmerken' bit $_"
			  unless $warned_regel{"Kenmerken: $_"}++;	
			push @desc, $_;
		    }
		}
	    }
	    elsif ($regel eq 'Presentatie') {
		push @presenter, $text;
	    }
	    elsif ($regel eq 'Afleverings nummer') {
		warn "seen 'Afleverings nummer' twice"
		  if defined $episode_num;
		if ($text eq 'Slot') {
		    # I don't really know what this means but assume
		    # it means the same as no episode number at all.
		    #
		}
		elsif ($text =~ /^\d+$/) {
		    if ($text == 0) {
			warn "I thought episode nums on the site were from 1";
		    }
		    else {
			$episode_num = $text - 1;
		    }
		}
		else {
		    warn "bad episode number $text";
		}
	    }
	    elsif ($regel eq 'Titel aflevering') {
		warn "seen 'Titel aflevering' twice"
		  if defined $sub_title;
		$sub_title = $text;
	    }
	    elsif ($regel eq 'Webpagina') {
		# We have to turn the string given, which is normally
		# just a hostname, into a URL.  I don't see why they
		# don't just link to it directly, this is a web site
		# after all.
		#
		# Anyway, the URI library doesn't seem to have any way
		# to take a string and turn it into a URL adding
		# 'http:' if necessary, so we do this by hand.
		#
		if ($text !~ tr/://) {
		    $text = "http://$text";
		}
		push @url, $text;
	    }
	    elsif ($regel eq 'Rolverdeling') {
		warn "seen 'Rolverdeling' twice" if $actors;

		# Maybe 'e.a' is Latin for 'and others' or something.
		$text =~ s/\s*e\.a\s*$//;
	    
		while (length $text) {
		    if ($text =~ s/\s*([^:]+):\s*([^.]+)(?:$|\.)//) {
			warn "discarding information about the parts played by each actor\n"
			  unless $warned_discarding_parts++;
			push @$actors, $2;
		    }
		    elsif ($text =~ s/\s*([^,]+)(?:$|,)//) {
			push @$actors, $1;
		    }
		    else {
			warn "unknown remnamt 'Rolverdeling' text '$text'";
			last;
		    }
		}
	    }
	    elsif ($regel eq 'Scenario schrijver') {
		warn "seen 'Scenario schrijver' twice" if $writers;
		push @$writers, $text;
	    }
	    elsif ($regel eq 'E-mail') {
		push @url, "mailto:$text";
	    }
	    elsif ($regel eq 'Bron') {
		# FIXME cannot do anything special with this.  It
		# means 'source' and perhaps by parsing the text we
		# could find the names of writers or whatever.
		#
		push @desc, "$regel: $text";
	    }
	    elsif ($regel eq 'Commentaar') {
		push @$commentators, $text;
	    }
	    elsif ($regel eq 'Jaar van premiere') {
		# Year of release, I think.
		warn "seen 'Jaar van premiere' twice"
		  if defined $date;
		$date = $text;
	    }
	    elsif ($regel eq 'Regisseur') {
		warn "seen 'Regisseur' twice" if defined $director;
		$director = $text;
	    }
	    elsif ($regel eq 'Orginele titel') {
		warn "seen 'Orginele titel' twice" if defined $orig_title;
		$orig_title = $text;
	    }
	    elsif ($regel eq 'Behaalde prijzen') {
		# Awards won.  It doesn't seem worth adding a separate
		# field for this to the XMLTV format, just append to
		# the description.
		#
		push @desc, "$regel: $text";
	    }
	    else {
		# Unknown key, but let's add it to the desc so we
		# don't lose information.  These newlines are just for
		# the benefit of someone reading the XML by hand.
		#
		push @desc, "$regel: $text";
		warn "unknown programme info key $regel\n"
		  unless $warned_regel{$regel}++;
	    }
	}

	if (not defined $naam) {
	    warn "did not see programme title, skipping programme\n";
	    next;
	}
	if (not defined $van) {
	    warn "did not see programme times, skipping programme\n";
	    next;
	}
	die if not defined $tot;

	$van = DateCalc($van, '+ 1 day') if $next_day;
	$tot = DateCalc($tot, '+ 1 day') if $next_day;
	if (Date_Cmp($van, $tot) > 0) {
	    t "programme in $master_url seems to run from $van to $tot, must straddle midnight";
	    if ($next_day++) {
		warn "seeming to span more than one midnight, skipping rest of page";
		return;
	    }
	    $tot = DateCalc($tot, '+ 1 day');
	}

	# Sometimes it happens that the start time of this programme
	# is before the start time of the previously seen programme.
	#
	# Now this could mean that we have crossed midnight, if for
	# example the last programme was 2300--2330 and this one is
	# 0000--0030.  But that would require a gap in the listings,
	# and doesn't seem to happen in practice.  Instead, these
	# going-backwards seem to randomly occur in the middle of the
	# day giving overlapping programmes.
	#
	# Rather than warning about this, we just include it
	# faithfully in the XML output and let someone else worry
	# about the problem when reading the file.
	#

	my @title = ([ $naam, $LANG]);
	push @title, [ $orig_title ] if defined $orig_title; # not Dutch!
	my ($van_base, $van_tz) = @{date_to_eur($van, $TZ)};
	my ($tot_base, $tot_tz) = @{date_to_eur($tot, $TZ)};
	my %prog
	  = (channel  => $ch_xmltv_id,
	     title    => \@title,
	     start    => UnixDate($van_base, '%q') . " $van_tz",
	     stop     => UnixDate($tot_base, '%q') . " $tot_tz",
	    );
	
	# We have lots of bits of description.  But we make them
	# into a single <desc> element because they probably give
	# different information, rather than stating the same
	# information in different ways.
	#
	$prog{desc} = [ [ join("\n\n", @desc), $LANG ] ] if @desc;
	
	$prog{'sub-title'} = [ [ $sub_title, $LANG ] ] if defined $sub_title;
	$prog{subtitles} = [ { type => 'teletext' } ] if $teletext_sub;
	$prog{credits} = { presenter => \@presenter } if @presenter;
	$prog{'episode-num'} = [ $episode_num ] if defined $episode_num;
	$prog{url} = \@url if @url;
	$prog{date} = $date if defined $date;
	$prog{category} = [ [ $genre, $LANG ] ] if defined $genre;
	$prog{'previously-shown'} = $previously_shown if $previously_shown;
	
	my %c;
	$c{actor} = $actors if $actors;
	$c{writer} = $writers if $writers;
	$c{commentator} = $commentators if $commentators;
	$c{director} = [ $director ] if $director;
	$prog{credits} = \%c if %c;
	
	$writer->write_programme(\%prog);
	update $bar if $bar;
    }
}

sub time_tot_str( $ ) {
    my $input = shift; 
    if (length($input) == 15) {
	$input .= '05:00'; 
    }
    my $datum = substr($input,0,length($input)-11); 
    my $tot   = substr($input,-5); 

    $datum =~ /(\d\d?)-(\d\d?)-(\d+)/
      or die "cannot find year in '$datum'";
    my ($dd, $mm, $yyyy) = ($1, $2, $3);
    foreach ($dd, $mm) { $_ = "0$_" if length == 1 }
    $tot =~ /(\d\d):(\d\d)/
      or die "cannot find time in '$tot'";
    my ($HH, $MM) = ($1, $2);

    my $str = "$yyyy-$mm-$dd $HH:$MM:00";
    my $p = parse_eur_date($str, $TZ);
    die "could not parse date $str" if not defined $p or not length $p;
    return $p;
}
sub time_van_str( $ ) {
    my $input = shift; 
    if (length($input) == 15) {
	$input .= '06:00';
    }
    my $datum = substr($input,0,length($input)-11);
    my $van = substr($input,-11);
    $van = substr($van,0,5);

    $datum =~ /(\d\d?)-(\d\d?)-(\d{4})/
      or die "cannot find year in '$datum'";
    my ($dd, $mm, $yyyy) = ($1, $2, $3);
    foreach ($dd, $mm) { $_ = "0$_" if length == 1 }
    $van =~ /(\d\d):(\d\d)/
      or die "cannot find time in '$van'";
    my ($HH, $MM) = ($1, $2);
    my $str = "$yyyy-$mm-$dd $HH:$MM:00";
    my $p = parse_eur_date($str, $TZ);
    die "could not parse date $str" if not defined $p or not length $p;
    return $p;
}


# get channel listing
sub get_channels() {
    my %channels;
    my $url = 'http://www.tvgids.nl';

    #All stations are in the select box.
    #The station ID is the option value
    my $t = new HTML::TreeBuilder();
    $t->parse(get_nice($url));
    my @conts = map { [ $_->content_list() ] }
      $t->look_down('_tag' => 'select', 'name' => 'station');
    foreach my $cont (@conts) {
	my @children =@$cont;
	if (scalar(@children) == 0) {
	    warn 'No stations are defined'; 
	    next; 
	}
	foreach my $station_line (@children) {
	    if ($station_line ne ' ') {     
		#This if statement is to prevent parsing the last 
		#empty element from the list.
			
		my $channel_id = $station_line->attr('value'); 
		
		#I am only interested in the normal channels.
		#tvgids.nl has some pages for the regional stations also
		#All normal channels have id <0,100>
		#That is at the moment... Could change in future...
		if ($channel_id > 0 && $channel_id < 100) {
		    my $channel_name = $station_line->as_text(); 
		    $channels{$channel_id} = $channel_name
		}
	    }

	}
    }	
    $t->delete(); undef $t;
    return %channels;
}


# Process a page containing the summary information.
#
# Parameters:
#   URL to fetch
#   Date::Manip object giving day for programmes in page (at least
#     until they cross midnight)
#   Date::Manip object giving official 'date' of page (normally the
#     same as the previous parameter)
#   XMLTV id of channel
#
# Returns a list of tuples of the form [ start, stop, title, url ]
# where start and stop are Date::Manip objects, title is a string, and 
# url is the page to download if you want full details.
#
sub process_summary_page( $$$ ) {
    my ($url, $day, $official_day) = @_;
    die if not defined $url;
    die if not defined $day;
    die if not defined $official_day;
    local $SIG{__WARN__} = sub {
	warn "$url: $_[0]";
    };
    local $SIG{__DIE__} = sub {
	die "$url: $_[0]";
    };
    my $t = new HTML::TreeBuilder;
    $t->parse(get_nice($url));
    my %interesting; ++ $interesting{$_} foreach
      qw(lijst_zender lijst_tijd details_programma);
    my @elems = $t->look_down(sub { die if not defined $_[0];
				    my $c = $_[0]->attr('class');
				    return 0 if not defined $c;
				    return $interesting{$c} });
    if (not @elems) {
	warn 'did not find any programmes in page';
	next;
    }
    my @bits;
    foreach my $e (@elems) {
	my $class = $e->attr('class');
	t "looking at elem of class $class";
	my $href;
      check_content:
	my @cont = $e->content_list();
	my $got_href = $e->attr('href');
	if (defined $got_href) {
	    t "got href: $got_href";
	    warn "seen 'href's contained inside each other"
	      if defined $href;
	    $href = $got_href;
	}
	if (not @cont) {
	    warn "found $class elem without content, ignoring"
	      unless $class eq 'lijst_zender';
	    next;
	}
	elsif (@cont == 1) {
	    for ($cont[0]) {
		if (ref) {
		    # Unpack this extra layer of element.
		    $e = $_;
		    goto check_content;
		}
		s/^\s+//; s/\s+$//;
		push @bits, [ $class, $href, $_ ];
	    }
	}
	elsif (@cont > 1) {
	    warn "found $class elem with more than one elem inside, ignoring"
	      unless $class eq 'lijst_zender';
	    next;
	}
    }
    $t->delete(); undef $t;
    if (not @bits) {
	warn "did not see any content, skipping page";
	next;
    }
    if ($bits[0]->[0] eq 'lijst_zender') {
	my $date_str = $bits[0]->[2];
	my $d = parse_dutch_date($date_str);
	if (defined $d) {
	    my ($d_base, $d_tz) = @{date_to_eur($d, $TZ)};
	    die "date in page $d_base ($date_str) doesn't match expected $official_day"
	      if UnixDate($d_base, '%Q') ne UnixDate($official_day, '%Q');
	    shift @bits;
	}
	# otherwise, leave it for later processing
    }
    #	use Log::TraceMessages qw(t d);
    #	$Log::TraceMessages::On = 1;
    #	t 'bits: ' . d \@bits;
    my @r;
    while (@bits >= 3) {
	my $ch_bit = shift @bits;
	my $ch_class = $ch_bit->[0];
	if ($ch_class ne 'lijst_zender') {
	    warn "bit expected to be channel name has class $ch_class not lijst_zender, skipping";
	    next;
	}
	my $ch = $ch_bit->[2];
	
	my $times_bit = shift @bits;
	my $times_class = $times_bit->[0];
	if ($times_class ne 'lijst_tijd') {
	    warn "bit expected to be times has class $times_class not lijst_tijd, skipping";
	    next;
	}
	my $times = $times_bit->[2];
	
	my $title_bit = shift @bits;
	my $title_class = $title_bit->[0];
	if ($title_class ne 'details_programma') {
	    warn "bit expected to be title has class $title_class not details_programma, skipping";
	    next;
	}
	my $title_href = $title_bit->[1];
	my $title = $title_bit->[2];
	
	# Right, got channel name, times, and title.
	# FIXME should check channel name (among other things).
	unless ($times =~ /^(\d\d):(\d\d)-(\d\d):(\d\d)$/
		and 0 <= $1 and $1 < 24 and 0 <= $2 and $2 < 60
		and 0 <= $3 and $3 < 24 and 0 <= $4 and $4 < 60) {
	    warn "bad programme times $times, skipping ($ch, $times, $title)";
	    next;
	}
	my ($start_hh, $start_mm, $stop_hh, $stop_mm) = ($1, $2, $3, $4);
	die if not defined $day;
	my $start = parse_eur_date("$day $start_hh:$start_mm", $TZ);
	die if not defined $start;
	my $stop = parse_eur_date("$day $stop_hh:$stop_mm", $TZ);
	die if not defined $stop;
	if (Date_Cmp($start, $stop) > 0) {
	    $day = UnixDate(DateCalc($day, '+ 1 day'), '%Y-%m-%d');
	    $stop = parse_eur_date("$day $stop_hh:$stop_mm", $TZ);
	    die if not defined $stop;
	    die unless Date_Cmp($start, $stop) < 0;
	}
	
	my $title_url = URI->new_abs($title_href, $url);
	push @r, [ $start, $stop, $title, $title_url ];
    }
    foreach (@bits) {
	my ($type, $href, $text) = @$_;
	if ($type eq 'lijst_zender' and $text eq 'Volgende') {
	    # Next page for this day.
	    my $next_url = URI->new_abs($href, $url);
	    push @r, process_summary_page($next_url, $day, $official_day)
	}
	elsif ($type eq 'lijst_zender' and $text eq 'Vorige') {
	    # Previous page for this day, assume already fetched.
	}
	else {
	    warn "discarding leftover $type: $text";
	}
    }
    return @r;
}

# Parse date strings that are in Dutch.  'Why not just call
# Date_Init("Language=Dutch")?' I hear you ask.  The trouble is that
# Date::Manip's language is a global setting and having set it to
# Dutch we cannot use code that expects English - either in this file
# or in any libraries.  The least insane way to proceed is to turn
# Dutch to English strings here.
#
# The conversions to make, however, are swiped from the Date::Manip
# code.
#
sub parse_dutch_date( $ ) {
    for (my $tmp = $_[0]) {
	s/\bjanuari\b/January/g;
	s/\bjan\b/January/g;
	s/\bfebruari\b/February/g;
	s/\bfeb\b/February/g;
	s/\bmaart\b/March/g;
	s/\bmaa\b/March/g;
	s/\bmrt\b/March/g;
	s/\bapril\b/April/g;
	s/\bapr\b/April/g;
	s/\bmei\b/May/g;
	s/\bmei\b/May/g;
	s/\bjuni\b/June/g;
	s/\bjun\b/June/g;
	s/\bjuli\b/July/g;
	s/\bjul\b/July/g;
	s/\baugustus\b/August/g;
	s/\baug\b/August/g;
	s/\bseptember\b/September/g;
	s/\bsep\b/September/g;
	s/\boctober\b/October/g;
	s/\boktober\b/October/g;
	s/\boct\b/October/g;
	s/\bokt\b/October/g;
	s/\bnovember\b/November/g;
	s/\bnov\b/November/g;
	s/\bdecember\b/December/g;
	s/\bdec\b/December/g;

	s/\bzondag\b/Sunday/g;
	s/\bmaandag\b/Monday/g;
	s/\bdinsdag\b/Tuesday/g;
	s/\bwoensdag\b/Wednesday/g;
	s/\bdonderdag\b/Thursday/g;
	s/\bvrijdag\b/Friday/g;
	s/\bzaterdag\b/Saturday/g;

	my $r = parse_eur_date($_, $TZ);
	die "could not parse date $_ (from Dutch $_[0])"
	  if not defined $r;
	return $r;
    }
}
