#!/usr/bin/perl -w
#
# $Id: tv_grab_uk.in,v 1.3 2002/02/28 18:03:33 epaepa Exp $
#
# Fetch UK television listings from the data provided by ananova.com.
#
# See release notes and/or cvs logs entries for module history
#
# -- Ed Avis, epa98@doc.ic.ac.uk
#

use strict;
use LWP::Simple;
use Getopt::Long;
use Tie::IxHash;
use Log::TraceMessages qw(t d); Log::TraceMessages::check_argv();
use Date::Manip;
use Tie::RefHash;
use Term::ProgressBar;
use IO::File;

use XMLTV;
use XMLTV::UK_TZ;
use XMLTV::Ananova_Channel;
use XMLTV::Memoize;
use XMLTV::Ask;

# Prototype declarations
sub get_copyright( $ );
sub get_regions( $$ );
sub get_dir( $$ );
sub read_channels_page( $ );
sub usage();
sub read_file( $$$$$ );
sub date_programmes( $$ );
sub add_clumpidx( $ );
sub get_channel_pkgs();
sub init_channels();
sub write_channels( $$$$$ );
sub wanted_by_region( $ );
sub get_pages( $$ );
sub configure();
sub grab( @ );

# Check options.  First do the undocumented --cache option (to cache
# get(), which retrieves web pages), then the normal ones.
#
my $using_cache = XMLTV::Memoize::check_argv('get');
my ($opt_days, $opt_help, $opt_output, $opt_share, $opt_configure);
GetOptions('days=i' => \$opt_days, 'help' => \$opt_help,
	   'configure' => \$opt_configure,
	   'output=s' => \$opt_output, 'share=s' => \$opt_share);
die 'number of days must not be negative'
  if (defined $opt_days && $opt_days < 0);
if ($opt_help) {
    print <<END
$0: get UK television listings in XMLTV format

FIXME
END
  ;
    exit(1);
}
if ($opt_configure) {
    print STDERR "Going to configure channels to download, please wait\n";
}

# share/ directory for storing channel mapping files.  This next line
# is altered by processing through tv_grab_uk.PL.  But we can use the
# current directory instead of share/tv_grab_uk for development.
#
# The 'source' file tv_grab_uk.in has $SHARE_DIR undef, which means
# use the current directory.  In any case the directory can be
# overridden with the --share option (useful for testing).
#
my $SHARE_DIR = undef;
$SHARE_DIR = $opt_share if defined $opt_share;
my $OUR_SHARE_DIR = (defined $SHARE_DIR) ? "$SHARE_DIR/tv_grab_uk" : '.';

# PHP page provided by Ananova to access their internal listings data.
# This is used as an inital substring of all the URLs gotten by this
# program.
#
my $A = 'http://www.ananova.com/tv_listings/_tv_raw.php';

# File that stores which channels to download.
my $CONFIG_FILE;
if (defined($ENV{HOME})) {
    $CONFIG_FILE = "$ENV{HOME}/.xmltv/tv_grab_uk";
}
else {
    # $HOME not set, use current directory.
    $CONFIG_FILE = 'tv_grab_uk';
}

# On Windows Date::Manip can have trouble finding the local timezone.
# Since the output listings shouldn't depend on the local timezone
# anyway, we just set it here.
#
Date_Init('TZ=UT');

# Things will go horribly wrong if Ananova change pages from one day
# to the next while the script is running.  Assume they do it at
# midnight.
#
my $today = ParseDate('today'); die if not defined $today;
END {
    if (UnixDate(ParseDate('today'), '%Q') ne UnixDate($today, '%Q')) {
	warn "current day has changed, results may be messed up\n";
    }
}

# Convert an internal (Date::Manip) date to output format.
sub ud { join(' ', @{date_to_uk($_[0])}) }

# What language the pages are in.  This has no real effect :-)
my $LANG = 'en';

# The date libraries, however, do benefit from memoization.  It's only
# about an 8% speed increase for the program as a whole, but worth it.
#
use Memoize;
eval { require Memoize };
if ($@) {
    warn "could not load Memoize module, things will run slowly\n";
}
else {
     foreach (qw(parse_uk_date ParseDate UnixDate DateCalc Date_Cmp
		 ParseDateDelta ud)) {
	 Memoize::memoize($_) or warn "cannot memoize $_";
     }
}

# Download the three index pages now.
my $index_pages = get_pages('getting list of channels', [ qw(regions channels dir) ]);

# Set up the global channels and regions data.  This is needed for
# both configuration and grabbing.
#
my $regions = get_regions($index_pages->{regions}->{content},
			  $index_pages->{regions}->{url});
my %region_display = reverse %$regions;
my %type_display;
$type_display{$_} = $_ foreach qw(radio satellite);
init_channels();
read_channels_page($index_pages->{channels}->{content});

# Predefined channel packages for ease of configuration.
my %channel_pkgs = get_channel_pkgs();

if ($opt_configure) {
    configure();
} else {
    my %g_args = ();
    if (defined $opt_output) {
	my $fh = new IO::File ">$opt_output";
	die "cannot write to $opt_output\n" if not $fh;
	%g_args = (OUTPUT => $fh);
    }
    grab(%g_args);
}


# Ask the user which channels to download, and write $CONFIG_FILE.
sub configure() {
    warn "FIXME overwriting existing $CONFIG_FILE\n";

    # Need to ask:
    #
    # - Do you get terrestrial TV and if so what region?
    # - Do you have satellite?
    # - Do you have radio?  (incl. with Sky Digital)
    # - If satellite, prompt for channel packages.
    #
    my $terr = askBooleanQuestion
      ('Do you get terrestrial analogue television?', 1);
    if ($terr) {
	my $region_dn = askQuestion
	  ('Which terrestrial region?', sort keys %$regions);
	my $aid;
	foreach (keys %$regions) {
	    if ($_ eq $region_dn) {
		$aid = $regions->{$_};
	    }
	}
	die if not defined $aid;
	print "chose region $region_dn, $aid\n";
    }
    exit();
}

# Grab listings and write them in XML.  Arguments are to be passed to
# XMLTV::Writer.
#
sub grab( @ ) {
    my %args = @_;
    my $copyright = get_copyright($index_pages->{regions}->{content});

    # Set up an XMLTV::Writer; print copyright and start of
    # document.  Ananova's data is in Latin-1.
    #
    my $writer = new XMLTV::Writer(encoding => 'ISO-8859-1', %args);
    $writer->comment($copyright);
    $writer->start({ 'source-info-url'     =>
		     'http://www.ananova.com/tv_listings/_tv_full_listings.html',
		     'source-info-name'    => 'Ananova',
		     'source-data-url'     => $A,
		     'generator-info-name' => 'XMLTV/0.5', # FIXME
		     'generator-info-url'  =>
		     'http://www.doc.ic.ac.uk/~epa98/work/apps/xmltv/',
	       });

    # We've set the type of 'radio' and 'satellite' channels.  Now deal
    # with the terrestrial channels, which have a region set.  We should
    # find that every channel fits into radio, xor satellite, xor one
    # particular region.
    #
    # We end up with a list of [ day, type, channel, filename ], where
    # type is one of 'radio', 'satellite', or a region code.
    #
    my @files;

    my %seen_ch;
    foreach (get_dir($index_pages->{dir}->{content},
		     $index_pages->{dir}->{url})) {
	#    local $Log::TraceMessages::On = 1;
	my ($orig, $day, $ananova_id, $region) = @$_;
	t 'got line from dir: orig=' . d($orig) . ', day=' . d($day) . ', ananova_id=' . d($ananova_id) . ', region=' . d($region);
	my $ch = XMLTV::Ananova_Channel->find_by_ananova_id($ananova_id);
	t 'found channel by Ananova id: ' . d $ch;
	if (not defined $ch) {
	    t 'creating a new channel and adding id';
	    $ch = new XMLTV::Ananova_Channel();
	    $ch->add_ananova_id($ananova_id);
	}
	$seen_ch{$ch}++;	# no dup check, since multiple days

	# If channel not seen before, assume terrestrial.
	my $type = $ch->get_type();
	$type = 'terrestrial' if not defined $type;
	my $has_region = (defined $region);

	if ($type eq 'terrestrial') {
	    if ($has_region) {
		$ch->add_region($region);
		push @files, [ $day, $region, $ananova_id, $orig ];
	    } else {
		# Probably an old file which is still lying around in dir.
		# We don't bother with these.
		#
		$type = 'duff';
	    }
	} elsif ($type eq 'satellite' or $type eq 'radio') {
	    if ($has_region) {
		warn 'channel ' . $ch->stringify() . " was seen as $type but also region $region";
	    } else {
		push @files, [ $day, $type, $ananova_id, $orig ];
	    }
	} elsif ($type eq 'duff') {
	    # Ignore.
	} else {
	    die "bad type $type";
	}
	$ch->set_type($type);
    }
    t 'files: ' . d \@files;

    # Check that there are no redundant entries in the channel data.
    foreach (XMLTV::Ananova_Channel->all()) {
	unless ($seen_ch{$_}) {
	    warn "channels data mentions channel $_, but not used\n";
	    $_->set_type('duff');
	}
    }

    # Now work out which of @files we actually want to download.  We can
    # pick channels in three ways: by type ('radio', 'satellite'), by
    # Ananova region ('15', '2' with display names like 'Carlton', 'Tyne
    # Tees') and individually by XMLTV id.
    #
    my (%wanted_type, %wanted_region, %wanted_xmltv_id);
    my $want_all;
    if (defined $ARGV[0] and $ARGV[0] eq 'ALL') {
	$want_all = 1;
    } else {
	#    local $Log::TraceMessages::On = 1;
	foreach my $arg (@ARGV) {
	    t "working out arg $arg";
	    my $larg = lc $arg;
	    t "lowercase version is $larg";
	    my $t;

	    # See whether the argument matches a type.  We look for an
	    # exact match and if not that then a regexp match.
	    #
	    foreach (sort keys %type_display) {
		my $ldn = lc $type_display{$_};
		if ($ldn eq $larg) {
		    $t = $_;
		    last;
		} elsif (not defined $t and index($ldn, $larg) != -1) {
		    $t = $_;
		}
	    }
	    if (defined $t) {
		print STDERR "getting channel type $type_display{$t}\n";
		$wanted_type{$t}++
		  && warn "channel type $type_display{$t} mentioned twice\n";
		next;
	    }

	    # Or a terrestrial region.
	    foreach (sort keys %region_display) {
		my $ldn = lc $region_display{$_};
		if ($ldn eq $larg) {
		    $t = $_;
		    last;
		} elsif (not defined $t and index($ldn, $larg) != -1) {
		    $t = $_;
		}
	    }
	    if (defined $t) {
		print STDERR "getting terrestrial region $region_display{$t}\n";
		$wanted_region{$t}++
		  && warn "terrestrial region $region_display{$t} mentioned twice\n";
		next;
	    }
	
	    # Nothing so far, but maybe it matches a channel package.
	    foreach (sort keys %channel_pkgs) {
		# Exact match only since they're computery names.
		if ($_ eq $arg) {
		    $t = $_;
		    last;
		}
	    }
	    if (defined $t) {
		print STDERR "getting channel package $t\n";
		foreach (@{$channel_pkgs{$t}}) {
		    t "setting wanted XMLTV id $_";
		    ++ $wanted_xmltv_id{$_};
		}
		next;
	    }

	    # Finally, perhaps it matches the name of a channel.
	    my $found_dn;
	    t 'seeing whether argument matches channel name';
	    foreach (XMLTV::Ananova_Channel->all()) {
		next if $_->get_type() eq 'duff';
		my $dn = $_->get_a_display_name();
		next if not defined $dn;
		t "checking non-duff channel with dn $dn: " .  d $_;
		my $ldn = lc $dn;
		t "comparing lowercase dn $ldn with lowercase arg $larg";

		if ($ldn eq $larg) {
		    t "lowercase displayname $ldn equals argument";
		    my $xmltv_id = $_->get_xmltv_id();
		    if (not defined $xmltv_id) {
			warn "sorry, cannot select channel $dn, need to add XMLTV id in code\n";
		    } else {
			$t = $xmltv_id;
			$found_dn = $dn;
			last;
		    }
		} elsif (not defined $t and index($ldn, $larg) != -1) {
		    t "best match so far is $larg as substring of $ldn";
		    my $xmltv_id = $_->get_xmltv_id();
		    if (not defined $xmltv_id) {
			warn "sorry, cannot select channel $dn, need to add XMLTV id in code\n";
		    } else {
			$t = $xmltv_id;
			$found_dn = $dn;
		    }
		} else {
		    t "no match, continue";
		}
	    }
	    if (defined $t) {
		print STDERR "getting channel $found_dn\n";
		$wanted_xmltv_id{$t}++
		  && warn "channel with XMLTV id $t already chosen";
		next;
	    }
	
	    if (not defined $t) {
		warn "'$arg' does not match any known channel type, package or channel\n";
		usage();
	    }
	}
	if (not keys %wanted_type
	    and not keys %wanted_region
	    and not keys %wanted_xmltv_id) {
	    if (not @ARGV) {
		# Fall back on default region 'carlton'.
		my $chosen;
		foreach (sort keys %region_display) {
		    if ($region_display{$_} =~ /\Qcarlton\E/i) {
			print STDERR "getting terrestrial region $region_display{$_}\n";
			$wanted_region{$_}++;
			$chosen = $_;
			last;
		    }
		}
		if (defined $chosen) {
		    warn "no channel types, packages or channels given, assuming $region_display{$chosen}\n";
		    usage();
		} else {
		    warn "no channel types, packages or channels given and default 'carlton' not found, "
		      . "giving up\n";
		    usage();
		    exit(1);
		}
	    } else {
		warn "nothing to download\n";
		# But we'll let it print an empty file anyway...
	    }
	}
    }

    # There used to be a warning that if you chose 'satellite' you'd need
    # to also pick a terrestrial region to get channels like BBC1.  This
    # is no longer the case since Ananova now has listings for BBC1
    # Digital and so on.  Besides, with the new channel packages
    # 'satellite' will probably not be used much.
    #

    # Filter out the files we want to download - those with the correct
    # channel type, region or channel id.
    #
    my @new_files;
    t 'deciding which files to download';
    my %used_xmltv_id;
    foreach (@files) {
	#    local $Log::TraceMessages::On = 1;
	t 'looking at file: ' . d $_;
	if (defined $opt_days and $opt_days < $_->[0]) {
	    t 'outside the --days range';
	    next;
	}

	if ($want_all) {
	    t 'want all files, so want this one';
	    push @new_files, $_;
	    next;
	}

	my $tor = $_->[1];
	t "type or region: $tor";
	if ($wanted_type{$tor} or $wanted_region{$tor}) {
	    t 'want this type or region';
	    push @new_files, $_;
	    next;
	}

	my $ch = XMLTV::Ananova_Channel->find_by_ananova_id($_->[2]);
	t 'looked up by Ananova id: ' . d $ch;
	if (defined $ch) {
	    my $xmltv_id = $ch->get_xmltv_id();
	    t 'channel has XMLTV id: ' . d $xmltv_id;
	    if (defined $xmltv_id) {
		if ($wanted_xmltv_id{$xmltv_id}) {
		    t 'this id is wanted';

		    # But the same id may be available as two different
		    # files.  We want only the first Ananova set of pages
		    # for this channel.
		    #
		    if ($ch->get_first_ananova_id() eq $_->[2]) {
			t 'is first Ananova id, adding';
			push @new_files, $_;
			$used_xmltv_id{$xmltv_id}++;
			next;
		    } else {
			t 'a secondary Ananova page for this channel, not adding';
		    }
		}
	    }
	}
    }
    @files = @new_files;
    t 'checking that every wanted XMLTV id was found';
    foreach (sort keys %wanted_xmltv_id) {
	next if $used_xmltv_id{$_};
	my $ch = XMLTV::Ananova_Channel->find_by_xmltv_id($_);
	die if not defined $ch;
	warn 'channel ' . $ch->stringify() . ' not found on site';
    }

    # We want to get them in day order, so that we can get the first day's
    # listings first.  This is becuase we need to get a complete day to
    # get the complete channel information, which must be written out
    # before any programmes.
    #
    # We download all the files at once, then process them one by one.
    #
    my $got = get_pages('downloading listings', [ map { $_->[3] } @files ]);
    my $bar = new Term::ProgressBar('parsing', scalar @files);
    my $first_day;
    my $wrote_channels = 0;
    my @progs_todo;
    foreach (sort { $a->[0] <=> $b->[0] } @files) {
	my ($day, $type, $ananova_id, $filename) = @$_;
	t "getting file for day $day, type $type, Ananova id $ananova_id, filename $filename";
	die if defined $opt_days and $day > $opt_days;
	$first_day = $day if not defined $first_day;

	# Work out the actual day this number corresponds to: 1 is
	# today.
	#
	my $day_offset = $day-1;
	t 'day offset: ' . d $day_offset;
	my $day_date = DateCalc($today, "+ $day_offset days");
	die if not defined $day_date;

	# Get a list of programmes from this filename, fix the dates and
	# add clumpidxes.
	#
	my $ch = XMLTV::Ananova_Channel->find_by_ananova_id($ananova_id);
	die if not defined $ch;
	my $g = $got->{$filename};
	my $progs = read_file($day_date, $ch, $g->{content}, $filename, $g->{url});
	date_programmes($progs, $day_date);
	add_clumpidx($progs);

	# Check to see if we have to write channels data first.
	if (not $wrote_channels) {
	    if ($day != $first_day) {
		# Must have done a whole day's listings, channels are ready to
		# write.
		#
		write_channels($writer, $want_all, \%wanted_type, \%wanted_xmltv_id, \%wanted_region);
		$wrote_channels = 1;
	    }
	}

	push @progs_todo, @$progs;
	if ($wrote_channels) {
	    t 'channels have been written before, write programmes';
	    $writer->write_programme($_) foreach @progs_todo;
	    @progs_todo = ();
	}

	update $bar;
    }

    # In case we never got to the second day, make sure the pending stuff
    # is written.
    #
    if (not $wrote_channels) {
	write_channels($writer, $want_all, \%wanted_type, \%wanted_xmltv_id, \%wanted_region);
	$writer->write_programme($_) foreach @progs_todo;
	$wrote_channels = 1; @progs_todo = ();
    }

    # Finish.
    $writer->end();
}


# Extract the copyright message from the comment at the start of every
# page served.  Takes page content, returns the copyright message.
#
sub get_copyright( $ ) {
    my $r;
    foreach (split /\n/, $_[0]) {
	s/^\s*\#// or die "unexpected non-comment line in page";
	s/^\s+//;
	last if not length;
	$r .= "$_\n";
    }
    return $r;
}


# Return a reference to an ordered hash mapping region display name to
# Ananova internal region name.
#
# Parameters:
#   contents of Ananova 'regions' page
#   URL of that page (for error reporting)
#
sub get_regions( $$ ) {
    my ($data, $url) = @_;
    my %r; tie %r, 'Tie::IxHash';
    foreach (split /\n/, $data) {
	t "doing line: $_";
	s/^\s+//; s/\s+$//;
	s/\#.*//;
	next if $_ eq '';
	if (/^region\.((?:[a-z]+_)?\d+)=(.+)$/) {
	    $r{$2} = $1;
	}
	else {
	    warn "bad line from $url: $_";
	}
    }
    if (not keys %r) {
	warn "couldn't get any region data from $url";
    }
    return \%r;
}


# Get the list of Ananova 'filenames' and parse each filename into a
# tuple of:
#
# [ original filename, day number, channel id, region ]
#
# Region may be undef, and channel id will also contain the region
# details (so that bbc1_2 and bbc1ea_0 are distinct channels).
#
# Returns a list of these tuples (er, listrefs).
#
# Parameters:
#   contents of Ananova 'dir' page
#   URL of 'dir' page
#
sub get_dir( $$ ) {
    my ($data, $url) = @_;
    local $Log::TraceMessages::On = 0;

    my @r;
    my %warned_unknown_region;
    foreach (split /\n/, $data) {
	t "doing line: $_";
	s/^\s+//; s/\s+$//;
	s/\#.*//;
	next if $_ eq '';
	
	my $orig = $_;

	s/^day(\d+)_// or die "bad Ananova filename $_ (no 'dayX_')";
	my $day = $1;
	my $channel = $_;

	my $region;
	foreach my $r (values %$regions) {
	    if ($r =~ /\D/ && s/$r$//) {
		# Ends with the region code itself.  This isn't
		# applicable if the region code is just a number.
		#
		$region = $r;
		last;
	    }
	    
	    $r =~ /(\d+)$/ or die "bad region code $r";
#	    t "just the number of region: $1";
	    if (/_$1$/) {
		# Ends with _ and just the number of the region.
		$region = $r;
		last;
	    }
	}

	if (not defined $region) {
	    if (/^(?:[a-z]+_)?[a-z0-9]+$/) {
		# No region at all, okay.
	    }
	    else {
		unless ($warned_unknown_region{$_}++) {
		    warn "can't find region for channel id $_\n";
		}
	    }
	}

	push @r, [ $orig, $day, $channel, $region ];
    }
    return @r;
}


# Read Ananova's Channels page.  This tells us about radio and
# satellite channels.
#
# Parameter: content of channels page
#
sub read_channels_page( $ ) {
    my $data = shift;
    local $Log::TraceMessages::On = 0;

    my (%type, %display);
    my %seen_display;
    foreach (split /\n/, $data) {
	t "doing line: $_";
	s/^\s+//; s/\s+$//;
	s/\#.*//;
	next if $_ eq '';
	
	if (/^(radio|satellite)\.([a-z0-9_]+)=(.+)$/) {
	    t 'matched';
	    my ($type, $ananova_id, $display) = ($1, $2, $3);
	    t "type=$type, ch=$ananova_id, display=$display";

	    my $ch = XMLTV::Ananova_Channel->find_by_ananova_id($ananova_id);
	    $ch = new XMLTV::Ananova_Channel() if not defined $ch;
	    $ch->set_type($type);
	    $ch->add_ananova_id($ananova_id);

	    # Only set the display name based on the first (ie,
	    # best) Ananova id for this channel.  Otherwise we'd
	    # have a conflict between say 'Border' and 'Border
	    # (Scottish viewers)'.  Only the first of the two should
	    # have a chance to set the display name.
	    #
	    if ($ch->get_first_ananova_id() eq $ananova_id) {
		$ch->set_main_display_name($display, 0);
	    }

	    if ($seen_display{lc $display}++) {
		# Kludge around fact that we _know_ Nickelodeon
		# is wrong: I've reported it but they haven't fixed it
		# yet.
		#
		unless ($display eq 'Nickelodeon') {
		    warn "channel display name $display seen twice";
		}
	    }
	}
	else {
	    warn "bad line in channels listing: $_\n";
	}
    }
}


# Usage message
my $shown_usage = 0;
sub usage() {
    return if $shown_usage++;
    my $msg = <<END
usage: $0 [--output FILE] [--days N] channel-spec...

There are three ways to choose which channels to download.  Pick a
terrestrial region or channel type from:

END
;
    $msg .= join(', ', sort values %region_display) . "\n";
    $msg .= join(', ', sort values %type_display) . "\n";
    $msg .= <<END

'radio' means all radio stations and 'satellite' all satellite
channels.  But if you have satellite, you probably want to pick one
or more of the following channel packages:

END
;
    foreach (sort keys %channel_pkgs) {
	my @names;
	foreach (@{$channel_pkgs{$_}}) {
	    my $ch = XMLTV::Ananova_Channel->find_by_xmltv_id($_);
	    if (defined $ch) {
		push @names, $ch->get_a_display_name();
	    }
	    else {
		warn "channel id $_ mentioned in package, but not known\n";
		push @names, $_;
	    }
	}
        $msg .= "$_: " . join(', ', @names) . "\n\n";
    }

    $msg .= <<END
Or you can specify the names of individual channels directly.

You can abbreviate names by giving a case-insensitive substring, for
example 'Tyne Tees' could be abbreviated to 'tyne'.  The special value
'ALL' means get every available channel, but this gives a very big
output file!
END
  ;
    warn $msg;
}


# Read data for a particular day.
#
# Parameters:
#   date expected in file (in Date::Manip format)
#   XMLTV::Ananova_Channel object, used to check and set display name
#   content of page from Ananova
# Plus two used for error reporting and checking:
#   Ananova 'filename'
#   Ananova URL
#
# Returns: reference to list of programme details, or undef if error.
# These won't have proper start and stop times; instead they have a
# 'time' key and you should use date_programmes() or similar to fix up
# the list of programmes afterwards.  Also the channel is not
# included, you should add that to each programme (probably in RFC2838
# style) afterwards.
#
my (%warned_shorter, $warned_wrong_date); # cut down on duplicate warnings
sub read_file( $$$$$ ) {
    my ($date_expected, $ch, $data, $file, $url) = @_;
    my @lines = split /\n/, $data;
    foreach (@lines) { s/^\s+//; s/\s+$//; s/\#.*// }
    @lines = grep { length } @lines;

    if (not @lines) {
	# No non-comment lines.  This could be because the PHP script
	# is returning 'file not found'.  That happens if you request
	# the directory listing, it contains obsolete files which
	# (wrongly) are still around, and then your request for the
	# file itself is handled by a different box where the file is
	# in fact deleted.
	#
	if ($data =~ /\n\# \Q$file\E does not exist$/) {
	    warn "file $file does not exist on server, probably should be removed from dir\n";
	    return undef;
	}
	else {
	    warn "cannot get data from $url, returns:\n$data";
	    return undef;
	}
    }

    # Check the date.
    if (not check_page_date((shift @lines), $date_expected)) {
	warn "bad date in $url, skipping";
	return undef;
    }

    # Set the definitive channel name, if not already set.  The
    # channel name can change if the same channel is listed in two
    # places, for example 'Sky Sports 2' and 'Sky Sports 2 (ITV
    # Digital)'.  We could end up grabbing both pages and mapping them
    # to the same channel.  The first name found wins.
    #
    # In practice I expect that soon we'll make sure to grab only one
    # of the two pages: getting both is really just for debugging.
    #

    # Check the channel name is as expected (if we know what the
    # display name should be for this channel).
    #
    my $got_ch_display = shift @lines;
    if (not $ch->has_definitive_display_name()) {
	$ch->set_main_display_name($got_ch_display, 1);
    }

    my $copyright = pop @lines;
    if ($copyright !~ /^\(c\) Copyright/) {
	warn "strange copyright message: $copyright\n";
    }

    if (@lines and $lines[0] =~
	/^There are no listings available for this channel today\|\|/) {
	return [];
    }

    # Right, got that cruft out of the way, each remaining line is a
    # |-separated list of programme details.
    #
    my @r;
    my $prev_time;
    foreach (@lines) {
	my @fields = split /\|/, $_, -1; # toothpicks ahoy!
	my $num_fields = scalar @fields;
	if ($num_fields == 1 and $fields[0] =~ /copyright/i) {
	    next;
	}
	if ($num_fields < 17 or $num_fields >= 22) {
	    warn "wrong number of fields ($num_fields, need 17..21) "
	      . "in line from $url: $_\n";
	    warn "fields are: " . join("\n", @fields) . "\n";
	    warn "skipping line\n";
	    next;
	}
	my ($title, $time, $when, $episode_num, $episode_name, $cast,
	    $director, $duration, $main_desc, $type, $subtitled, $bw,
	    $stereo, $mono, $new, $repeat, $digital)
	  = @fields;
	my %p;

	# In the XMLTV format, title is multivalued, so it needs to be
	# a list.  Furthermore each element is itself a list of
	# [ string, language ].  Many other elements are like this.
	#
	$p{title} = [ [ $title, $LANG ] ];
	
	# The comment from Ananova says that the time is 'probably in
	# time zone existing at 5:00am of the correct file date'.  I
	# assume that means that it might not be, and it might instead
	# have an explicit timezone.  We'll just use the old
	# date-parsing routines to figure out the timezone.
	#
	# That means that for now, we add an element 'time' to the
	# programme details, and later on, date_programmes() turns
	# this into a proper start and stop time.
	#
	if (length $time) {
	    if (not $time =~ /^\d\d?:\d\d$/) {
		warn "bad time '$time' in line from page $url: $_";
		warn "skipping line";
		next;
	    }
	}
	else {
	    # No time was given for this programme.  This is probably
	    # because it's contained in the same 'clump' as the
	    # previous one, for example 'CBBC' at 6:45 is followed in
	    # the listings by 'Teletubbies' without a time.
	    #
	    # For this case, we give the programme the same time as
	    # the previous one.  That's the way it appears in the
	    # Ananova user-visible pages and it's what add_clumpidx()
	    # expects.
	    #
	    if (not defined $prev_time) {
		warn "no time for first line from page $url: $_";
		warn "skipping line";
		next;
	    }
	    $time = $prev_time;
	}

	# For sanity-checking the time against 'when',
	# comparing raw hours and minutes will probably be faster
	# than using Date::Manip.
	#
	$time =~ /^(\d\d?):(\d\d)$/ or die;
	my ($hours, $minutes) = ($1, $2);
	if (length($hours) == 1) {
	    $hours = "0$hours";
	    $time = "$hours:$minutes";
	}
	$p{time} = $time;
	$prev_time = $time;
	
	# The 'when' attribute can be DAYTIME, EVENING or LATENIGHT.
	# It seems a bit redundant to me.  But on the principle that
	# no scrap of information should be thrown away, we check that
	# it's sensible.
	#
	if ($when eq 'DAYTIME') {
	    if (5 <= $hours and $hours < 18) {
		# Daytime is between 05:00 and 18:00.  It overlaps
		# slightly with LATENIGHT.
		#
	    }
	    else {
		warn "time $time is wrongly considered 'DAYTIME' "
		  . "in line from url $url: $_\n";
	    }
	}
	elsif ($when eq 'EVENING') {
	    if (18 <= $hours) {
		# Evening is from 18:00 until midnight.
	    }
	    else {
		warn "time $time is wrongly considered 'EVENING' "
		  . "in line from url $url: $_\n";
	    }
	}
	elsif ($when eq 'LATENIGHT') {
	    # Latenight is until 07:00 (or sometimes a programme just
	    # beginning at that time is still latenight).  Annoyingly,
	    # 23:59 is also counted as latenight, so we'll say it runs
	    # from 23:00 to 07:00.
	    #
	    if (23 <= $hours
		or $hours < 7
		or ($hours == 7 and $minutes == 0)) {
		# Okay.
	    }
	    else {
		warn "time $time is wrongly considered 'LATENIGHT' "
		  . "in line from url $url: $_\n";
	    }
	}
	else {
	    warn "unknown 'when' specifier $when "
	      . "in line from url $url: $_";
	}

	# Episode number.
	if (length $episode_num) {
	    if ($episode_num =~ m!^[0-9/]+$!) {
		# Assume that Ananova numbers episodes from 1; but
		# XMLTV - like all good languages - counts from 0.
		#
		$episode_num =~ s/^(\d+)/$1 - 1/e;

		# We don't know the series or season.
		$p{'episode-num'} = [ ". . $episode_num", 'xmltv_ns' ];
	    }
	    else {
		warn "bad episode number '$episode_num' "
		  . "in line from url $url: $_";
	    }
	}

	# Epsiode name.  This corresponds to the badly named
	# 'sub-title' in XMLTV.
	#
	if (length $episode_name) {
	    $p{'sub-title'} = [ [ $episode_name, $LANG ] ];
	}

	# Cast.
	if (length $cast) {
	    foreach (split /\s*,\s*/, $cast) {
		push @{$p{credits}{actor}}, $_;
	    }
	}

	# Director.
	if (length $director) {
	    foreach (split /\s*,\s*/, $director) {
		push @{$p{credits}{director}}, $_;
	    }
	}
	
	# Ananova's idea of 'duration' is usually the original length
	# of a film - not the length it is shown at on TV.  Now we do
	# have a 'length' element in the XMLTV format, but that's
	# meant for the length _as shown_, just not including adverts
	# or other junk.  So we just discard duration.
	#
	# There is an occasional bug in the site where the duration has
	# what looks like a year stuck three times onto the end.  As
	# in '85 mins1997 1997 1997'.
	#
	$duration =~ s/(\d{4}) \1 \1$//;
	if ($duration ne '' and $duration !~ /^(\d+)\s+(?:mins|minutes)$/) {
	    warn "bad duration $duration "
	      . "in line from url $url: $_";
	}

	# Programme type.
	if (length $type) {
	    foreach (split /\s*,\s*/, $type) {
		# Convert Ananova's categories into English.
		my %lookup = (chldren => 'children',
			      diy => 'DIY');
		$_ = lc;
		$_ = $lookup{$_} if defined $lookup{$_};
		push @{$p{category}}, [ $_, $LANG ];
	    }
	}

	# Subtitles.  Assume that when Ananova say this, they mean
	# teletext (I don't know what happens for foreign films with
	# on-screen subtitles).
	#
	if ($subtitled) {
	    # We don't know what language the subtitles are in.  $LANG
	    # sets the language for the descriptions, not the
	    # programmes themselves.
	    #
	    $p{subtitles} = [ { type => 'teletext' } ];
	}
	
	# Check 'type' of channel to decide whether video and audio
	# elements need be present.  If $p{video}{present} is false,
	# that means there's definitely no picture; if it's undefined
	# then we don't know yet.
	#
	my $ch_type = $ch->get_type();
	if ($ch_type eq 'terrestrial') {
	    # Terrestrial television.  We can't infer anything from
	    # that, because occasionally programmes are broadcast with
	    # no picture or no sound.
	    #
	}
	elsif ($ch_type eq 'satellite') {
	    # Similar.
	}
	elsif ($ch_type eq 'radio') {
	    $p{video}{present} = 0;
	    $p{audio}{present} = 1;
	}
	elsif ($ch_type eq 'duff') {
	    die "trying to download listings for duff channel";
	}
	else { die "bad type $ch_type for channel $ch" }

	# Black and white - in other words, not colour.
	if ($bw) {
	    if (defined $p{video}{present} and not $p{video}{present}) {
		warn "black-and-white flag set for a programme with no picture";
	    }
	    $p{video}{present} = 1;
	    $p{video}{colour} = 0;
	}
	
	# Stereo or mono.
	if (not $stereo and not $mono) {
	    # Just don't set any of the flags.
	}
	else {
	    if (defined $p{audio}{present} and not $p{audio}{present}) {
		warn "stereo information set for a programme with no sound";
	    }
	    $p{audio}{present} = 1;

	    if (not $stereo and $mono) {
		$p{audio}{stereo} = 'mono';
	    }
	    elsif ($stereo and not $mono) {
		$p{audio}{stereo} = 'stereo';
	    }
	    elsif ($stereo and $mono) {
		warn "line in page $url has both stereo and mono: $_";
	    }
	    else { die }
	}

	# Repeat or new.  I don't know whether these are necessarily
	# mutually exclusive - you might have an instant repeat of the
	# first episode of a new series have both.  So I won't bother
	# checking that both are not set.
	#
	if ($repeat) {
	    # 'Repeat' in British TV usually means 'previously shown
	    # on the same channel'.  It has happened that series
	    # transferred from one channel to another got repeated on
	    # the new channel as 'new'.
	    #
	    # However, we can't say this for sure.  Things can be
	    # shown on BBC1 and then 'repeated' on BBC2, for example.
	    # Short of some really ornate system to describe all
	    # different nuances of previously-shown in the file
	    # format, we just have to leave the element empty.
	    #
	    $p{'previously-shown'} = {};
	}
	if ($new) {
	    $p{new} = 1;
	}

	# I don't know what the 'digital' flag is for: Ananova says
	# 'if known to be available on as digital transmission'.  Just
	# ignore it.
	#

	# There is one main description and four additional
	# descriptions with increasing levels of detail.  We
	# sanity-check that they have more or less increasing length.
	#
	my @descs = @fields[17..20];
	foreach my $i (0 .. $#descs) {
	    next if not defined $descs[$i] or not length $descs[$i];
	    foreach my $j ($i+1 .. $#descs) {
		next if not defined $descs[$j] or not length $descs[$j];
		# Sometimes the data really does have shorter text for
		# the supposedly more detailed description.  So we
		# can't check it pedantically.  OTOH this has caught
		# some errors in data input.  So we use a heuristic:
		# the more detailed description should be at least
		# half as long as a less detailed one.
		#
		if (2 * length $descs[$j] < length $descs[$i]) {
		    unless ($warned_shorter{$descs[$j]}{$descs[$i]}++) {
			warn
			  "description $j ($descs[$j]) is much shorter than description $i ($descs[$i]) "
			    . "in line from url $url: $_";
		    }
		}
	    }
	}
	# The most detailed description should be the same as the main
	# description.  Er, except when it is not present at all.
	#
	if (defined $descs[3] and $descs[3] ne '' and $descs[3] ne $main_desc) {
	    warn "description 3 ($descs[3]) isn't the same as main desc ($main_desc) "
	      . "in line from url $url: $_";
	    # Add on the main description so we don't lose it.
	    push @descs, $main_desc;
	}
	my %seen;
	foreach (reverse @descs) {
	    next if $_ eq '';
	    next if $seen{$_}++;
	    push @{$p{desc}}, [ $_, $LANG ];
	}

	# Channel.  By now we know the definitive display name of the
	# channel, so we can call get_xmltv_id().
	#
	$p{channel} = $ch->get_xmltv_id();

	# Source - used for debugging and written out only as a
	# comment in the output.
	#
	$p{source} = $file;

	push @r, \%p;
    }
    return \@r;
}


# check_page_date()
#
# Check the date in a day's listings matches what we expect.
# According to Ananova's comment there's some odd procedure you have
# to follow to make sure it is correct.
#
sub check_page_date($$) {
    my ($got, $expected) = @_;

    if (not $got =~
/^((?:Sun|Mon|Tues|Wednes|Thurs|Fri|Satur)day)\|(\d\d)\|(\d\d)\|(\d\d\d\d)$/)
    {
	warn "bad date '$got'";
	return 0;
    }
    my ($weekday, $dd, $mm, $yyyy) = ($1, $2, $3, $4);
    t "got date: $weekday $yyyy-$mm-$dd";
    my $dp = ParseDate("$yyyy-$mm-$dd");
    if (not defined $dp) {
	warn "bad date '$got'";
	return 0;
    }
    t "parsed out date $dp, check it matches $weekday";
    if (UnixDate($dp, '%A') ne $weekday) {
	# Apparently you have to step backwards by one or two days
	# until the date matches the weekday given.
	#
	my $found = 0;
	foreach (0, 1) {
	    $dp = DateCalc($dp, '- 1 day'); die if not defined $dp;
	    if (UnixDate($dp, '%A') eq $weekday) {
		$found = 1;
		last;
	    }
	}
	if (not $found) {
	    warn "weekday of $got is wrong (even tried going back a couple of days)";
	    return undef;
        }
    }

    # But does it match what we expect?
    if (UnixDate($dp, '%Q') ne UnixDate($expected, '%Q')) {
	if ($using_cache) {
	    unless ($warned_wrong_date++) {
		warn "since cache is in use, ignoring wrong date in pages\n";
	    }
	}
	else {
	    warn "wrong date in page\n";
	    return 0;
	}
    }

    return 1;
}


# date_programmes()
#
# Given a list of programme details (from extract_progs()) and the date
# of this listing, add proper time and date for each programme.  In UT.
#
# Parameters:
#   reference to list of programme details
#   date in Date::Manip format
#
# Modifies the list passed in, so that each programme no longer has
# {time} but has {start} instead.  If the programme has
# {length}, gets rid of that too and puts in {stop}.
#
sub date_programmes($$) {
#    local $Log::TraceMessages::On = 1;
    die 'usage: date_programmes(ref to list of programmes, date)'
      if @_ != 2;
    my ($progs, $base_date) = @_;
    t 'adding date to programmes: ' . d $progs;
    t 'base date: ' . d $base_date;
    my $base_day = UnixDate($base_date, '%Q');
    die if not defined $base_day;
    die 'bad base day, format should be YYYYMMDD'
      if $base_day !~ /^\d{8}$/;

    my $prev_date;
    my $day_later = ParseDateDelta('+1 day') or die;
    my $current_tz = 0; # not undef, because of Memoize complaining

    foreach (@$progs) {
	t('adding date to programme ' . d($_));
	my $t = $_->{'time'};
	
	# $t should be hours and minutes, add seconds
	$t =~ s/\b(\d\d):(\d\d)\b/$1:$2:00/ or die "bad hh:mm $t";

	if (defined gettz($t)) {
#	    local $Log::TraceMessages::On = 1;
	    t "found explicit timezone $t, using for future progs";
	    $current_tz = gettz($t);
	}

	t "doing 24h UK time $t with base day $base_day";
	my $prog_date = parse_uk_date("$base_day $t", $current_tz);
	if (not defined $prog_date) {
	    # It's not a valid UK time.  Two reasons for this: it
	    # really isn't, or we're just confused about what day it
	    # is and need to 'jump' forward a day.
	    #
	    t 'that date is bad, maybe need to jump a day?';
	    my $err;
	    my $new_base_day = UnixDate
	      DateCalc($base_day, $day_later, \$err),
	      '%Q';
	    die "error from DateCalc(): $err" if defined $err;
	    my $new_prog_date = parse_uk_date("$new_base_day $t", $current_tz);
	    die "bad base day + time '$t' (even tried next day)"
	      if (not defined $new_prog_date) or ($new_prog_date !~ /\S/);
	    t 'okay... assume we will jump a day (do it later)';
	}

	if ((not defined $prog_date)
	    or (defined $prev_date
		and (Date_Cmp($prev_date, $prog_date) > 0) ) )
        {
	    # Seem to have jumped backwards in time.  Must be the next
	    # day - but see below.
	    #
	    t 'time is lower than before';
	    my $prev_day = UnixDate $prev_date, '%Q';
	    t 'previous programme was at ' . d($prev_date);
	    my $threshold = ParseDate("$prev_day 12:00:00");
	    t 'threshold is ' . d($threshold);
	    if (Date_Cmp($prev_date, $threshold) < 0) {
		# I can't believe that one programme would last from
		# before 12:00 until after midnight on any day.  So
		# this seeming jump to the next day is bogus - it's
		# the same day but the time is a little bit earlier
		# for some reason.  (Probably UT/BST switching)
		#
		t 'previous programme started before threshold, ' .
		  'cannot be next day';
	    }
	    else {
		t 'must be next day';
		my $err;
		$base_day = UnixDate
		  DateCalc($base_day, $day_later, \$err),
		  '%Q';
		die "error from DateCalc(): $err" if defined $err;
		$prog_date = parse_uk_date("$base_day $t", $current_tz);
		die "bad base day + time '$t'"
		  if (not defined $prog_date) or ($prog_date !~ /\S/);
		t 'new base day: ' . d($base_day);
	    }
	}

	delete $_->{'time'};
	$_->{start} = ud($prog_date);
	t 'new start time: ' . d($_->{start});
	$prev_date = $prog_date;

	if (defined(my $length = delete $_->{length})) {
	    # Try to calculate the stop time based on start time and length.
	    if (not defined $_->{stop}) {
		my $stop = DateCalc(ParseDate($_->{start}), "+ $length");
		if (defined $stop) {
		    $_->{stop} = ud($stop);
		}
		else {
		    warn "could not calculate stop time from $_->{start} + $length";
		}
	    }
	    else {
		warn 'programme has both length and stop';
	    }
	}
    }
}


# add_clumpidx()
#
# Sometimes two programmes on a channel are given the same
# start time in the listings.  This seems to happen when the
# first is a 'mothership' containing several smaller things,
# for example '11:00 The Core, 11:00 Core News'.
#
# We add a 'clumpidx' attribute to distinguish these
# programmes.  Eg 'The Core' has clumpidx '0/2' and 'Core
# News' has '1/2'.
#
# Parameters:
#   a reference to a list of programmes for one channel, which will
#   be modified
#
sub add_clumpidx($) {
    die "usage: add_clumpidx(ref to list of programmes)"
      if @_ != 1;
    my $progs = shift;
    t('add_clumpidx() ENTRY');

    my $last_start;
    my %num_in_clump; # Maps start time to num. progs at that time
    foreach (@$progs) {
	t 'looking at programme: ' . d($_);
	my $start = ParseDate($_->{start});
	t '$start=' . d($start);
	$_->{clumpidx} = $num_in_clump{$start}++;
	t 'clumpidx now ' . d($_->{clumpidx});

	if ($num_in_clump{$start} > 1) {
	    if (not defined $last_start or $last_start ne $start) {
		warn <<END
more than one programme at $start on same channel, \
but not consecutive in listings (this is $_->{title})
END
				 ;
	    }
	}
	$last_start = $start;
    }

    # Okay, we've got clumpidx of '0', '1' where needed, but even
    # better would be '0/2', '1/2'.  We look at how many programmes
    # are in each clump: if only one, remove the clumpidx entirely.
    # If more than one, put the full 'x/y' clumpidx.
    #
    t "refine clumpidx's and build todo list";
    my %todo;
    foreach (@$progs) {
	t 'looking at programme: ' . d($_);
	my $start = ParseDate($_->{start});
	my $num = $num_in_clump{$start};
	die if not defined $_->{clumpidx};
	if ($num == 1) {
	    # Ordinary, sane programme not sharing its slot.  This
	    # would have a clumpidx of '0/1', which isn't worth
	    # putting in the output.
	    #
	    t 'only programme in slot';
	    die if $_->{clumpidx} ne '0';
	    delete $_->{clumpidx};
	}
	elsif ($num > 1) {
	    t 'shares a slot';
	    $_->{clumpidx} .= "/$num";
	    t 'new clumpidx: ' . d($_->{clumpidx});
	    push @{$todo{$start}}, $_;
	    t "\$todo{$start} now " . d($todo{$start});
	}
	else { die }
    }
    t 'add_clumpidx() EXIT';
}

# Write channels which are used.  We can't write channels which we
# didn't use, because we never downloaded any files for them and so
# never found out what the definitive display name was.  Fortunately,
# writing out channels that weren't used is pointless anyway :-).
#
# Parameters:
#     XMLTV::Writer to use
#     whether all channels are wanted
#     ref to hash mapping channel type to wanted
#     ref to hash mapping xmltv id to wanted
#     ref to hash mapping region to wanted
# FIXME should pass this 'channel wanted' info better
#
sub write_channels( $$$$$ ) {
#    local $Log::TraceMessages::On = 1;
    my $writer = shift;
    my $want_all = shift;
    use vars '%wanted_type'; local *wanted_type = shift;
    use vars '%wanted_xmltv_id'; local *wanted_xmltv_id = shift;
    use vars '%wanted_region'; local *wanted_region = shift;
    my @wanted;
    foreach (XMLTV::Ananova_Channel->all()) {
	t 'is this channel wanted? : ' . d $_;
	my $type = $_->get_type();
	die "channel $_ has unknown type" if not defined $type;
	if ($want_all
	    or $wanted_type{$type}
	    or $type eq 'terrestrial' and wanted_by_region($_)) {
	    t 'all, or by type, or by region: yes';
	    push @wanted, $_;
	    next;
	}
	
	my $xmltv_id = $_->get_xmltv_id();
	if (defined $xmltv_id and $wanted_xmltv_id{$xmltv_id}) {
	    t 'by XMLTV id, yes';
	    push @wanted, $_;
	    next;
	}
	t 'no';
    }

    my @new_wanted;
    foreach (@wanted) {
	# The XMLTV id and display name should be available by now.
	# If not, something went wrong downloading that channel and it
	# shouldn't be output.
	#
	my $has_xmltv_id = (defined $_->get_xmltv_id());
	my $has_dn = (defined $_->get_main_display_name());

	if (not $has_xmltv_id) {
	    warn 'cannot find or make XMLTV id for channel ' . $_->stringify() . ', not writing';
	    next;
	}

	if (not $has_dn) {
	    warn 'channel ' . $_->stringify() . ' has no display name, not writing';
	    next;
	}

	push @new_wanted, $_;
    }
    foreach (sort { $a->get_xmltv_id() cmp $b->get_xmltv_id() } @new_wanted) {
	$_->write($writer, $LANG);
    }
}
sub wanted_by_region($) {
    my $ch = shift;
    foreach (keys %wanted_region) {
	return 1 if $ch->is_region($_);
    }
    return 0;
}


####
# Channels stuff
#

# In principle it should be possible to find all channel data by
# looking at the Ananova site.  However they don't use the RFC2838
# style names, and I also want to add some extra display names for
# channel numbers.  So there's a hardcoded table listing XMLTV channel
# ids, their equivalent on the Ananova site, and optionally an extra
# (short) display name for that channel.
#
# It can be hard to decide whether two related channels should map to
# the same internal name - eg digital and analogue versions of the
# same channel.  I have made different internal names if I know that
# the content will be different (eg BBC1 digital is different to any
# of the analogue region versions), but otherwise mapped both channels
# to the same internal name.  Sometimes there are annoying small
# differences which require differing internal names, else
# tv_sort complains.  The same applies to regional variants for
# channels which don't differ between regions (eg Channel 5).
#
# Piping the output through tv_sort will check that the two
# versions of a channel are indeed identical.
#
sub init_channels() {
    # See the distributed version of this file for info about the
    # format.
    #
    my $channel_names_file = "$OUR_SHARE_DIR/channel_ids";
    local *FH;
    open (FH, "<$channel_names_file")
      or die "cannot open $channel_names_file: $!";
    while (<FH>) {
	s/^\s+//; s/\s+$//; s/\#.*//;
	next unless length;
	my @fields = split /:/;
	die "$channel_names_file:$.: wrong number of fields"
	  if @fields < 2 or @fields > 3;

	my ($xmltv_id, $ananova_ids, $extra_dn) = @fields;
	my @aids = split /,/, $ananova_ids;
	die "$channel_names_file:$.: no Ananova ids"
	  if not @aids;

	t "initializing channel with id $xmltv_id";
	my $ch = new XMLTV::Ananova_Channel();
	$ch->set_xmltv_id($xmltv_id);
	foreach (@aids) {
	    t "adding Ananova id $_";
	    $ch->add_ananova_id($_);
	}
	t 'maybe adding extra display name: ' . d $extra_dn;
	$ch->add_extra_display_names($extra_dn)
	  if defined $extra_dn;
    }
    close FH or warn "cannot close $channel_names_file: $!";
}

# Return a hash mapping package names to lists of XMLTV channel ids.
sub get_channel_pkgs() {
    # Each package is a file under channel_pkgs/ somewhere in share/.
    # The filename is the package name, and then channel ids are
    # listed one per line.
    #
    my $channel_pkgs_dir = "$OUR_SHARE_DIR/channel_pkgs";
    die "no directory $channel_pkgs_dir" if not -d $channel_pkgs_dir;
    my %pkgs;
    foreach (<$channel_pkgs_dir/*>) {
	m!^\Q$channel_pkgs_dir\E/(.+)$! or die;
	my $pkg_name = $1;
	die "package $pkg_name seen twice" if defined $pkgs{$pkg_name};
	open(PKG, "$_") or die "cannot read channel package file $_: $!";
	while (<PKG>) {
	    s/^\s+//; s/\s+$//; s/\#.*//;
	    next unless length;
	    push @{$pkgs{$pkg_name}}, $_;

	    # Check the XMLTV id is actually known.
	    my $ch = XMLTV::Ananova_Channel->find_by_xmltv_id($_);
	    if (not defined $ch) {
		warn "channel id $_ mentioned in package $pkg_name, but not known";
	    }
	}
	close PKG or die "cannot close $_: $!";
    }
    return %pkgs;
}


# get_pages()
#
# Fetch the given 'pages' from Ananova.  Attempt to combine multiple
# page fetches.
#
# Parameters:
#   text to use for progress bar
#   listref of page names to download, eg for show=dir name is 'dir'
#
# Returns: reference to hash mapping page name to a hash with 'url'
# and 'content'.  Although 'url' may be shared with other pages.
#
# Dies if a page cannot be downloaded.
#
sub get_pages( $$ ) {
    my ($text, $pages) = @_;
    my @pages = @$pages;
    my %r;
    my $num_pages = scalar @pages;
    t "initializing progress bar with $num_pages items";
    my $bar = new Term::ProgressBar($text, $num_pages);

    # Arbitrary limit on number of pages fetched at once, requested by
    # Ananova to keep down memory usage on the server.
    #
    my $max_at_once = 10;
    while (@pages) {
	my @this_fetch = ();
	while (@pages and (@this_fetch < $max_at_once)) {
	    push @this_fetch, shift @pages;
	}
	t 'this fetch: ' . d \@this_fetch;
	t 'remaining to fetch: ' . d \@pages;
	my $url = "$A?" . join('&', map { "show[]=$_" } @this_fetch);
	t "fetching url: $url";
	foreach (@this_fetch) { $r{$_}->{url} = $url }
	my $got = get $url;
	die "cannot fetch $url" if not defined $got;
	
	# Each new page begins with some comment (#) lines.
	my @lines = split /\n/, $got;
	my @got;
	my $curr = '';
	my $in_comment = 1;
	foreach (@lines) {
	    my $is_comment = /^\#/;

	    # Horrible kludge: there is one page which does have a
	    # comment in the middle of it, ignore that line.
	    #
	    $is_comment = 0 if /^\#\s+OK,/;

	    if (not $is_comment and not $in_comment) {
		# Another ordinary line on the current page.
		$curr .= "$_\n";
	    }
	    elsif (not $is_comment and $in_comment) {
		# Reached the end of the comments on the current page.
		$curr .= "$_\n";
		$in_comment = 0;
	    }
	    elsif ($is_comment and not $in_comment) {
		# Reached some comments, must be start of next page.
		t 'reached end of page: ' . d $curr;
		push @got, $curr; update $bar;
		$curr = "$_\n";
		$in_comment = 1;
	    }
	    elsif ($is_comment and $in_comment) {
		# Another comment at the top of the current page.
		$curr .= "$_\n";
	    }
	    else { die }
	}
	t 'last page: ' . d $curr;
	push @got, $curr; update $bar;
	if (@got != @this_fetch) {
	    die 'expected ' . (scalar @this_fetch) .
	      " pages from URL $url, got " . (scalar @got);
	}
	foreach (@this_fetch) {
	    die "page $_ requested twice" if defined $r{$_}->{content};
	    $r{$_}->{content} = shift @got;
	}
    }
    die if (keys %r) != $num_pages;
    return \%r;
}
