#!/usr/bin/perl -w

=pod

=head1 NAME

tv_grab_na_dd - Grab TV listings for North America using Zap2IT's Data Direct service.

=head1 SYNOPSIS

    tv_grab_na_dd --help

    tv_grab_na_dd --configure [--config-file FILE] [--dd-data FILE]
                              [--reprocess] [--auto-config add|ignore]

    tv_grab_na_dd --list-lineups [--config-file FILE] [--dd-data FILE]
                              [--reprocess]

    tv_grab_na_dd [--config-file FILE] [--dd-data FILE]
                  [--reprocess] [--auto-config add|ignore]
                  [--days N]  [--offset N] [--quiet]
                  [--old-chan-id] [--low-mem] [--output FILE]
                  [--list-channel]

=head1 DESCRIPTION

This scripts downloads listings from Zap2IT's DataDirect service,
converts it to XMLTV format, and outputs the results.

You must first register with Data Direct at: L<http://labs.zap2it.com>

You'll need to provide the XMLTV certificate code C<ZYZM-TE5O-SBUT> (Letter O)

The data is provided free of charge, except for a short periodic web survey.

Once you've registered, run C<tv_grab_na_dd --configure> to provide
your username and password.

Once configured, running B<tv_grab_na_dd> with no arguments will output
listings in XML format to standard output.

=head1 Mode selection (default is grab mode) 

=over

=item --configure

Activates configure mode,  If a config file already exists the values are used as defaults.

=item --list-lineups

Lists available lineups.  Only requires username in the config file. Used by programs that
automate the L<--configure> process.


=back

=head1 General Options

=over

=item --config-file I<file>

Set the name of the configuration file, the default is B<~/.xmltv/tv_grab_na_dd.conf>.
This is the file created during L</--configure> mode.

=item --dd-data I<file>

Store DataDirect data to this file. (default is a temporary file)

=item --reprocess

Don't don't get data from DataDirect, but reprocess a file saved with L</--dd-data>.

=item --auto-config I<add|ignore>

When used in --configure mode, updates the config file, removing old channels, and adding or
ignoring new channels.  Prompts are skipped if defaults are available in the current config file.

When used in grab mode, appends new channels to the config file.

=back

=head1 Grabber Mode options

=over

=item --days I<n>

grab I<n> days.  The default is 7. 

=item --offset I<n>

start N days in the future.  The default is to start
from today.

=item --quiet

suppress some messages normally written to standard error.

=item --old-chan-id

use a channel id similar to L<tv_grab_na>

=item --low-mem

Omit all but the most basic program information. Reduces memory usage.

=item --output I<file>

write xml to I<file> rather than standard output.

=item --list-channel

same as L<--days> 0

=back

=head1 Automating configuration

Sometimes applications want to call B<tv_grab_na_dd> as a standalone application,
but automate the configure process.  The best way is to hook in to the XMLTV::Ask module,
but if that's not available, here is a solution.

=over

Step1. Application creates config file with username (and optionally password).

Step2. C<tv_grab_na_dd --dd-file lineups.xml --list-lineups> 

Step3. Application adds desired lineup to config file.

Step4. C<tv_grab_na_dd --dd-file lineups.xml --reprocess --auto-config add --list-channels>

Step5. Application edits config file as needed, and deletes lineups.xml.

=back

=head1 Notes on lineups

tv_grab_na_dd only outputs a single lineup. If your DataDirect
account has multiple lineups, they are all downloaded even though only one is output.

To process multiple lineups, specify a different L</--config-file>.
To prevent re-downloading the data on subsequent passes, the L<--reprocess> option is recommended.

=head1 Notes on channel lists

Channel lists can be configured both at the DataDirect website and through the grabber.  This is done to
allow multiple config files with different channel lists.  DataDirect only supports a single channel map
per lineup.

=head1 Notes on passwords

If a password is stored in the config file, the config file should be properly protected.
Instead of storing the password in the config file, it can be ommitted, and will be prompted for. 

=head1 Known issues

When run from B<xmltv.exe> on Windows 98, B<tv_grab_na_dd> sometimes crashes.  The cause
is under investigation, but seems to be data-size dependent. Try reducing L</--days>

=head1 SEE ALSO

L<xmltv(5)>.

=head1 Author

Author/Maintainer: Robert Eden, rmeden@yahoo.com

=head2 Contributors:

=over

Ed Avis, ed@membled.com

Don Huettl, drh@huettl.net

Matti Airas, mairas@iki.fi (I used tv_grab_fi as a template)

The folks at Tribune Media L<http://labs.zap2it.com/>

and of course everyone else I forgot to mention. :)

=cut

#################################################################
# initializations

use strict;
use Date::Manip;
use Time::Local;
use SOAP::Lite;
use File::Temp qw(tempfile);
use Getopt::Long;
use XML::Twig 3.10;
# use Data::Dumper;
use constant Have_bar => eval { require Term::ProgressBar; 1 };

use XMLTV;
use XMLTV::Ask;
use XMLTV::Config_file;
use XMLTV::Version '$Id: tv_grab_na_dd,v 1.22 2004/03/25 23:54:09 rmeden Exp $';
use XMLTV::Usage <<END
$0: get lists from Zap2IT's DataDirect service in XMLTV format
To Configure
    $0 --configure [--config-file FILE] [--dd-data FILE]
                              [--reprocess] [--auto-config add|ignore]
To get listings
    $0 [--config-file FILE] [--dd-data FILE]
                  [--reprocess] [--auto-config add|ignore]
                  [--days N]  [--offset N] [--quiet]  [--old-chan-id] [--low-mem]
                  [--output FILE]
END
;

#
# Global Vars
# 
my @messages;           # DD warnings.
my %chan_config;         # Active/inactive channels.
my %chan_id;            # quick channel id lookup
my %station;            # DD station data
my %lineups;            # DD channel mapping data
my %program;            # DD program data
my %crew;               # DD crew data
my %programGenre;       # DD Genre data

my $bar;                # handle for status bar
my $count;              # record count (for status bar)
my $DEBUG          =0;  # debug mode
my $config_file;        # config file name
my $tz;                 # TZ values to avoid date::manip when speed counts
my $tz_offset;
my $start_time=time();
my $prog_count=0;        # record count;

my $dd_user="";         # dd username
my $dd_pass="";         # dd password
my $dd_lineup="";       # dd lineup (empty all lineups)
my $dd_data;            # temp file handle to store DD data
my $dd_data_name;       # filename for above
my $dd_data_size;       # amount of data returned 
my $dd_start;           # dd start time
my $dd_stop;            # dd stop time

my $opt_help;           # ask for help
my $opt_configure;      # configure mode
my $opt_config_file ;   # config_file_name
my $opt_output;         # output name
my $opt_days       =10; # days to fetch
my $opt_offset     =0;  # day to start
my $opt_quiet      =0;  # supress messages
my $opt_lineup     =''; # limit results to one lineup
my $opt_old_chan_id=0;  # use tv_grab_na style chan ids
my $opt_low_mem    =0;  # use as little memory as you can
my $opt_dd_data    =''; # save dd data
my $opt_reprocess  =''; # reprocess dd data
my $opt_auto_config  =''; # auto add/ignore channels
my $opt_list_channels=''; # 
my $opt_list_lineups=''; # 

#
# Process command line
#
foreach (@ARGV) {
    tr/_/-/ if /^--/; # older option style
}
GetOptions(
	       'help'          => \$opt_help,
    	   'configure'     => \$opt_configure,
    	   'config-file=s' => \$opt_config_file,
    	   'config_file=s' => \$opt_config_file,
    	   'output=s'      => \$opt_output,
           'days=i'        => \$opt_days,
    	   'offset=i'      => \$opt_offset,
    	   'quiet'         => \$opt_quiet,
    	   'lineup=s'      => \$opt_lineup,
           'old_chan_id'   => \$opt_old_chan_id,
           'old-chan-id'   => \$opt_old_chan_id,
           'low_mem'       => \$opt_low_mem,
           'low-mem'       => \$opt_low_mem,
           'dd_data=s'     => \$opt_dd_data,
           'dd-data=s'     => \$opt_dd_data,
           'reprocess'     => \$opt_reprocess,
           'auto-config=s' => \$opt_auto_config,
           'auto_config=s' => \$opt_auto_config,
           'list-channels' => \$opt_list_channels,
           'list-lineups'  => \$opt_list_lineups,
           'debug'         => \$DEBUG,
	  )
  or usage(0);
usage(1) if $opt_help;

die 'number of days must not be negative' if ($opt_days < 0);
die "must specify --dd_data during reprocess\n" if $opt_reprocess and not $opt_dd_data;
die "--auto-config must be 'add' or 'ignore'\n" if $opt_auto_config && $opt_auto_config !~ /^(add|ignore)$/;

$opt_days    = 0 if $opt_configure || $opt_list_channels || $opt_list_lineups;
$config_file = XMLTV::Config_file::filename($opt_config_file, 'tv_grab_na_dd', $opt_quiet);

########################################################################
#
# Load config file
#
if (-e $config_file)
{
    foreach (XMLTV::Config_file::read_lines($config_file))
    {
        next unless defined $_;
        chomp;
        my( $setting, $val ) = split( /:\s+/o, $_, 2 );

        if ( $setting =~ /^(not )?channel$/o )
        {
            $chan_config{$val} = $1 ? 0 : 1;
        }
        elsif ( $setting eq 'username' )
        {
            $dd_user = $val;
        }
        elsif ( $setting eq 'password' )
        {
            $dd_pass = $val;
            print STDERR "\n**WARNING** Password in config file, protect as required\n\n";
        }
        elsif ( $setting eq 'lineup' )
        {
            $dd_lineup = $val;
        }
        else
        {
            warn "Unknown setting: $setting, skipping.\n";
        }
    }
} # load config file

#
#
# start --configure mode
#

if ( $opt_configure )
{
    open(CONF,">$config_file") or die "can't open config file: $config_file\n";
    if ( ! $opt_auto_config )
    {
        say("
Free Data Direct registration required in advance.
You can get an ID at http://labs.zap2it.com
Specify certificate code: 'ZYZM-TE5O-SBUT' (Letter O)

    ");
        $dd_user=ask("Username ($dd_user):")|| $dd_user || die "DataDirect Username Required\n";
        $dd_pass=ask("
WARNING: Storing the password in the config file is not secure
If passowrd is blank, it will be prompted as needed(more secure)
Unsecured password ('x':delete,default:$dd_pass,):")|| $dd_pass;
    }
    $dd_pass='' if $dd_pass eq 'x';
    print CONF "username: $dd_user\n";
    print CONF "password: $dd_pass\n" if $dd_pass;
}

die "You must specify a username.\n" unless $dd_user;


#
# compute start/stop time
#
{
    my $start = DateCalc(" Midnight","+ $opt_offset days") || die "Can't compute <$opt_offset> days\n";
    my $stop  = DateCalc($start,"+ $opt_days   days") || die "Can't compute <$opt_days> days\n";

#
# if days==0, back start time up by a minute to try and get only channels
#
    $start = DateCalc($start,"- 1 minute") if $opt_days==0;

    die "*ERROR* start($start) before stop($stop)\n" unless $stop gt $start;
    
    $dd_start=UnixDate(Date_ConvTZ($start,"","UTC"),"%Y-%m-%dT%H:%M:%SZ");
    $dd_stop =UnixDate(Date_ConvTZ($stop ,"","UTC"),"%Y-%m-%dT%H:%M:%SZ");

    print STDERR "dd_start: $dd_start\n" if $DEBUG;
    print STDERR "dd_stop : $dd_stop\n" if $DEBUG;

#
# generate these values to avoid date::manip later
#     this code is twice as fast!
#
    $tz = UnixDate("now","%z");
    $tz_offset = substr($tz,0,3)*3600+substr($tz,3,2)*60;
    print "Using TZ=<$tz> offset=<$tz_offset>\n" if $DEBUG;
} # compute date

#
# open dd data file (temp, or created)
#
if ($opt_reprocess)
{
    die "$opt_dd_data file not found\n" unless -e $opt_dd_data;
    $dd_data_name = $opt_dd_data;
    $dd_data      = new IO::File("<$dd_data_name");
    $dd_data_size= -s $dd_data;
}
else
{
#
# get DD data
#
    #
    # open file to store DD XML
    #
    if ($opt_dd_data)
    {
        $dd_data_name = $opt_dd_data;
        $dd_data      = new IO::File("+>$dd_data_name");
    }
    else
    {
        ($dd_data,$dd_data_name) = tempfile('tv_grab_na_dd_XXXX',
                                             DIR    => File::Spec->tmpdir(),
                                             SUFFIX => '.tmp',
                                             UNLINK=>($DEBUG ? 0 : 1));
    }

#
# Prompt for password (if needed)
#
    $dd_pass=~s/^\s//g;
    unless (length($dd_pass))
    {
        require Term::ReadKey;
        $| = 1;
        print STDERR "Password for $dd_user: ";
        Term::ReadKey::ReadMode('noecho');
        chomp($dd_pass = <STDIN>);
        Term::ReadKey::ReadMode('restore');
        print STDERR "\n";
    }

#
# Fetch data
# 
    print STDERR "Fetching from DataDirect\n";
    print STDERR "    dd_data is in $dd_data_name\n" if $DEBUG || $opt_dd_data;   

    sub SOAP::Transport::HTTP::Client::get_basic_credentials
    {
       return "$dd_user" => "$dd_pass";
    }

    my $time=time();
    my $soap= SOAP::Lite
            -> service("http://docs.tms.tribune.com/tech/tmsdatadirect/zap2it/xtvd.wsdl")
            -> outputxml('true')
#           -> on_debug(1)
            -> on_fault( sub {
                             	my($soap,$res)=@_;
                              	die "SOAP call failed: "
                             	    .(ref $res ? $res->faultstring
                              	               : $soap->transport->status)
                              	    ."\n";
                             })
            -> proxy("http://localhost/", options => {compress_threshold => 10000},
                                                      timeout            => 420);
    $dd_data->print($soap->download("<startTime>$dd_start</startTime><endTime>$dd_stop</endTime>"));
    $dd_data->flush;
    $dd_data_size= -s $dd_data;
    $time = int(time() - $time);
    printf STDERR "    Fetched %d k/bytes in %d seconds\n",$dd_data_size/1024,$time;
} # get data

#
# load supporting details
#
my $twig=XML::Twig->new(   
         twig_roots    => { HTML => 1, message => 1, xtvd => 1 },
         ignore_elts   => { schedules => 1 },
		 twig_handlers => 
		      {
		         HTML     => sub {
                                  die "\n*** FETCH ERROR***\n".$_->first_child_text;
                		         },
                 message  => sub {
                                  push @messages, $_->first_child_text;
                                  $_->twig->purge;
                                  return 1;
                                 },
		         stations => sub { $_->twig->purge;  return 1;},
		         station  => sub {
                                  my $hash=$_->simplify;
                                  $station{$hash->{id}}=$hash;
                                  $_->twig->purge;  
                                  return 1;
                		         },
		         lineups => sub { $_->twig->purge;  return 1;},
                 lineup  => sub {
                                  my $hash = $_->simplify;
                                  my $name = $hash->{name};
                                  while (exists $lineups{$name})
                                  {
                                    $name.='-2'; # deal with dupe names
                                  }
                                  $lineups{$name}=$hash;
                                  $_->twig->purge;
                                  return 1;
                                 },
		         programs=> sub { $_->twig->purge;  return 1;},
		         program => sub {
                                  my $hash=$_->simplify;
                                  if ($opt_low_mem)  # only store title/subtitle
                                  {
                                    $program{$hash->{id}}{title}=$hash->{title};
                                    $program{$hash->{id}}{'subtitle'}=$hash->{subtitle} if exists $hash->{subtitle};
                                  }
                                  else
                                  {
                                    $program{$hash->{id}}=$hash;
                                  }
                                  $_->twig->purge;  
                                  return 1;
                		         },  
                 productionCrew => sub { $_->twig->purge;  return 1;},
		         crew    => sub {
                                  unless ($opt_low_mem)
                                  {
                                    my $hash=$_->simplify;
                                    $crew{$hash->{program}}=$hash;
                                  }
                                  $_->twig->purge;  
                                  return 1;
                  		          },
                 genres       => sub { $_->twig->purge;  return 1;},
		         programGenre => sub {
                                  unless ($opt_low_mem)
                                  {
                                    my $hash=$_->simplify;
                                    $programGenre{$hash->{program}}=$hash;
                                  }
                                  $_->twig->purge;  
                                  return 1;
                  		          },
		         _default_ => sub {  # for some reason this is not being processed last, can't do the purge
                                  unless ( $opt_quiet || $count++ % 1000 )
                                  {
                                     if ($bar) { $bar->update(tell($dd_data)) }
                                     else      { print STDERR "."            };
                                  }
                                  return 1;
                  		          },
	         });

unless ($opt_quiet)
{
    if (Have_bar) { $bar = new Term::ProgressBar('loading data',$dd_data_size+1) }
    else          { print STDERR "loading data "; }
}
seek($dd_data,0,0);  #rewind
$twig->parse( $dd_data );
$bar->update($dd_data_size+1) if $bar;
print STDERR "\n" unless ($opt_quiet || $bar );

$twig=undef;  # destroy twig (just in case)

#
# --list-lineup mode
#
if ($opt_list_lineups)
{
    printf STDERR "%-42s|%-6s|%-20s|%s\n","Lineup ID","Postal","Type","Device";
    for my $id (sort keys %lineups)
    {
          printf STDERR "%-42s|%-6s|%-20s|%s\n",$id,
                                                  ,$lineups{$id}{postalCode}||'',
                                                  ,$lineups{$id}{type}||'',
                                                  ,$lineups{$id}{device}||'';
    }
    exit 0;    
}

#
# --configure stage2, process channel list
#
if ($opt_configure)
{
    my %chan_found=();
    my $key;
    $dd_lineup = (keys %lineups)[0] unless $dd_lineup;
    if (! $opt_auto_config)
    {
        $dd_lineup = askQuestion("\nWhich Lineup? ($dd_lineup)",$dd_lineup,sort keys %lineups);
    }
    print CONF "lineup: $dd_lineup\n";

    foreach (@{$lineups{$dd_lineup}{map}})
    {
       my $res='yes';
       my $key=sprintf("%d %s",$_->{channel},$station{$_->{station}}{callSign});
       $chan_found{$key}=1;
       if ($opt_auto_config)
       {
            if (exists $chan_config{$key})
            {
            }
            elsif ($opt_auto_config eq 'add')
            {
                print STDERR "Adding new channel: $key\n";
                $chan_config{$key}=1;
            }
            else
            {
                print STDERR "Ignoring new channel: $key\n";
                $chan_config{$key}=0;
            }
       }
       else
       {
            $res='no' if exists $chan_config{$key} and ! $chan_config{$key};
            $res = askQuestion("Add channel $key?",$res,qw(yes no all none ));
            $chan_config{$key}=1       if $res=~/^[ya]/i;
            $chan_config{$key}=0       if $res=~/^[n]/i;
            $opt_auto_config='add'     if $res=~/^all/i;
            $opt_auto_config='ign'     if $res=~/^none/i;
       } # ask question (or --auto-new )

       print CONF ( $chan_config{$key} ? '' : 'not ' ), "channel: $key\n";
    } # channel loop

    foreach (sort keys %chan_config)
    {
        next if $chan_found{$_};
        print STDERR "Channel '$_' no longer exists\n";
    }
    close CONF;
    exit 0;
} # --configure channel list



#
# open output file
# 
my %w_args;
my $writer;
if (defined $opt_output) {
                            my $fh = new IO::File(">$opt_output");
                            die "cannot write to $opt_output: $!" if not defined $fh;
                            $w_args{OUTPUT} = $fh;
                         }
$w_args{encoding} = 'ISO-8859-1';

$writer = new XMLTV::Writer(%w_args);
$writer->start( {
              'source-info-name'     => 'TMS Data Direct Service',
              'source-info-url'      => 'http://labs.zap2it.com/',
              'generator-info-name'  => 'XMLTV',
      	      'generator-info-url'   => 'http://www.xmltv.org/',
            });

#
# write stations, removing those we don't care about
#
for my $map (@{$lineups{$dd_lineup}{map}})
{
    my $myid = sprintf("I%d.labs.zap2it.com",$map->{station});

    my $station=$station{$map->{station}};
    my $key=sprintf("%d %s",$map->{channel},$station->{callSign});

#
# detect new channel (appending to config file is lame, but it works)
#
    unless (exists $chan_config{$key})
    {
       $chan_config{$key}=0; # default ignore
       if ($opt_auto_config)
       {
          $chan_config{$key}=1 if $opt_auto_config eq 'add'; 
          print STDERR ( $opt_auto_config eq 'add' ? "Adding" : "Ignoring" )," new channel: $key\n";

          open(CONF,">>$config_file") or die "can't open config file for update: $config_file\n";
          print CONF ( $chan_config{$key} ? '' : 'not ' ), "channel: $key\n";
          close CONF;
       }
       else
       {
           print STDERR "New channel found, rerun --configure: $key\n";
       }
    } # new channel

    next unless $chan_config{$key}; #skip?

#
# generate tv_grab_na channel number
#
    if ($opt_old_chan_id)
    {
       $myid = sprintf("C%d%s.zap2it.com",$map->{channel},lc($station->{callSign}));
    }

#
# Set display names:
#           channel + callSign
#           channel + callSign + lineup
#           channel (only)
    my @names;
    push @names, [ sprintf("%s %s"   ,$map->{channel},$station->{callSign})];
    push @names, [ sprintf("%s %s %s",$map->{channel},$station->{callSign},$dd_lineup)];
    push @names, [ $map->{channel} ];

# 
# Now add display names for the fcc
#
    push @names,[sprintf("%d %s %s",$station->{fccChannelNumber},
                                    $station->{callSign},
                                    'fcc')] if exists $station->{fccChannelNumber};

#
# round up the rest we have
#
    for my $key (qw(callSign name affiliate))
    {
            push @names,[ $station->{$key} ] if exists $station->{$key};
    }
    
    unless (@names)
    {
        warn "No display names defined for channel $myid\n";
        next;
    }

    $writer->write_channel({ 'id'           => $myid,
                             'display-name' => \@names});
    $chan_id{$station->{id}}=$myid;
} # output  channels


#
# prepare to output schedule
#
$twig=XML::Twig->new( twig_roots => { schedule => 1 }, twig_handlers => {                 
    schedule => sub {
                     $prog_count++;
                     unless ( $opt_quiet || $count++ % 10 )
                     {
                       if ($bar) { $bar->update(tell($dd_data)) }
                      else      { print STDERR "."            };
                     }

                     my %prog=();
                     my $ptr;
                     my $twig=$_;
                     $_=$_->simplify;

                     ## Skip programs not in our lineup.
		     if (exists $chan_id{$_->{station}}) {
                  
		
#
# start with elements from schedule tag
#

#
# we generated a TZ offset a while back... this is twice as fast as Date::Manip!
#
                    my $start = timegm(
                                        int( substr($_->{time},17,2) ),
                                        int( substr($_->{time},14,2) ),
                                        int( substr($_->{time},11,2) ),
                                        int( substr($_->{time},8,2) ),
                                        int( substr($_->{time},5,2) - 1 ),
                                        int( substr($_->{time},0,4) - 1900 ) );
                     my @gStart = gmtime( $start+$tz_offset );
                     $prog{start} = sprintf("%d%02d%02d%02d%02d%02d %s",
		                             $gStart[5] + 1900,
					     $gStart[4] + 1,
					     @gStart[3,2,1,0],
					     $tz);

                     my $h = substr($_->{duration},2,2);
                     my $m = substr($_->{duration},5,2);
                     my $stop = $start + ( ( $h * 60 ) + $m ) * 60;
                     my @gStop = gmtime( $stop+$tz_offset );
                     $prog{stop} = sprintf("%d%02d%02d%02d%02d%02d %s",
		                            $gStop[5] + 1900,
					    $gStop[4] + 1,
					    @gStop[3,2,1,0],
					    $tz);

                     $prog{channel} = $chan_id{$_->{station}};
                     $prog{'previously-shown'}={}           if exists $_->{repeat};
                     $prog{audio}{stereo}='stereo'          if exists $_->{stereo};
                     $prog{subtitles}=[{type=>'onscreen' }] if exists $_->{subtitled};
                     push @{ $prog{rating} }, [$_->{tvRating},'VCHIP'] if exists $_->{tvRating};

                     if (exists $_->{part} )
                     {
                          $prog{clumpidx} = sprintf("%d/%d",$_->{part}{number},
                                                            $_->{part}{total})
                     }

#todo.. parse program ID to get episode num
#                     if ( $_->{program} =~ /^EP/ )
#                     {
#                            #episode-num?
#                     }
                   
#
# add elements from program tag
#
                     if ($ptr = $program{$_->{program}})
                     {
                        $prog{title}        =[[$ptr->{title},      'en']] if exists $ptr->{title};
                        $prog{'sub-title'}  =[[$ptr->{subtitle}   ,'en']] if exists $ptr->{subtitle};
                        $prog{desc}         =[[$ptr->{description},'en']] if exists $ptr->{description};
                        $prog{date}         =$ptr->{year}                 if exists $ptr->{year};

                        $prog{length}       =substr($ptr->{runTime},2,2)*3600+
                                             substr($ptr->{runTime},5,2)*60 if exists $ptr->{runTime};

                        push @{ $prog{rating} }, [$ptr->{mpaaRating},'MPAA'] if exists $ptr->{mpaaRating};

                        
                        if (exists $ptr->{colorCode})
                        {
                            $prog{video}{colour}=$ptr->{colorCode}; # wants boolean but try anyway
                            $prog{video}{colour}=0 if $ptr->{colorCode} =~ /^B/i;
                        }


                        if (exists $ptr->{starRating})
                        {
                             my $star=length($ptr->{starRating});
                             if ($ptr->{starRating} =~ /\+$/)
                             {
                                  $star -= .5;
                                  $prog{'star-rating'}=[sprintf("%1.1f/%d",$star,4)];
                             }
                             else
                             {                              
                                  $prog{'star-rating'}=[sprintf("%d/%d",$star,4)];
                             }
                        }
                     } # %program items

#
# add elements from program Genre tag
#
                     if ($ptr = $programGenre{$_->{program}})
                     {
                        $prog{category}=[];
                        if (ref $ptr->{genre} eq 'HASH')
                        {
                            push @{$prog{category}},[$ptr->{genre}{class},'en'];
                        }
                        else
                        {
                            foreach (@{$ptr->{genre}})
                            {
                                push @{$prog{category}},[$_->{class},'en'];
                            }
                        }
                     } # Genra items

#
# add elements from crew tag
#
                     if ($ptr = $crew{$_->{program}})
                     {
                        my ( @director, @actor, @writer, @adapter, @producer,
                             @presenter, @commentator, @guest );
                        $ptr->{member}=[$ptr->{member}] if (ref $ptr->{member} eq 'HASH');
                        foreach (@{$ptr->{member}})
                        {
                            my $name="";
                            $name.=$_->{givenname}." " unless ref $_->{givenname};
                            $name.=$_->{surname}       unless ref $_->{surname};
                            push @actor     ,$name if $_->{role} eq 'Actor';
                            push @guest     ,$name if $_->{role} eq 'Guest Star';
                            push @presenter ,$name if $_->{role} eq 'Host';
                            push @director  ,$name if $_->{role} eq 'Director';
                            push @producer  ,$name if $_->{role} eq 'Executive Producter';
                            push @producer  ,$name if $_->{role} eq 'Producter';
                            push @writer    ,$name if $_->{role} eq 'Writer';
                        }

                        $prog{credits}{actor    }=\@actor     if @actor   ;
                        $prog{credits}{director }=\@director  if @director;
                        $prog{credits}{guest    }=\@guest     if @guest;
                        $prog{credits}{presenter}=\@presenter if @presenter;
                        $prog{credits}{producer }=\@producer  if @producer;
                        $prog{credits}{writer   }=\@writer    if @writer;
                     } #crew items

#
# write record
#
                     $writer->write_programme(\%prog);
		} # channel exists
                     $twig->twig->purge;
                     return 1;
       		     } # schedule subroutine
	         }); #twig setup

#
# rescan data, looking for schedule items
#
seek($dd_data,0,0);  #rewind
unless ($opt_quiet)
{
    if (Have_bar) { $bar = new Term::ProgressBar('Writing schedule',$dd_data_size+1) }
    else          { print STDERR "Writing schedule"; }
}
my $time=time();
$twig->parse( $dd_data );
print STDERR "\n" unless ($opt_quiet || $bar );
$bar->update($dd_data_size+1) if $bar;

$writer->end();
if (@messages)
{
    warn join( "\n", @messages ), "\n";
}

printf STDERR "Downloaded %d programs in %d seconds\n",$prog_count,time()-$start_time
    unless $opt_quiet;

exit();


