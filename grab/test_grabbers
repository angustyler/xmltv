#!/usr/bin/perl
#
# Run each of the grabbers in turn and do some checks on the output.
# This is a tool for xmltv developers to run only occasionally -
# because it does network fetches it can't be part of 'make test'!
# Run it giving the root of the xmltv source tree, after 'make'.
# It needs a test.conf file in each grabber directory.
#
# -- Ed Avis, ed@membled.com, 2005-08-20
#
use warnings;
use strict;
use Getopt::Long;
use File::Copy;
use File::Slurp;
use List::Util qw(min);
use File::chdir;

sub run;

# Run grabbers with these args.
my ($offset, $days) = (1, 2);

our $opt_configure;     # try to --configure grabbers if necessary
our $opt_only;          # run just one grabber
our $opt_list_channels; # run with --list-channels
GetOptions('configure' => \$opt_configure,
	   'only=s' => \$opt_only,
	   'list-channels' => \$opt_list_channels,
	  ) && @ARGV == 1
  or die "usage: $0 [--configure] [--only grabber] [--list-channels] xmltv-source-root-dir\n";
my $root = shift;
die "$root not a directory" if not -d $root;
my $dtd = 'xmltv.dtd';
my $dtd_in_root = "$root/$dtd";
die "$dtd_in_root not there" if not -e $dtd_in_root;

if (not -e $dtd) {
    my $symlink_exists = eval { symlink("",""); 1 };
    my $word = $symlink_exists ? 'symlink' : 'copy';
    print "${word}ing $dtd_in_root to $dtd\n";
    my $sub = $symlink_exists ? sub { symlink $_[0], $_[1] } : \&copy;
    $sub->($dtd_in_root, $dtd) or die "cannot $word: $!";
}

my @grabbers;
{
    local $CWD = "$root/grab";
    if (defined $opt_only) {
	die "no such grabber $opt_only\n" if not -d $opt_only;
	@grabbers = ($opt_only);
    }
    else {
	@grabbers = grep { -d } <[a-z]*>;
    }
}

foreach (@grabbers) {
    /^[a-z_]+$/ or die "bad grabber name $_";
    my $exe = "tv_grab_$_";
    my $exe_with_path = "perl -I $root/blib/lib $root/blib/script/$exe";
    my $config = "$root/grab/$_/test.conf";

    my $output = $opt_list_channels ? "${_}_channels.xml" : "${_}_${offset}_$days.xml";
    my $cmd;
    if (-s $output) {
	print "nonempty $output already there, not rerunning $exe\n";
    }
    elsif (not $opt_list_channels) {
      TEST_CONFIG_EXISTS:
	if (not -f $config) {
	    my $config_cmd = "$exe_with_path --cache --config-file $config --configure";
	    warn "$config does not exist\n";
	    warn("you should run: $config_cmd\n"), next if not $opt_configure;
	    if (run $config_cmd) {
		warn "$config_cmd failed: $?, $!\n";
		next;
	    }
	    # Otherwise, try again to see if config exists.
	    goto TEST_CONFIG_EXISTS;
	}

	$cmd = "$exe_with_path --cache --config-file $config --offset $offset --days $days ";
    }
    else {
	$cmd = "$exe_with_path --cache --list-channels ";
    }

    if (defined $cmd) {
	if (run "$cmd > $output 2>$exe.log") {
	    warn "$cmd failed: $?, $!";
	    next;
	}

	# Run the same command again to see that --output and --quiet works.
	my $cmd2 = "$cmd --output ${output}2 2>$exe.log2";
	my $cmd3 = "$cmd --quiet > ${output}3 2>$exe.log3";
	my $cmd4 = "$cmd --quiet --output ${output}4 2>$exe.log4";

	if (run $cmd2) {
	    warn "$cmd2 failed: $?, $!";
	    next;
	}

	if (run $cmd3 ) {
	    warn "$cmd3 failed: $?, $!";
	    next;
	}

	if (run $cmd4 ) {
	    warn "$cmd4 failed: $?, $!";
	    next;
	}
        
	# Check that the grabber was quiet when it should have been.
	if( -s "$exe.log3" )
	{
	    warn( "$cmd3 produced output to STDERR when it shouldn't have:" );
	    next;
	}

	if( -s "$exe.log4" )
	{
	    warn( "$cmd4 produced output to STDERR when it shouldn't have:" );
	    next;
        }

	if( ! compare_files( $output, "${output}2" ) )
	{
	    warn "$output and ${output}2 differ.";
	    next;
	}

	if( ! compare_files( $output, "${output}3" ) )
	{
	    warn "$output and ${output}3 differ.";
	    next;
	}

	if( ! compare_files( $output, "${output}4" ) )
	{
	    warn "$output and ${output}4 differ.";
	    next;
	}

	# The output files were all equal. Remove all but one of them.
	unlink( "${output}2" );
	unlink( "${output}3" );
	unlink( "${output}4" );
    }

    # Okay, it ran, and we have the result in $output.  Validate.
    if (run "nsgmls -wxml -s $output") {
	warn "$output not valid XML\n";
	next;
    }
    print "$output validates ok\n";

    # Run through tv_cat, which makes sure the data looks like XMLTV,
    # but also lets us compare before and after to check whitespace
    # etc.
    #
    if (run "tv_cat $output >$output.catted") {
	warn "$output makes tv_cat choke, so probably has semantic errors\n";
	next;
    }
    if (run("diff -us $output $output.catted | head")) {
	die "diff failed: $?, $!";
    }

    unless ($opt_list_channels) {
	# Do tv_sort sanity checks.  One day it would be better to put
	# this stuff in a Perl library.
	#
	my $sort_errors = "$output.sort_errors";
	if (run "tv_sort $output >$output.sorted 2>$sort_errors") {
	    # This would indicate a bug in tv_sort.
	    warn "tv_sort failed on $output for some reason, see $sort_errors\n";
	    next;
	}
	print "$output looks like XMLTV\n";
	if (my @lines = read_file $sort_errors) {
	    warn "$output has funny start or stop times: some errors are:\n"
	      . join('', @lines[0 .. min(9, $#lines)]);
	    next;
	}
    }
}

# Compare two files. Return true if they have the same contents.
sub compare_files {
    my( $file1, $file2 ) = @_;

    run("diff $file1 $file2 > /dev/null");
    return $? ? 0 : 1;
}

# Run an external command. Exit if the command is interrupted with ctrl-c.
sub run {
    my( $cmd ) = @_;

    system( $cmd );
    
    if ($? == -1) {
	print STDERR "Failed to execute $cmd: $!\n";
	exit 1;
    }
    elsif ($? & 127) {
	print "Terminated by signal " . ($? & 127) . "\n";
	exit 1;
    }
    return $? >> 8;
}

