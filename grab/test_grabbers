#!/usr/bin/perl
#
# Run each of the grabbers in turn and do some checks on the output.
# This is a tool for xmltv developers to run only occasionally -
# because it does network fetches it can't be part of 'make test'!
# Run it giving the root of the xmltv source tree, after 'make'.
# It needs a test.conf file in each grabber directory.
#
# -- Ed Avis, ed@membled.com, 2005-08-20
#
use warnings;
use strict;
use Getopt::Long;
use File::Copy;
use File::Slurp;
use List::Util qw(min);
use File::chdir;
use File::Spec;
use XML::LibXML;
use FindBin;

sub run;
sub w;

# Run grabbers with these args.
my ($offset, $days) = (1, 2);

# How many seconds can a grabber take to download data
my $CMD_TIMEOUT = 600;

# Find the root directory.
my( $vol, $dir, $file ) = File::Spec->splitpath( $FindBin::Bin );
my( @dirs ) = File::Spec->splitdir( $dir );
pop @dirs;
my $root = File::Spec->catdir( @dirs );

our $opt_configure;     # try to --configure grabbers if necessary
our $opt_only;          # run just one grabber
our $opt_list_channels; # run with --list-channels
our $opt_validate_file; # validate that a file is valid xmltv data.
our $opt_help=0;

my $result = GetOptions('configure' => \$opt_configure,
			'only=s' => \$opt_only,
			'list-channels' => \$opt_list_channels,
			'validate-file=s' => \$opt_validate_file,
			'xmltv-root=s' => \$root,
			'help|h' => \$opt_help,
			);

if ( scalar( @ARGV ) != 0 or not $result or $opt_help )
{
    print << "EOH";
usage: $0 [options]
    
Valid options:
--only <grabber>  Only test the specified grabber.
--configure       Configure all/the selected grabber(s).
--list-channels   Test that the --list-channels option is supported.
--xmltv-root dir  Root directory for the xmltv distribution. Only necessary
                  if text_grabbers is moved outside of the xmltv distribution
                  directory.

--validate-file <filename> 
                  Test that the contents of a file is valid xmltv.

--help            Print this text.

EOH

   exit 1;
}

w "Using $root as xmltv distribution dir.";
 
my $dtd_in_root = "$root/xmltv.dtd";
if (not -e $dtd_in_root)
{
    print "$dtd_in_root does not exist.\n";
    print "Failed to find the xmltv distribution directory. Please use the\n";
    print "--xmltv-root parameter to specify it.\n";
    exit 1;
}

my $dtd_str = read_file($dtd_in_root);
my $dtd = XML::LibXML::Dtd->parse_string($dtd_str);

my $parser = XML::LibXML->new();
$parser->line_numbers(1);

if ( defined( $opt_validate_file ) )
{
    exit validate_file( $opt_validate_file );
}

my @grabbers;
{
    local $CWD = "$root/grab";
    if (defined $opt_only) {
	die "no such grabber $opt_only\n" if not -d $opt_only;
	@grabbers = ($opt_only);
    }
    else {
	@grabbers = grep { -d } <[a-z]*>;
    }
}

foreach (@grabbers) {
    /^[a-z_]+$/ or die "bad grabber name $_";
    my $exe = "tv_grab_$_";
    if ( -f "$root/blib/script/$exe" )
    {
	w "Testing $exe";
    }
    else
    {
	w "No such grabber $exe.";
	next;
    }

    my $exe_with_path = "perl -I $root/blib/lib $root/blib/script/$exe";
    if (not run( "$exe_with_path --ahdmegkeja > /dev/null 2>&1" ))
    {
      w "$exe_with_path --ahdmegkeja did not fail. The grabber seems to "
	  . "accept any command-line parameter without returning an error.";
      next;
    }

    if (run( "$exe_with_path --version > /dev/null 2>&1" ))
    {
      w "$exe_with_path --version failed: $?, $!";
      next;
    }

    if (run( "$exe_with_path --capabilities > /dev/null 2>&1" ))
    {
      w "$exe_with_path --capabilities failed: $?, $!";
      next;
    }

    my $config = "$root/grab/$_/test.conf";

    my $output = $opt_list_channels ? "${_}_channels.xml" : "${_}_${offset}_$days.xml";
    my $cmd;
    if (-s $output) {
	print "nonempty $output already there, not rerunning $exe\n";
    }
    elsif (not $opt_list_channels) {
      TEST_CONFIG_EXISTS:
	if (not -f $config) {
	    my $config_cmd = "$exe_with_path --cache --config-file $config --configure";
	    warn "$config does not exist\n";
	    warn("you should run: $config_cmd\n"), next if not $opt_configure;
	    if (run $config_cmd) {
		warn "$config_cmd failed: $?, $!\n";
		next;
	    }
	    # Otherwise, try again to see if config exists.
	    goto TEST_CONFIG_EXISTS;
	}

	$cmd = "$exe_with_path --cache --config-file $config --offset $offset --days $days ";
    }
    else {
	$cmd = "$exe_with_path --cache --list-channels ";
    }

    if (defined $cmd) {
	if (run "$cmd > $output 2>$exe.log") {
	    w "$cmd failed: $?, $!";
	    next;
	}

	# Run the same command again to see that --output and --quiet works.
	my $cmd2 = "$cmd --output ${output}2 2>$exe.log2";
	my $cmd3 = "$cmd --quiet > ${output}3 2>$exe.log3";
	my $cmd4 = "$cmd --quiet --output ${output}4 2>$exe.log4";

	if (run $cmd2) {
	    w "$cmd2 failed: $?, $!";
	    next;
	}

	if (run $cmd3 ) {
	    w "$cmd3 failed: $?, $!";
	    next;
	}

	if (run $cmd4 ) {
	    w "$cmd4 failed: $?, $!";
	    next;
	}
        
	# Check that the grabber was quiet when it should have been.
	if ( -s "$exe.log3" )
	{
	    w "$cmd3 produced output to STDERR when it shouldn't have. " 
		. "See $exe.log3";
	}
	else
	{
	    unlink( "$exe.log3" );
	}

	if ( -s "$exe.log4" )
	{
	    w "$cmd4 produced output to STDERR when it shouldn't have. " 
		. "See $exe.log4";
        }
	else
	{
	    unlink( "$exe.log4" );
	}

	if ( ! compare_files( $output, "${output}2" ) )
	{
	    w "$output and ${output}2 differ.";
	    next;
	}

	if ( ! compare_files( $output, "${output}3" ) )
	{
	    w "$output and ${output}3 differ.";
	    next;
	}

	if ( ! compare_files( $output, "${output}4" ) )
	{
	    w "$output and ${output}4 differ.";
	    next;
	}

	# The output files were all equal. Remove all but one of them.
	unlink( "${output}2" );
	unlink( "${output}3" );
	unlink( "${output}4" );
    }

    # Okay, it ran, and we have the result in $output.  Validate.
    if (validate_file( $output )) {
	w "Errors found in $output";
	next;
    }
    w "$output validates ok";

    # Run through tv_cat, which makes sure the data looks like XMLTV,
    # but also lets us compare before and after to check whitespace
    # etc.
    #
    if (run "tv_cat $output >$output.catted") {
	w "$output makes tv_cat choke, so probably has semantic errors";
	next;
    }
    if (run("diff -us $output $output.catted | head")) {
	die "diff failed: $?, $!";
    }

    unless ($opt_list_channels) {
	# Do tv_sort sanity checks.  One day it would be better to put
	# this stuff in a Perl library.
	#
	my $sort_errors = "$output.sort_errors";
	if (run "tv_sort $output >$output.sorted 2>$sort_errors") {
	    # This would indicate a bug in tv_sort.
	    w "tv_sort failed on $output for some reason, see $sort_errors";
	    next;
	}
	print "$output looks like XMLTV\n";
	if (my @lines = read_file $sort_errors) {
	    w "$output has funny start or stop times: some errors are:\n"
	      . join('', @lines[0 .. min(9, $#lines)]);
	    next;
	}
    }
}

# Compare two files. Return true if they have the same contents.
sub compare_files {
    my( $file1, $file2 ) = @_;

    run("diff $file1 $file2 > /dev/null");
    return $? ? 0 : 1;
}

# Run an external command. Exit if the command is interrupted with ctrl-c.
sub run {
    my( $cmd ) = @_;

#    print "Running $cmd\n";

    my $killed = 0;

    # Set a timer and run the real du.
    eval {
	local $SIG{ALRM} =
            sub {
		# ignore SIGHUP here so the kill only affects children.
		local $SIG{HUP} = 'IGNORE';
		kill 1,(-$$);
		$killed = 1;
	    };
	alarm $CMD_TIMEOUT;
	system ( $cmd );
	alarm 0;
    };
    $SIG{HUP} = 'DEFAULT';    

    if( $killed )
    {
	w "Timeout";
	return 1;
    }

    if ($? == -1) {
	w "Failed to execute $cmd: $!";
	return 1;
    }
    elsif ($? & 127) {
	w "Terminated by signal " . ($? & 127);
	exit 1;
    }

    return $? >> 8;
}

sub validate_file
{
    my( $file ) = @_;
    my $errors = 0;
    
    my $doc;
    
    eval { $doc = $parser->parse_file( $file ); };
    
    if ( $@ )
    {
	w "The file is not well-formed xml:\n$@ ";
	return 1;
    }
    
    eval { $doc->validate( $dtd ) };  
    if ( $@ )
    {
	w "The file is not valid according to the xmltv dtd:\n $@";
	return 1;
    }

    my $w = sub 
    { 
	w "Line " . $_[0]->line_number() . " $_[1]";
	$errors++;
    };
    
    my %channels;
    
    my $ns = $doc->find( "//channel" );
    foreach my $ch ($ns->get_nodelist)
    {
	my $channelid = $ch->findvalue('@id');
	my $display_name = $ch->findvalue('display-name/text()');
	
	
	$w->( $ch, "Illegal channel-id $channelid" )
	    if $channelid !~ /^[-a-zA-Z0-9]+(\.[-a-zA-Z0-9]+)+$/;
	
	$w->( $ch, "Duplicate channel-tag for $channelid" )
	    if defined( $channels{$channelid} );
	
	$channels{$channelid} = $display_name;
    }
    
    $ns = $doc->find( "//programme" );
    
    foreach my $p ($ns->get_nodelist)
    {
	my $channelid = $p->findvalue('@channel');
	my $start = $p->findvalue('@start');
	my $stop = $p->findvalue('@stop');
	my $title = $p->findvalue('title/text()');
	my $desc = $p->findvalue('desc/text()');
		
	if ( not defined( $channels{$channelid} ))
	{
	    $w->( $p, "Channel $channelid does not have a <channel>-entry." );
	    $channels{$channelid} = "auto";
	    $errors++;
	}
	
	$w->( $p, "Empty title" )    
	    if $title =~ /^\s*$/;
	
	$w->( $p, "Illegal start-time $start" )
	    if not verify_time( $start );
	
	$w->( $p, "Illegal stop-time $stop" )
	    if $stop ne "" and not verify_time( $stop );
    }
    
    return $errors;
}

sub verify_time
{
    my( $time ) = @_;

    return $time =~ /^\d{12,14}(\s+([A-Z]+|[+-]\d{4}))$/;
}

sub w
{
    print "$_[0]\n";
}

