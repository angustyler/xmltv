#!/usr/bin/perl -w

=head1 NAME

tv_grab_uk_rt - Grab TV listings for the United Kingdom, from an
alternative source.

=head1 SYNOPSIS

tv_grab_uk_rt --help

tv_grab_uk_rt [--config-file FILE] --configure

tv_grab_uk_rt [--config-file FILE] [--output FILE] [--days N]
              [--offset N] [--quiet]

=head1 DESCRIPTION

Output TV and radio listings in XMLTV format for many stations
available in Britain.  The data comes from the Radio Times website.

=head1 WARNING

Running this grabber requires very many web page fetches (potentially
one per programme).  It is better where possible to run the ordinary
UK grabber B<tv_grab_uk>, which has its own specially-created data
source rather than scraping from a human-readable website.

Normally youE<39>d run this grabber instead of B<tv_grab_uk> only when
you want more than seven days of listings, or to get the more detailed
cast lists in the Radio Times data.

=head1 USAGE

First you must run B<tv_grab_uk_rt --configure> to choose which
stations you want to receive.  Then running B<tv_grab_uk_rt> with no
arguments will get about a fortnightE<39>s listings for the stations
you chose.

B<--configure> Prompt for which stations to download and write the
configuration file.

B<--config-file FILE> Set the name of the configuration file, the
default is B<~/.xmltv/tv_grab_uk_rt.conf>.  This is the file written by
B<--configure> and read when grabbing.

B<--output FILE> When grabbing, write output to FILE rather than
standard output.

B<--days N> When grabbing, grab N days rather than as many as
possible.

B<--offset N> Start grabbing at today + N.  N may be negative.

B<--quiet> suppress the progress messages normally written to standard
error.

=head1 SEE ALSO

L<xmltv(5)>, L<tv_grab_uk(1)>, L<http://www.radiotimes.beeb.com/>

=head1 AUTHOR

Ed Avis, ed@membled.com

=head1 BUGS

The website parsing isnE<39>t perfect and there will often be warning
messages about bits of HTML that arenE<39>t understood.  Some of the
details provided by the site have to be thrown away because they
cannot be accommodated in the XMLTV format; again, warning messages
are printed.

There are too many web page fetches, because a separate page gives
'details' for each programme.  It would be better to fetch the details
only for those programmes that are interesting, in some kind of
two-pass grabbing.

There is code to find out the 'categories' given for each programme,
but that involves even more page fetches so it is disabled at present.

=cut

use strict;
use IO::Socket;
use LWP::Simple;
use Date::Manip; Date_Init('TZ=UTC');
use Getopt::Long;
use XMLTV;
use XMLTV::Memoize;
use XMLTV::Ask;
use XMLTV::Europe_TZ;
use XMLTV::Config_file;
use XMLTV::Usage <<END
To configure: $0 --configure [--config-file FILE]
To grab listings: $0 [--config-file FILE] [--output FILE] [--days N]
         [--offset N] [--quiet]
END
  ;

# Use Log::TraceMessages if installed.
BEGIN {
    eval { require Log::TraceMessages };
    if ($@) {
	*t = sub {};
	*d = sub { '' };
    }
    else {
	*t = \&Log::TraceMessages::t;
	*d = \&Log::TraceMessages::d;
	Log::TraceMessages::check_argv();
    }
}

sub get_url( $ );
sub get_programmes( $$$$$ );
sub get_programme_details( $$$$$ );
sub do_cast( $$ );
sub rt_date( $$$ );
sub get_channels();
sub get_categories();
sub get_available_dates();
sub get_progs_in_cat( $$$ );
sub rt_to_xmltv( $ );
sub xmltv_to_rt( $ );
sub grab( @ );
sub configure();

# GLOBAL CONSTANTS
my $TIME_INTERVAL = 120;
my $LANG = 'en';
my $DOMAIN = 'radiotimes.beeb.com';
my $BASE_URL = "http://www.$DOMAIN";

# Whether to fetch categories (makes everything slower)
my $GET_CATEGORIES = 0;

# We try to strip away Javascript to just get URLs.  This is a list of
# known Javascript functions foo such that foo('url') can be changed
# to just url.  Other functions may be removed also, but you get a
# warning :-).
#
my %known_js = (exitpopup      => 1,
		refreshOpener  => 1,
		refreshOpener2 => 1,
	       );

# Check options.  First do the undocumented --cache option (to cache
# get(), which retrieves web pages), then the normal ones.
#
my $using_cache = XMLTV::Memoize::check_argv('get_url');
my ($opt_days,
    $opt_help,
    $opt_output,
    $opt_share,
    $opt_configure,
    $opt_config_file,
    $opt_offset,
    $opt_quiet,
   );
# No default for $opt_days, we determine it from the site.
$opt_offset = 0; # default today
$opt_quiet  = 0; # default
GetOptions('days=i'        => \$opt_days,
	   'help'          => \$opt_help,
	   'configure'     => \$opt_configure,
	   'config-file=s' => \$opt_config_file,
	   'output=s'      => \$opt_output,
	   'share=s'       => \$opt_share, # also undocumented
           'offset=i'      => \$opt_offset,
	   'quiet'         => \$opt_quiet,
	  )
  or usage(0);
die 'number of days must not be negative'
  if (defined $opt_days && $opt_days < 0);
if ($opt_help) {
    usage(1);
}

# share/ directory for storing channel mapping files.  This next line
# is altered by processing through tv_grab_uk.PL.  But we can use the
# current directory instead of share/tv_grab_uk for development.
#
# The 'source' file tv_grab_uk.in has $SHARE_DIR undef, which means
# use the current directory.  In any case the directory can be
# overridden with the --share option (useful for testing).
#
my $SHARE_DIR = undef;
$SHARE_DIR = $opt_share if defined $opt_share;
my $OUR_SHARE_DIR = (defined $SHARE_DIR) ? "$SHARE_DIR/tv_grab_uk_rt" : '.';
(my $CHANNEL_NAMES_FILE = "$OUR_SHARE_DIR/channel_ids") =~ tr!/!/!s;

# Tables to convert between Radio Times and XMLTV ids of channels.
# The way to access these is through the routines rt_to_xmltv() and
# xmltv_to_rt(), not directly.  Those will deal sensibly with a new RT
# channel that isn't mentioned in the file.
#
my (%rt_to_xmltv, %xmltv_to_rt, %extra_dn);
open(FH, $CHANNEL_NAMES_FILE) or die "cannot open $CHANNEL_NAMES_FILE: $!";
while (<FH>) {
    s/\#.*//; s/^\s+//; s/\s+$//;
    next unless length;
    my @fields = split /:/;
    die "$CHANNEL_NAMES_FILE:$.: wrong number of fields"
      if @fields < 2 or @fields > 3;

    my ($xmltv_id, $rt_id, $extra_dn) = @fields;
    warn "$CHANNEL_NAMES_FILE:$.:RT id $rt_id seen already\n"
      if defined $rt_to_xmltv{$rt_id};
    $rt_to_xmltv{$rt_id} = $xmltv_id;
    warn "$CHANNEL_NAMES_FILE:$.:XMLTV id $xmltv_id seen already\n"
      if defined $xmltv_to_rt{$xmltv_id};
    $xmltv_to_rt{$xmltv_id} = $rt_id;

    $extra_dn{$xmltv_id} = $extra_dn if defined $extra_dn;
}
close FH or warn "cannot close $CHANNEL_NAMES_FILE: $!";

die if defined $opt_output; # TODO

# File that stores which channels to download.
my $config_file
  = XMLTV::Config_file::filename($opt_config_file, 'tv_grab_uk_rt');

if (not $opt_configure) {
    if (-e $config_file) {
	print STDERR "using config file $config_file\n"
	  unless $opt_quiet;
    }
    else {
	die "config file $config_file does not exist, run me with --configure\n";
    }
}

if ($opt_configure) {
    configure();
}
else {
    my %g_args = ();
    if (defined $opt_output) {
	my $fh = new IO::File ">$opt_output";
	die "cannot write to $opt_output\n" if not $fh;
	%g_args = (OUTPUT => $fh);
    }
    grab(%g_args);
}
exit();

# Grab listings and write them in XML.  Arguments are to be passed to
# XMLTV::Writer (but encoding is always ISO-8859-1).
#
sub grab( @ ) {
    my $writer = new XMLTV::Writer(@_, encoding => 'ISO-8859-1');
    my %write_channels;		# to be written as <channel> elements

    print STDERR "finding channels:\t" unless $opt_quiet;
    my %channels = get_channels();
    print STDERR "done.\n" unless $opt_quiet;

    # Read the configuration file.  At present the lines must be one
    # of two forms:
    #
    # channel <xmltv id>
    # ALL
    #
    open(CONF, $config_file)
      or die "cannot read $config_file: $!\n";
    while (<CONF>) {
	s/\#.*//; s/^\s+//; s/\s+$//;
	next if not length;
	t "got line from config file: $_";
	if ($_ eq 'ALL') {
	    %write_channels = %channels;
	}
	elsif (/^channel\s+(.+)/) {
	    my $xmltv_id = $1;
	    if (not defined $channels{$xmltv_id}) {
		warn "$config_file:$.: no channel with XMLTV id $xmltv_id, skipping\n";
		next;
	    }
	    $write_channels{$xmltv_id} = $channels{$xmltv_id};
	}
	else { die "$config_file:$.: bad line\n" }
    }

    print STDERR "getting dates for which listings available:\t"
      unless $opt_quiet;
    my @available_dates = get_available_dates();
    t 'available dates: ' . d \@available_dates;
    die 'apparently, there are no days of listings on the site'
      if not @available_dates;
    print STDERR "done.\n" unless $opt_quiet;

    my $today = DateCalc(ParseDate('today midnight'), "$opt_offset days");

    my $is_available = sub( $ ) {
	my $d = shift;
	foreach (@available_dates) {
	    return 1 if not Date_Cmp($d, $_);
	}
	return 0;
    };

    my @dates_to_get;
    for (my $d = $today; $is_available->($d); $d = DateCalc($d, '+ 1 day')) {
	push @dates_to_get, $d;
    }
    die "listings for today ($today) not available" if not @dates_to_get;
    my $last_day = $dates_to_get[-1];
    foreach (@available_dates) {
	if (Date_Cmp($last_day, $_) < 0) {
	    warn "strangely, day $_ is available but there are gaps before it";
	}
    }

    if (defined $opt_days) {
	if ($opt_days > @dates_to_get) {
	    warn 'only ' . (scalar @dates_to_get)
	      . ' days of consecutive listings available';
	}
	else {
	    @dates_to_get = @dates_to_get[0 .. $opt_days - 1];
	}
    }
    my $days = @dates_to_get > 1 ? 'days' : 'day';
    print STDERR 'getting ' . (scalar @dates_to_get) . " $days of listings\n"
      unless $opt_quiet;
    t 'getting dates:' . d \@dates_to_get;

    $writer->start({ 'source-info-url'     => "$BASE_URL/",
		     'source-info-name'    => 'Radio Times',
		     'generator-info-name' => 'XMLTV',
		     'generator-info-url'  =>
		     'http://membled.com/work/apps/xmltv/',
		   });


    my %categories;
    if ($GET_CATEGORIES) {
	# Find all the categories
	print STDERR "finding categories:\t" unless $opt_quiet;
	%categories = get_categories();
	print STDERR "done.\n" unless $opt_quiet;
    }

    # Find all the programes on the channels
    my %prog_to_cat;

    # get the listings for each date
    my @programmes;
    foreach my $date (@dates_to_get) {
	# Create the time string according to the TIME_INTERVAL
	my $mns = 0;
	while ($mns < 24 * 60) {
	    my $time = DateCalc($date, "+ $mns minutes");
	    $mns += $TIME_INTERVAL;

	    # first find all the new programmes for this time slot
	    my @new_programmes;

	    foreach my $chan (sort keys %write_channels) {
		# Assume the user's preferred language is the same as
		# the RT site... this language-selection charade is a
		# bit pointless I admit.
		#
		my $dn = $write_channels{$chan}->{'display-name'};
		my $name = XMLTV::best_name([ $LANG ], $dn)->[0];
		$name = $chan if not defined $name;
		print STDERR 'time ', UnixDate($time, '%q'), ", channel $name:\t"
		  unless $opt_quiet;
		push @new_programmes,
		  get_programmes($chan, $time, \%prog_to_cat,
				 \%categories, \%channels);
		print STDERR "\n" unless $opt_quiet;
	    }

	    # Next find all the programes in each category (if there are new progs
	    # FIX ME we dont need to check all channels only those with new progs
	    # FIX ME we also need to check if there are more than 100 results and
	    # search over less channels
	    if (@new_programmes) {
		if ($GET_CATEGORIES) {
		    print STDERR "finding the categories at $time:\t"
		      unless $opt_quiet;
		    %prog_to_cat =
		      get_progs_in_cat([ sort keys %write_channels ], $time, \%categories);
		    print STDERR "done.\n" unless $opt_quiet;
		}
	    }

	    # Set the category for each new programme
	    foreach my $new_prog (@new_programmes) {
		my $channelId = $new_prog->{_chanID};
		my $programmeId = $new_prog->{_progID};
		if ($GET_CATEGORIES) {
		    my $cat_ID = $prog_to_cat{"$channelId$programmeId"};
		    my $cat = $categories{$cat_ID};
		    if (defined $cat) {
			push @{$new_prog->{category}}, [ lc $cat ];
		    }
		    else {
			warn "unknown category id $cat\n";
		    }
		}
	    }

	    # push the new channels into the completlist
	    push (@programmes, @new_programmes);
	}
    }

    # write out the xml
    # write out the channels
    $writer->write_channels(\%write_channels);

    #write out the programmes
    foreach (@programmes) {
	foreach my $k (keys %$_) {
	    die "undef $_->{$k}" if not defined $_->{$k};
	}
	$writer->write_programme($_);
    }
    $writer->end();
}


# Function to get a url.  This also seems like a sensible place to do
# HTML-demoronizing.  I've removed the automatic retrying because it
# won't interact well with memozing LWP::get() and I'd prefer to be
# warned whenever a page fails to download.  Could add it back later.
#
sub get_url( $ ) {
    local $_ = get(shift);
    return undef if not defined;
    tr/\222\222\226/''-/;
    # There could be other illegal chars but I haven't seen them.
    return $_;
}


# Function to find all the programmes on a channel (at a given date +
# time).
#
# Parameters:
#   XMLTV id of channel
#   Date::Manip object giving date and time
#   prog_to_cat hash (see elsewhere for details)
#   categories hash
#   channels hash
#
# Returns: list of programmes
#
# I think this relies on the page returning exactly $TIME_INTERVAL
# worth of listings.
#
my %seen_prog;
sub get_programmes( $$$$$ ) {
    my $channel_xid = shift;
    my $time = shift;
    my $prog_to_cat = shift;
    my $categories = shift;
    my $channels = shift;

    my @p;

    my $url = "$BASE_URL/ListingsServlet?event=4&";
    $url .= 'jspGridLocation=%2Fjsp%2Ftv_listings_grid.jsp&';
    $url .= 'jspListLocation=%2Fjsp%2Ftv_listings_single.jsp&';
    $url .= 'jspError=%2Fjsp%2Ferror.jsp&';
    $url .= 'searchDate=' . UnixDate($time, '%d/%m/%Y') . '&';
    $url .= 'searchTime=' . UnixDate($time, '%R') . '&';
    $url .= 'channels=' . xmltv_to_rt($channel_xid);

    # FIXME commonize this
    local $SIG{__WARN__} = sub {
	warn "$url: $_[0]";
    };
    local $SIG{__DIE__} = sub {
	die "$url: $_[0]";
    };
    
    my $data = get_url($url);
    if (not defined $data) {
	warn "could not get $url\n";
	my $from_time = UnixDate($time, '%Q');
	my $to_time = UnixDate(DateCalc($time, "+ $TIME_INTERVAL seconds"), '%Q');
	warn "not fetching any programmes for channel $channel_xid "
	  . "between $from_time and $to_time\n";
	return ();
    }
    $data =~ tr/\n//d;
    print STDERR '#' unless $opt_quiet;

    my @results = ($data =~ /<!-- start of a result -->.*?<!-- end of a result -->/ig);
    if (not @results) {	
	if ($data =~ /There are no programmes available/) {
	    # Assume that this is because nothing is showing on that
	    # channel, not because the site is missing some data.
	    #
	}
	else {
	    warn "$url: no results found in HTML\n";
	}
	return ();
    }

    foreach (@results) {
	m/programmeId=([0-9]+)/ or die "$url: cannot find programmeId= in $_";
	my $programmeId = $1;

	unless ($seen_prog{$channel_xid}->{$programmeId}++) {
	    my $progs = get_programme_details($channel_xid, $programmeId,
					      $prog_to_cat, $categories,
					      $channels);
	    if (not $progs) {
		warn "$url: could not get programme $programmeId on channel $channel_xid\n";
	    }
	    elsif (not @$progs) {
		warn "$url: strange, $programmeId on channel $channel_xid seems to be empty";
	    }
	    else {
		push @p, @$progs;
	    }
	}
	print STDERR '#' unless $opt_quiet;
    }
    return @p;
}

# Function to parse the HTML and get all the info we need
#
# Parameters:
#   XMLTV id of channel
#   RT id of programme
#   hash mapping 'channelidprogrammeid' to RT category id
#   hash of categories
#   hash of channels
#
# Returns a listref of programmes: normally with just one element, but
# can be more when two programmes share a timeslot.  (The clumpidxes
# will be set.)
#
my %warned_ch_mismatch; # eliminate duplicate warnings
sub get_programme_details( $$$$$ ) {
#    local $Log::TraceMessages::On = 1;
    my $channel_xid = shift;
    my $channelId = xmltv_to_rt($channel_xid);
    my $programmeId = shift;
    use vars '%prog_to_cat'; local *prog_to_cat = shift;
    use vars '%categories'; local *categories = shift;
    use vars '%channels'; local *channels = shift;

    # %p is the main programme we will return.
    my %p;
    $p{channel} = $channel_xid;
    $p{_chanID} = $channelId;
    $p{_progID} = $programmeId;

    # @followons are small extra programmes sharing its slot.  Things
    # like news bulletins which come in the middle of a film are also
    # counted as 'after' it, for simplicity.
    #
    my @followons;

    if ($GET_CATEGORIES) {
	my $cat_ID = $prog_to_cat{"$channelId$programmeId"};
	my $cat = $categories{$cat_ID};
	push @{$p{category}}, [ lc $cat ];
    }

    my $url = "$BASE_URL/ListingsServlet?event=10&";
    $url .= "channelId=$channelId&";
    $url .= "programmeId=$programmeId&";
    $url .= 'jspLocation=/jsp/prog_details.jsp';
    my $prog_details_string = get_url($url);
    if (not defined $prog_details_string) {
	warn "cannot get $url\n";
	return undef;
    }

    $prog_details_string  =~ tr/\r//d;
    if (not $prog_details_string  =~ m{</script>\s*(<table .*?)<!-- end main table -->}s) {
	warn "cannot find main table in content of $url, skipping\n";
	return undef;
    }
    my $prog_details = $1;

    for ($prog_details) {
	my $C = '<!-- -->'; # used to stop strings running together

	# Remove scripting.
	s{<script>[^<]*</script>}{$C}g;
	
 	# Turn hyperlinks with only 'alt' text into ones with content.
 	s!<a href="(.+?)"[^>]*alt="(.+?)"[^>]*></a>!<a href="$1">$2</a>!g;

 	# Remove hyperlinks within the RT site (keep only external
 	# ones).  Hmm, sometimes Related Features might be relative
 	# links, and we might want to keep those.  Hasn't happened so
 	# far though.
 	#
 	s{<a href="\W.+?"[^>]*>([^<]*)</a>}{$C$1$C}g;

 	# Replace <a> elements with just the URL and link text.
 	s{<a href="(.+?)"[^>]*>([^<]*)</a>}{$C$1$C$2$C}g;
 	t 'after href munging: ' . d $_;

	# Now we're ready to strip all markup.  We use pipe characters
	# as a delimiter between bits of text.  So first, check there
	# aren't any in there already.
	#
	tr/|//d;
	
	# Replace comments and HTML tags with pipes.
	s/<!--.*?-->/\|/g;
	s/<[ ]*[^0-9][^>]*?>/\|/g;
	
	# Tidy up the pipes and whitespace.  Hey, ASCII art!
	s/&nbsp;/ /g;
        s/\s+/ /g;
	s/\s+\|/\|/g;
	s/\|\s+/\|/g;
	tr/|/|/s;
	s/^\|//;
	s/\|$//;
	
#	local $Log::TraceMessages::On = 1;
	t 'after barification: ' . d $_;
    }

    my @bits = split /\|/, $prog_details;
    if (not @bits) {
        warn 'no programme details found in HTML';
        return undef;
    }

    my $title = shift @bits;
    my $sub_title;
    if (@bits and $bits[0] ne 'Channel:') {
	$sub_title = shift @bits;
    }

    # The title might give us a hint about the timezone, or we might
    # have to guess.
    #
    my $tz;
    if ($title =~ s/^\((UTC|GMT|BST)\)\s*//) {
	$tz = $1;
    }

    $p{title} = [ [ $title, $LANG ] ];

    my ($channel_name, $date, $times, $cert, $sub_title_1, $desc,
	$director, $filmed_in, $cast);
    # Map heading to [ where to put it, multiplicity ].
    my %fields = (Channel       => [ \$channel_name, '1' ],
		  Date          => [ \$date,         '1' ],
		  Time          => [ \$times,        '1' ],
		  Certificate   => [ \$cert,         '?' ],
		  Episode       => [ \$sub_title_1,  '?' ],
		  Review        => [ \$desc,         '?' ], # hmm
		  'Directed by' => [ \$director,     '?' ],
		  'Filmed in'   => [ \$filmed_in,    '?' ],
		 );
    FIELD: foreach my $f (sort keys %fields) {
	  my ($var, $mult) = @{$fields{$f}};
	  for (my $i = 0; $i < @bits; $i++) {
	      die if not defined $bits[$i];
	      if ($bits[$i] =~ /^$f:? *$/) {
		  my $val = $bits[$i + 1];
		  if (not defined $val) {
		      warn "found $f: but nothing after it";
		      return undef;
		  }
		  $$var = $val;
		  splice @bits, $i, 2;
		  next FIELD;
	      }
	  }

	  if ($mult eq '1') {
	      # Mandatory item, and we didn't find it.
	      warn "could not find $f: in programme details";
	      return undef;
	  }
	  elsif ($mult eq '?') {
	      # No worry.
	  }
	  else {
	      die "bad multiplicity specifier $mult";
	  }
      }

    # Check the channel name found matches the channel we thought.
    my $ch = $channels{$channel_xid};
    die "no channel data for $channel_xid" if not defined $ch;
    my $dn = $ch->{'display-name'}->[0]->[0];
    die "no display name for $channel_xid" if not defined $dn;
    if ($dn ne $channel_name) {
	warn "channel name '$channel_name' for programme doesn't match $dn"
	  unless $warned_ch_mismatch{$channel_name}{$dn}++;
    }

    my ($start, $start_tz);
    my ($stop, $stop_tz);
    if ($times =~ /^(.*) to (.*)$/) {
	my $pair;
	t "start time $1, calling rt_date()";
	if (not defined ($pair = rt_date($date, $1, $tz))) {
	    warn "cannot parse date $date with start time $1";
	    return undef;
	}
	($start, $start_tz) = @$pair;
	t "got date $start with tz $start_tz";

	t "stop time $2, calling rt_date()";
	if (not defined ($pair = rt_date($date, $2, $tz))) {
	    warn "cannot parse date $date with start time $1";
	    return undef;
	}
	($stop, $stop_tz) = @$pair;
	t "got date $stop with tz $stop_tz";
    }
    else {
	warn "bad Time value $times";
	return undef;
    }
    # Some programmes have thir stop time on the next day.  (This test
    # may break when the timezones change.)
    #
    if (Date_Cmp($start, $stop) > 0) {
	$stop = DateCalc($stop, '+ 1 day');
	die if not defined $stop;
    }
    $p{start} = UnixDate($start, "%q $start_tz");
    $p{stop} = UnixDate($stop, "%q $stop_tz");

    if (defined $cert) {
	warn "already seen certificate" if defined $p{rating};
	for ($cert) {
	    if (not s/^\[(.+)\]$/$1/) {
		warn "bad certificate text: $_";
	    }
	    else {
		push @{$p{rating}}, [ $_, 'BBFC' ];
	    }
	}
    }

    if (not defined $sub_title and not defined $sub_title_1) {
	# No secondary title.
    }
    elsif (not defined $sub_title and defined $sub_title_1) {
	$p{'sub-title'} = [ [ $sub_title_1, $LANG ] ];
    }
    elsif (defined $sub_title and not defined $sub_title_1) {
	$p{'sub-title'} = [ [ $sub_title, $LANG ] ];
    }
    elsif (defined $sub_title and defined $sub_title_1) {
	warn "two sub-titles: $sub_title, $sub_title_1";
	$p{'sub-title'} = [ [ $sub_title, $LANG ],
			    [ $sub_title_1, $LANG ] ];
    }
    else { die }

    if (defined $desc) {
	$p{'desc'} = [ [ $desc, $LANG ] ];
    }
    if (defined $director) {
	push @{$p{credits}{director}}, $director;
    }
    if (defined $filmed_in) {
	warn "already seen filmed-in date" if defined $p{date};
	if ($filmed_in !~ /^\d+$/) {
	    warn "bad filmed-in value '$filmed_in'\n";
	}
	else {
	    $p{date} = $filmed_in;
	}
    }

    if (defined $cast) {
	if ($cast =~ /(?:\.){5}/) {
	    # The style giving part.....actor.  There used to be code
	    # for this, but it seems the website has stopped producing
	    # it.
	    #
	    warn "discarding cast $cast";
	}
	else {
	    $p{credits}->{actor} = [ split /,\s*/, $cast ];
	}
    }

    my ($options,$subtitles,$widescreen,$repeat,$black_and_white,
	$episode,$review);
  BIT: while (@bits) {
	my $bit = shift @bits;
	if ($bit eq 'Cast List') {
	    # Some of the following bits are a cast list.
	    t 'calling do_cast()';
	    do_cast(\%p, \@bits);
	    t 'after do_cast(), remaining bits: ' . d \@bits;
	}
	elsif ($bit eq 'Related Websites' or $bit eq 'Related Features') {
	    t 'calling do_link()';
	    do_link(\%p, \@bits);
	    t 'after do_link(), remaining bits: ' . d \@bits;
	}
	elsif ($bit =~ /^javascript:/) {
	    t 'javascript: link with no preceding text, pushing back';
	    t 'calling do_link()';
	    unshift @bits, $bit;
	    do_link(\%p, \@bits);
	    t 'after do_link(), remaining bits: ' . d \@bits;
	}
	elsif ($bit eq 'Add to my diary') {
	    my $url = shift @bits;
	    if (not defined $url) {
		warn "strange, no URL in 'Add to my diary'";
	    }
	    elsif ($url !~ /^javascript:/) {
		warn "strange, add to diary URL not javascript";
	    }
	}
	else {
	    t "unknown bit $bit, try do_misc()";
	    push @followons, do_misc(\%p, $bit);
	}
    }

    foreach (keys %p) {
	die "undef $_" if not defined $p{$_};
    }

    if (@followons) {
	my $num = 1 + @followons;
	my $i = 0;
	foreach (\%p, @followons) {
	    $_->{clumpidx} = "$i/$num";
	    ++ $i;
	}
    }
    return [ \%p, @followons ];
}
# Process a single bit, probably containing flags like 'Repeat'.
# Warns about unknown stuff.
#
# Parameters:
#   programme (will be modified)
#   bit of text (will be modified)
#
# Also returns any follow-on programmes which are found.
#
my $warned_discarding_deaf_signed;
sub do_misc( $$ ) {
    use vars '%p'; local *p = shift;
    local $_ = shift;
    my @r;
    while (length) {
	if (s/^Subtitled,?\s*//) {
	    warn 'seen subtitling twice' if defined $p{subtitles};
	    $p{subtitles} = [ { type => 'teletext' } ];
	}
	elsif (s/^Widescreen,?\s*//) {
	    warn 'seen widescreen twice' if defined $p{_widescreen};
	    # FIXME I think this can be handled under <video>.
	    $p{_widescreen} = 'yes';
	}
	elsif (s/^Repeat,?\s*//) {
	    warn 'seen repeat twice' if defined $p{'previously-shown'};
	    $p{'previously-shown'} = {};
	}
	elsif (s/^(Black (?:and|&) White),?\s*//) {
	    warn 'seen black-and-white twice' if defined $p{video}{colour};
	    warn "assuming $1 is 'Black and White'\n";
	    $p{video}{present} = 1;
	    $p{video}{colour} = 0;
	}
	elsif (s/^(?:Followed by|Including) ([^,]+),?\s*//) {
	    push @r, { channel => $p{channel},
		       title   => [ [ $1, $LANG ] ],
		       start   => $p{start},
		       stop    => $p{stop},
		     };
	    # The caller must add the clumpidx later.
	}
	elsif (s/^Deaf Signed,?\s*//) {
	    warn "discarding deaf-signed information\n"
	      unless $warned_discarding_deaf_signed++;
	}
	elsif (s/^TV Movie,?\s*//) {
	    push @{$p{category}}, [ 'TV movie', 'en' ];
	}
	else {
	    warn "unknown remnant bit $_";
	    last;
	}
    }
    return @r;
}
# Process a list of bits and store them in the {credits} part of a
# programme hash.
#
# Parameters:
#   (ref to) programme hash to modify,
#   (ref to) list of 'bits' of text, also modified
#
# This routine removes elements from the front of the list, as much as
# looks like a cast list.
#
my $warned_discarding_parts;
sub do_cast( $$ ) {
    my $prog = shift;
    use vars '@bits'; local *bits = shift;
    t 'got cast list bits: ' . d \@bits;

    # Magic string that the site uses between part name and actor.
    my $DOTS = '.....';

    my $has_dots = 0;
    foreach (@bits) {
	if ($_ eq $DOTS) {
	    $has_dots = 1;
	    last;
	}
    }

    if ($has_dots) {
	# Gives the name of the part and of the actor.
	my (@parts, @actors);
      PART: while (@bits) {
	    for (shift @bits) {
		if ($_ eq $DOTS) {
		    unshift @bits, $_;
		    last PART;
		}
		elsif (/\w/) {
		    push @parts, $_;
		}
		else {
		    warn "bad part name $_";
		    push @bits, $_; # just so it doesn't get lost
		    last PART;
		}
	    }
	}

	my $n = 0;
      DOTS: while (@bits) {
	    for (shift @bits) {
		if ($_ eq $DOTS) {
		    ++ $n;
		}
		else {
		    unshift @bits, $_;
		    last DOTS;
		}
	    }
	}
	if ($n != @parts) {
	    warn 'found ' . (scalar @parts) . " parts in cast list, but only $n dots";
	}

      ACTOR: while (@bits && $n--) {
	    for (shift @bits) {
		if (not defined) {
		    warn "not enough actors for all parts in cast list";
		    last ACTOR;
		}
		elsif (not /\w/) {
		    warn "bad actor name $_";
		    unshift @bits, $_;
		    last ACTOR;
		}
		else {
		    push @actors, $_;
		}
	    }
	}

	while (@parts) {
	    my $p = shift @parts;
	    my $a = shift @actors;
	    warn "discarding information about the parts played by each actor\n"
	      unless $warned_discarding_parts++;
	    push @{$prog->{credits}->{actor}}, $a;
	}
    }
    else {
	t 'just a list of actors';
	for (shift @bits) {
	    if (not defined) {
		warn "nothing in cast list";
		return;
	    }
	    else {
		while (length) {
		    if (s/^([^,]+),?\s*//) {
			push @{$prog->{credits}->{actor}}, $1;
		    }
		    else {
			warn "weird bit in comma-separated cast list: $_";
			last;
		    }
		}
	    }
	}
    }
}
# Process a hyperlink from the bits of text.  This means remove the
# first three bits.
#
# Parameters:
#   (ref to) programme hash to modify,
#   (ref to) list of 'bits' of text, also modified
#
my ($warned_discarding_link_text, $warned_discarding_link_description);
sub do_link( $$ ) {
    my $prog = shift;
    use vars '@bits'; local *bits = shift;
    t 'got link bits: ' . d \@bits;

    # Modify the list in-place.
    my $url       = shift @bits;
    my $link_text = shift @bits;
    my $desc      = shift @bits;
    t "link data: \$url=$url, \$link_text=$link_text, \$desc=$desc";

    if (not defined $url) {
	warn "strange, no URL after 'Related Websites'";
	return;
    }
    # Remove moronic use of Javascript.
    for ($url) {
	if (s/^javascript://) {
	    if (s/^(\w+)\('(.+?)'\);$/$2/) {
		warn "unknown Javascript function $1"
		  if not $known_js{$1}++;
	    }
	    else {
		warn "unknown Javascript statement $url";
	    }
	}
	else {
	    # I don't think this code will ever execute, alas.
	    warn "Hooray!  A non-Javascript link!\n";
	}
	# Not sure how spaces get in there, but they do.
	s/^\s+//; s/\s+$//;
	# (Could warn about all non-URL characters.)
    }
    push @{$prog->{url}}, $url;
    if (not defined $link_text) {
	warn "strange, no link text after 'Related Websites'";
    }
    else {
	# Damned if you do, and damned if you don't :-).
	warn "discarding link text, just storing URL\n"
	  unless $warned_discarding_link_text++;
    }
    if (not defined $desc) {
	warn "strange, no description after 'Related Websites'";
    }
    else {
	warn "discarding link description, just storing URL\n"
	  unless $warned_discarding_link_description++;
    }
    t 'finished doing link, remaining bits: ' . d \@bits;
    # And what if there was more than one related site?
}

# Parse a date from the RT site.  This involves guessing the timezone,
# unless we already know it.
#
# Parameters:
#   base day (string)
#   time (hh:mm)
#   timezone, or undef
#
# Returns ref to list of:
#   Date::Manip object
#   timezone of date (string)
#
# or returns undef if date parsing failed.
#
sub rt_date( $$$ ) {
    my ($date, $time, $tz) = @_;
    t 'rt_date() ENTRY';
    t '$date=' . d $date;
    t '$time=' . d $time;
    t '$tz=' . d $tz;

    my $parsed;
    if (not defined $tz) {
	t "time $time, must guess tz";
	$parsed = parse_eur_date("$date $time", 'UTC');
	t 'parse_eur_date() returned: ' . d $parsed;
    }
    else {
	t "time $time, known timezone $tz";
	$parsed = ParseDate("$date $time $tz");
	t 'ParseDate() returned: ' . d $parsed;
    }
    return undef if not defined $parsed;
    my $r = date_to_eur($parsed, 'UTC');
    t 'returning result of date_to_eur(), ' . d $r;
    return $r;
}

# Function which will locate all the available channels and return a hash
# with channelId as the key and a channel description.
#
sub get_channels() {
    my $data = get_url("$BASE_URL/");
    if (not defined $data) {
	die "could not get channels page $BASE_URL/, aborting\n";
    }
    $data =~ tr/\n\r/\n/ds;
    t 'got channels page: ' . d $data;
    $data =~ s/\n//g;
    $data =~ /<select name="channels"[^>]*?>(.*?)<\/select>/
      or die "cannot find channel string in HTML $data";
    my $channel_string = $1;
    t 'got string of channels: ' . d $channel_string;
    $channel_string =~ s/\s+/ /g;
    my @channels = ($channel_string =~ /<option value="[0-9]+" >[^<]*/ig);
    t 'channels in string: ' . d @channels;
    warn "no channels found in $channel_string" if not @channels;
    my %c;

    foreach (@channels) {
	t 'doing channel string: ' . d $_;
	m/"([0-9]*)"/ or die "cannot find numeric channel id in $_";
	my $channelId = $1;
	t 'got numeric id: ' . d $channelId;
	m/>(.*)/ or die "cannot find channel description in $_";
	my $channelDesc = $1;
	for ($channelDesc) {
	    s/^\s+//; s/\s+$//;
	}
	t 'got description: ' . d $channelDesc;
	my $chanID_to_output = rt_to_xmltv($channelId);
	t 'XMLTV id to use: ' . d $chanID_to_output;
	die if not defined $chanID_to_output;
	die if not defined $channelId;

	my @dns = ([ $channelDesc, $LANG ]);
	my $extra_dn = $extra_dn{$chanID_to_output};
	push @dns, [ $extra_dn ] if defined $extra_dn;
	my $ch = { 'display-name' => \@dns,
		   'id' => $chanID_to_output };
	t 'channel object: ' . d $ch;
	$c{$chanID_to_output} = $ch;
	t "added to channels hash under key $chanID_to_output";
    }

    t 'returning hash: ' . d \%c;
    return %c;
}

# Function which will locate all the available categories and return a hash
# with categoryId as the key and a category description
sub get_categories() {
    my $url = "$BASE_URL/jsp/listings_search.jsp";
    my $data = get_url($url);
    if (not defined $data) {
	warn "could not get categories page $url, not grabbing category data\n";
	return ();
    }
    $data =~ s/\n//g;
    $data =~ /<select name="genres"[^>]*?>(.*?)<\/select>/
      or die "cannot find category in HTML $data";
    my $category_string = $1;
    $category_string =~ s/\s+/ /g;
    my @categories =
      ($category_string =~ /<option value="[0-9]+">[^<]*/ig);
    warn "cannot find categories in $category_string" if not @categories;
    my %c;

    foreach (@categories) {
	m/"([0-9]*)"/
	  or die "cannot find number in category $_";
	my $categoryId = $1;
	m/>(.*)/
	  or die "cannot find description in category $_";
	my $categoryDesc = $1;
	my $cast;

	$c{$categoryId} = $categoryDesc;
    }

    return %c;
}

# Function which will locate all the available dates and return a list
# of Date::Manip objects, one for each day.
#
# (I was tempted to make this a hash (so you could say $available{$d}
# to see if a day exists) but string equality is a bit dirty for
# comparing two Date::Manip objects.  There needs to be a tied hash
# class which can use a specified equality operation.)
#
sub get_available_dates() {
    my @r;
    my $url = "$BASE_URL/jsp/listings_search.jsp";
    my $data = get_url($url);
    if (not defined $data) {
	die "could not get $url, so cannot find available dates, aborting\n";
    }

    $data =~ s/\n//g;
    $data =~ /<select name="searchDate"[^>]*?>(.*?)<\/select>/
      or die "cannot find searchDate string in HTML $data";
    local $_ = $1;
    s/&nbsp;/ /g;
    s/\s+/ /g;
    s/^\s*//;
    t 'date string: ' . d $_;
    while (length) {
	if (not s!<option value="(\d\d)/(\d\d)/(\d{4})" ?(?:selected)?>([^<]+)!!) {
	    warn "remnant junk in date string: $_";
	    return @r;
	}

	my $parsed_val = ParseDate("$3-$2-$1");
	die "cannot parse option value $1/$2/$3"
	  if not defined $parsed_val;

	# Paranoia, or 'use all the information'.
	my $parsed_text = ParseDate($4);
	if (defined $parsed_text) {
	    warn "dates '$1/$2/$3' and '$4' from same option differ"
	      if Date_Cmp($parsed_val, $parsed_text);
	}
	else {
	    warn "cannot parse option text $4";
	}

	push @r, $parsed_val;
    }
    return @r;
}


# Function which will locate all the programes in a category
# (at a given date and time)
# will return a hash with "chanIDProgID" as the key
#
# Parameters:
#   (reference to) list of XMLTV ids of channels to search
#   Date::Manip object giving date and time
#   (reference to) hash of categories
#
# I think this searches $TIME_INTERVAL time starting from the time
# given.
#
sub get_progs_in_cat( $$$ ) {
    my @channels_to_search = map { xmltv_to_rt($_) } @{shift()};
    my $time = shift;
    use vars '%categories'; local *categories = shift;

    my %cats;

    # For each category find all the programmes in that category
    foreach my $category (keys %categories) {
	my $url = "$BASE_URL/ListingsServlet?event=7&";
	$url .= 'jspGridLocation=%2Fjsp%2Ftv_listings_grid.jsp&';
	$url .= 'jspListLocation=%2Fjsp%2Ftv_listings_list.jsp&';
	$url .= 'jspError=%2Fjsp%2Ferror.jsp&';
	$url .= 'channels=' . join(',', @channels_to_search) . '&';
	$url .= "genres=$category&";
	$url .= 'searchDate=' . UnixDate($time, '%d/%m/%Y') . '&';
	$url .= 'searchTime=' . UnixDate($time, '%R');
	my $data = get_url($url);
	if (not defined $data) {
	    warn "could not get $url, so cannot get data on category $category\n";
	    next;
	}
	$data =~ s/\n//g;

	my @results = ($data =~ /<!-- start of a result -->.*?<!-- end of a result -->/ig);
	warn "cannot find results in $data" if not @results;

	foreach (@results) {
	    /channelId=([0-9]+)/
	      or die "cannot find channelId= in $_";
	    my $channelId = $1;

	    /programmeId=([0-9]+)/
	      or die "cannot find programmeId= in $_";
	    my $programmeId = $1;

	    $cats{"$channelId$programmeId"} = $category;
	}
    }
    return %cats;
}

sub rt_to_xmltv( $ ) {
    my $n = shift;
    if (not defined $rt_to_xmltv{$n}) {
	my $new = "$n.$DOMAIN";
	die "channel id $new already exists" if defined $xmltv_to_rt{$new};
	$rt_to_xmltv{$n} = $new;
	$xmltv_to_rt{$new} = $n;
    }
    return $rt_to_xmltv{$n};
}
sub xmltv_to_rt( $ ) {
    my $x = shift;
    for ($xmltv_to_rt{$x}) {
	die "no RT id known for $x" if not defined;
	return $_;
    }
}


# Ask the user which channels to download, and write $config_file.
#
# Uses global %channels hash.
#
# FIXME commonize the whole damn configure routine with tv_grab_uk!
#
sub configure() {
#    local $Log::TraceMessages::On = 1;

    print <<END
Warning: this grabber requires a large number of page fetches from a
human-readable website.  It is normally better to run tv_grab_uk,
which has its own data source.

END
  ;
    if (not askBooleanQuestion('Proceed with configuration?', 0)) {
	print "Exiting.\n";
	exit 0;
    }

    XMLTV::Config_file::check_no_overwrite($config_file);

    print STDERR "finding channels:\t";
    my %channels = get_channels();
    print STDERR "done.\n";

    # FIXME need to make directory
    open(CONF, ">$config_file") or die "cannot write to $config_file: $!";
    my %chose_ch;
    t 'channels: ' . d \%channels;

    # For now we just let the user pick among the 'standard' channels.
    for (;;) {
	print "Enter the name of a channel, or '.' to finish: ";
	my $in = <STDIN>;
	$in =~ s/^\s+//; $in =~ s/\s+$//;
	last if $in eq '.';

	# FIXME commonize this matching by display name.
	my @poss;
      CH: foreach my $k (sort keys %channels) {
	    my $ch = $channels{$k};
	    my $dns = $ch->{'display-name'};
	    unless ($dns and @$dns) {
		warn "channel with id $ch->{id} has no display name, so cannot be configured\n";
		next CH;
	    }
	    foreach (map { $_->[0] } @$dns) {
		if (/$in/i) {
		    push @poss, $ch;
		    next CH;
		}
	    }
	}

	# We only matched based on display names, so we can assume
	# that each possible channel has at least one.
	#
	if (@poss == 0) {
	    print "No channel matching that.\n";
	}
	elsif (@poss == 1) {
	    my $ch = $poss[0];
	    if (askBooleanQuestion('Add channel ' .
				   $ch->{'display-name'}->[0]->[0] . '?', 1)) {
		my $xmltv_id = $ch->{id};
		unless ($chose_ch{$xmltv_id}++) {
		    print CONF "channel $xmltv_id\n";
		}
	    }
	}
	elsif (1 <= @poss and @poss < 25) {
	    my %dn_to_ch;
	    foreach (@poss) {
		my $dn = $_->{'display-name'}->[0]->[0];
		warn "more than one channel called $dn"
		  if exists $dn_to_ch{$dn};
		$dn_to_ch{$dn} = $_;
	    }
	    my $none_option = 'None of the above are what I wanted';
	    die 'silly channel name' if exists $dn_to_ch{$none_option};
	    my $r = askQuestion('Which channel to add?',
				$poss[0]->{'display-name'}->[0]->[0],
				(sort keys %dn_to_ch), $none_option);
	    next if $r eq $none_option;
	    my $ch = $dn_to_ch{$r}; die if not defined $ch;
	    my $xmltv_id = $ch->{id};
	    unless ($chose_ch{$xmltv_id}++) {
		print CONF "channel $xmltv_id\n";
	    }
	}
	elsif (25 <= @poss) {
	    print "'$in' matches lots of channels, be more specific.\n";
	}
	else { die }
    }

    close CONF or warn "cannot close $config_file: $!";
    print "All done, run with no arguments to grab a fortnight's listings.\n";
    exit();
}
