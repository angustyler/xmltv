#!/usr/bin/perl
=pod

=head1 NAME

tv_grab_uk_rt - Grab TV listings for United Kingdom and Republic of Ireland

=head1 SYNOPSIS

tv_grab_uk_rt --help

tv_grab_uk_rt --configure [--config-file FILE]

tv_grab_uk_rt [--config-file FILE] [--output FILE] [--days N] [--offset N]
              [--gui OPTION] [--quiet]

tv_grab_uk_rt --list-channels

tv_grab_uk_rt --capabilities

tv_grab_uk_rt --version

=head1 DESCRIPTION

Output TV listings in XMLTV format for many stations available in the 
United Kingdom and Republic of Ireland.  The data comes from 
machine-readable files produced by the Radio Times website.

=head1 USAGE

First you must run B<tv_grab_uk_rt --configure> to choose which stations you
want to receive.  Then running B<tv_grab_uk_rt> with no arguments will get
about a fortnightE<39>s listings for the stations you chose.

B<--configure> Prompt for which stations to download and write the
configuration file.

B<--gui OPTION> Use this option to enable a graphical interface to be used.
OPTION may be 'Tk', or left blank for the best available choice.
Additional allowed values of OPTION are 'Term' for normal terminal output
(default) and 'TermNoProgressBar' to disable the use of Term::ProgressBar.

B<--config-file FILE> Set the name of the configuration file, the default is
B<~/.xmltv/tv_grab_uk_rt.conf>.  This is the file written by B<--configure> and
read when grabbing.

B<--output FILE> When grabbing, write output to FILE rather than standard
output.

B<--quiet> Suppress the progress messages normally written to standard error.

B<--days N> When grabbing, grab N days of data instead of all available.

B<--offset N> Start grabbing at today + N days.

B<--list-channels> Write output giving <channel> elements for every channel
available, but no programmes.

B<--capabilities> Show which capabilities the grabber supports. For more
information, see L<http://xmltv.org/wiki/xmltvcapabilities.html>

B<--version> Show the version of the grabber.

B<--help> Print a help message and exit.

Note that tv_grab_uk_rt always downloads data for all days and then filters
out the days specified with --days and --offset. It is therefore more
efficient to omit --days and --offset and use all the returned data.

=head1 SEE ALSO

L<xmltv(5)>, L<http://www.radiotimes.com/>

=head1 AUTHOR

Ed Avis, ed@membled.com

Nick Morrott, knowledgejunkie@gmail.com (maintainer)

=cut

use warnings;
use strict;
use XMLTV::Version '$Id: tv_grab_uk_rt.in,v 1.120 2007/11/04 04:35:32 knowledgejunkie Exp $ ';
use XMLTV::Capabilities qw/baseline manualconfig cache preferredmethod/;
use XMLTV::Description 'United Kingdom/Republic of Ireland (Radio Times)';
use XMLTV::PreferredMethod qw/allatonce/;
use Getopt::Long;
use HTML::Entities;
use Date::Manip; Date_Init('TZ=+0000');
use XMLTV::Config_file;
use XMLTV::Get_nice;
use XMLTV::Ask;
use XMLTV::ProgressBar;
use XMLTV::Memoize; XMLTV::Memoize::check_argv 'get_nice';
use XMLTV::DST;
use XMLTV::Supplement qw/GetSupplement SetSupplementRoot/;
use XMLTV::Usage <<END
$0: Get TV listings for United Kingdom and Republic of Ireland in XMLTV format
To configure: $0 --configure [--config-file FILE]
To grab listings: $0 [--config-file FILE] [--output FILE] [--days N] [--offset N]
                     [--gui OPTION] [--quiet]
To list channels: $0 --list-channels
To show capabilities: $0 --capabilities
To show version: $0 --version
END
  ;
$XMLTV::Get_nice::Delay = 0; # since this is intended for grabbing

# Retrieve tv_grab_uk_rt channel_ids mapping
my $xmltv_channel_ids = GetSupplement( 'tv_grab_uk_rt', 'channel_ids' );

# Provide caching for the often-missing Radio Times channel index
SetSupplementRoot( 'http://xmltv.radiotimes.com' );
my $rt_channels_dat = GetSupplement( 'xmltv', 'channels.dat' );

sub configure();

# Use Log::TraceMessages if installed.
BEGIN {
    eval { require Log::TraceMessages };
    if ($@) {
	*t = sub {};
	*d = sub { '' };
    }
    else {
	*t = \&Log::TraceMessages::t;
	*d = \&Log::TraceMessages::d;
	Log::TraceMessages::check_argv();
    }
}

GetOptions('help'      => \ my $opt_help,
       'configure'     => \ my $opt_configure,
       'config-file=s' => \ my $opt_config_file,
       'gui:s'         => \ my $opt_gui,
       'output=s'      => \ my $opt_output,
       'share=s'       => \ my $opt_share, # also undocumented
       'quiet'         => \ my $opt_quiet,
       'list-channels' => \ my $opt_list_channels,
       'days=s'        => \ my $opt_days,
       'offset=s'      => \ my $opt_offset,
      )
  or usage(0);

if ($opt_help) {
    usage(1);
}

# Required for Tk
XMLTV::Ask::init($opt_gui);

# Stuff for the root <tv> element.
my %tv_credits = ( # 'source-info-url'     => "todo",
           'source-info-name'    => 'Radio Times',
           'generator-info-name' => 'XMLTV',
           'generator-info-url'  =>
           'http://xmltv.org/wiki/',
         );


# Tables to convert between Radio Times and XMLTV ids of channels.
# The way to access these is through the routines rt_to_xmltv() and
# xmltv_to_rt(), not directly.  Those will deal sensibly with a new RT
# channel that isn't mentioned in the file.
#
my @lines = split( /[\n\r]+/, $xmltv_channel_ids );
my (%rt_to_xmltv, %xmltv_to_rt, %extra_dn, %icon_urls);
foreach my $line (@lines) {
    next if $line =~ '^#';
    my @fields = split( /\|/, $line );
    # We need at least 2 fields (xmltv_id,rt_id) to run the grabber
    # No check on maximum number of fields to support future updates
    # to channel_ids now we are using XMLTV::Supplement
    die "Wrong number of fields in XMLTV channel_ids file. Please update XMLTV"
      if @fields < 2;

    # First 4 fields of channel_ids file are:
    # i) XMLTV ID ii) RT ID iii) Name of channel iv) Icon URL
    # The RT channels.dat provides a channel name - here we provide
    # an alternative or updated name if the channel name has changed
    my ($xmltv_id, $rt_id, $extra_dn, $icon_url) = @fields;

    if (not $opt_quiet) {
        warn "RT ID '$rt_id' already seen in XMLTV channel_ids file\n"
          if defined $rt_to_xmltv{$rt_id};
    }
    $rt_to_xmltv{$rt_id} = $xmltv_id;

    if (not $opt_quiet) {
        warn "XMLTV ID '$xmltv_id' already seen in XMLTV channel_ids file\n"
          if defined $xmltv_to_rt{$xmltv_id};
    }
    $xmltv_to_rt{$xmltv_id} = $rt_id;

    $extra_dn{$xmltv_id} = $extra_dn if defined $extra_dn;
    $icon_urls{$xmltv_id} = $icon_url if defined $icon_url;
}

# Keep output on STDERR preserving STDOUT for XML data
say( "\nAll data is the copyright of the Radio Times website
<http://www.radiotimes.com> and the use of this data
is restricted to personal use only.\n" ) if not $opt_quiet;

# Process the list of available channels from the RT site
my (%channels, %seen_rt_id, %seen_name);
my @rt_channels = split /\n/, $rt_channels_dat;
my $num_rt_channels = scalar @rt_channels;
say( "Radio Times reports available listings for $num_rt_channels channels.\n")
  if not $opt_quiet;

my $chans_bar = new XMLTV::ProgressBar({name   => 'Retrieving channels',
                                        count  => $num_rt_channels,
                                        ETA    => 'linear', })
                                          if not $opt_quiet;
my $need_final_update = 0;

foreach (@rt_channels) {
    chomp;
    /^(\d+)\|(.+)/ or die "Bad line seen in RT channels.dat: $_";
    my ($rt_id, $name) = ($1, $2);
    if ($seen_rt_id{$rt_id}++) {
        die "RT channel ID '$rt_id' already seen in RT channels.dat, aborting";
    }
    if ($seen_name{$name}++) {
        if (not $opt_quiet) {
            warn "RT channel '$name' already seen in RT channels.dat\n";
        }
    }
    
    my $xmltv_id = $rt_to_xmltv{$rt_id};
    
    # If the current RT channel has a known XMLTV ID, check it against known bad
    # channels and skip it if required. If the channel does not have an 
    # XMLTV ID, create one and continue.
    if (defined $xmltv_id) {
        # Skip any RT entries which have been flagged as bad in channel_ids file
        if ( $extra_dn{ $rt_to_xmltv{$rt_id} } =~ /.*Do\ Not\ Use.*/ ) {
    #        if (not $opt_quiet) {
    #            warn "RT channel '$name' ($rt_id) flagged as bad, skipping\n";
    #        }
            $need_final_update = 1;
            next;
        }
    } else {
        # Handle new channels on RT site unknown to channel_ids
        if (not $opt_quiet) {
            warn "RT channel '$name' ($rt_id) unknown in XMLTV channel_ids file\n";
        }
        $xmltv_id = "C$rt_id.radiotimes.com";
    }

    my @names = ([ $name ]);
    my $icon_url = $icon_urls{$xmltv_id};
    my @icon = { 'src' => $icon_url } if $icon_url;
    for ($extra_dn{$xmltv_id}) { push @names, [ $_ ] if defined }
    if (@icon) {
        $channels{$xmltv_id} = { id => $xmltv_id,
			         rt_id => $rt_id,
			         'display-name' => \@names,
			         'icon' => \@icon };
    } else {
        $channels{$xmltv_id} = { id => $xmltv_id,
			         rt_id => $rt_id,
			         'display-name' => \@names };
    }
    
    # Update the progres bar by one increment
    if (defined $chans_bar) {
        $chans_bar->update();
    }
}

if (defined $chans_bar) {
    # Only update the progress bar to 100% if we need to
    $chans_bar->update($num_rt_channels) if $need_final_update;
    $chans_bar->finish();
    say( "\n" ) if not $opt_quiet;
}

if (not $opt_quiet) {
    foreach (keys %xmltv_to_rt) {
        # ignore channels flagged as bad in channel_ids
        next if $extra_dn{$_} =~ /.*Do\ Not\ Use.*/;
        warn "XMLTV channel '$_' ($xmltv_to_rt{$_}) not seen on RT site\n"
          if not exists $channels{$_};
    }
}

my %g_args = ();
if (defined $opt_output) {
    my $fh = new IO::File ">$opt_output";
    die "Cannot write to $opt_output" if not $fh;
    #    binmode $fh or die "cannot set binmode for output: $!";
    %g_args = (OUTPUT => $fh);
}

if ($opt_list_channels) {
    die "--list-channels can't be given with --configure, exiting.\n"
      if $opt_configure;
    my $writer = new XMLTV::Writer(%g_args, encoding => 'ISO-8859-1');
    $writer->start(\%tv_credits);
    foreach (sort keys %channels) {
	delete $channels{$_}{rt_id};
	$writer->write_channel($channels{$_});
    }
    $writer->end;
    exit;
}

# File that stores which channels to download.
my $config_file
  = XMLTV::Config_file::filename($opt_config_file, 'tv_grab_uk_rt', $opt_quiet);

if ($opt_configure) {
    configure();
    exit;
}

# Ask the user which channels to download, and write $config_file.
#
# Uses global %channels hash.
#
# FIXME commonize with other grabbers.
#
sub configure() {
    #    local $Log::TraceMessages::On = 1;

    XMLTV::Config_file::check_no_overwrite($config_file);

    # FIXME need to make directory
    open(CONF, ">$config_file") or die "Cannot write to $config_file: $!";
    t 'channels: ' . d \%channels;

    my %chan_id_to_name;
    foreach my $chan_id (keys %channels) {
        $chan_id_to_name{$chan_id} =
            $channels{$chan_id}->{'display-name'}->[0]->[0];
    }

    my @chan_ids = sort {$chan_id_to_name{$a} cmp $chan_id_to_name{$b}}
        keys %chan_id_to_name;

    my @questions;
    foreach my $chan_id (@chan_ids) {
        push @questions, "Add channel ".$chan_id_to_name{$chan_id}."? ";
    }
    my @answers = ask_many_boolean(1, @questions);

    for (my $i=0; $i < $#chan_ids; $i++) {
        if ($answers[$i]) {
            print CONF "channel ".$chan_ids[$i]."\n";
        }
    }

    close CONF or warn "cannot close $config_file: $!";
    say("Finished configuration.");
    exit();
}

# Grabbing.  Start by reading config file.
my @wanted_chs;
my $n = 0;
foreach (XMLTV::Config_file::read_lines $config_file) {
    ++$n;
    next if not defined;
    /^\s*channel\s+(\S+)\s*$/ or die "$config_file: $n: bad line $_\n";
    my $id = $1;
    if (not exists $channels{$id}) {
        warn "XMLTV channel '$id' mentioned in $config_file but is not available on RT site\n"
          if not $opt_quiet;
        next;
    }
    push @wanted_chs, $id;
}
#@wanted_chs = sort keys %channels;

my %d_args = ();
if (defined( $opt_days ) or defined( $opt_offset )) {
  $opt_offset = 0 unless defined $opt_offset;
  $opt_days = 15 unless defined $opt_days;

  $d_args{offset} = $opt_offset;
  $d_args{days} = $opt_days;
  $d_args{cutoff} = "000000";
}

my $writer = new XMLTV::Writer(%g_args, %d_args, encoding => 'ISO-8859-1');
$writer->start(\%tv_credits);
foreach (@wanted_chs) {
    my %h = %{$channels{$_}};
    delete $h{rt_id};
    $writer->write_channel(\%h);
}

my $num_req_chans = scalar @wanted_chs;

say("Downloading listings for $num_req_chans configured channels\n")
  if not $opt_quiet;

my $listings_bar = new XMLTV::ProgressBar({name   => 'Retrieving listings',
                                           count  => $num_req_chans,
                                           ETA    => 'linear', })
                                             if not $opt_quiet;

my %warned_wrong_num_fields; # give that warning once per channel file

# Reset check for final progress bar update
$need_final_update = 0;

foreach my $ch (@wanted_chs) {
    my $c = $channels{$ch};
    my $rt_id = $channels{$ch}->{rt_id}; die if not defined $rt_id;

    # Try to get the base timezone for this channel from its name.
    my $base_tz;
    if ($c->{'display-name'}->[0]->[0] =~ /\((UTC|GMT|CET)\)\s*$/) {
	$base_tz = $1;
    }
    for ($base_tz) { $_ = 'UTC' if not defined }

    my $uri = "http://xmltv.radiotimes.com/xmltv/$rt_id.dat";
    local $SIG{__DIE__} = sub { die "$uri: $_[0]" };
    local $SIG{__WARN__} = sub { warn "$uri: $_[0]" };
    my $page = get_nice $uri;

    # Tidy up HTML entities and bad characters in the Radio Times data. The 
    # data frequently contains a mixture of valid and invalid Latin-1 characters
    # and we want our output to be valid Latin-1. HTML::Entities decides to use
    # Unicode so we have to fiddle a few entities manually first. We then
    # replace individual characters with their valid Latin-1 counterparts.
    #
    # See http://en.wikipedia.org/wiki/ISO/IEC_8859-1 for Latin-1 charmap
    #
    for ($page) {
        # Tidy up HTML entities
        s/&#8212;/--/g;  # the long dash
        s/&#8230;/.../g; # the ellipsis
        decode_entities $_;

        # Replace known bad single chars with good replacements:
        # unused->c-cedilla, unused->E-acute, unused->hyphen, unused->hyphen;
        tr/\x87\x89\x80\x94/\xE7\xC9\x2D\x2D/;
	
        # Remove Unicode null (U+0000) character
        s/\x{0000}//g;
	
        # Replace bad characters with suitable Latin-1 replacements. The
        # grabber includes debug output to highlight any unhandled characters.
        
        # Replace bad chars prefixed with A-grave (xC0)
        #
        # RT output seems to be using the A-grave+guillements chars in place
        # of many \xC0-\xFF characters so we cannot use a single replacement
        # and substitute the character with '?'
        s/\xC0\xBB\xC0\xBB/?/g; # doubled A-grave+>> -> ?

        # Replace bad chars prefixed with A-tilde (xC3)
        s/\xC3[\xC6\xE6]/'/g;   # -> '
        s/\xC3[\xF4\xF6]/"/g;   # -> "
        s/\xC3[\xF9\xFB]/-/g;   # -> -
        s/\xC3\xA6/\xB0/g;      # -> degree symbol
        s/\xC3\xBB/\xBD/g;      # -> 1/2
        s/\xC3\xE1/\x20/g;      # -> space
        s/\xC3\xFA/\xA3/g;      # -> pound sign

        # Replace bad chars prefixed with E-grave (xC8)
        s/\xC8\x98/\xF1/g;      # -> n-tilde
        s/\xC8\xA1/\xED/g;      # -> i-acute
        s/\xC8\xA6/\xFA/g;      # -> u-acute
        s/\xC8\xA8/\xE9/g;      # -> e-acute
        s/\xC8\xAC/\xEA/g;      # -> e-circumflex
        s/\xC8\xAD/\xFC/g;      # -> u-umlaut
        s/\xC8\xAF/\xEF/g;      # -> i-umlaut
        s/\xC8\xB3/\xF4/g;      # -> o-circumflex
        s/\xC8\xB5/\xF6/g;      # -> o-umlaut
        s/\xC8\xBA/\xE7/g;      # -> c-cedilla
        s/\xC8\xBD/\xEB/g;      # -> e-umlaut
        s/\xC8\xBF/\xE8/g;      # -> e-grave
        s/\xC8\xD1/\xE5/g;      # -> a-ring
        s/\xC8\xE1/\xE0/g;      # -> a-grave
        s/\xC8\xE8/\x20/g;      # -> space
        s/\xC8\xED/\xE1/g;      # -> a-acute
        s/\xC8\xF1/\xE4/g;      # -> a-umlaut
        s/\xC8\xFE/\xF3/g;      # -> o-acute
        
        # Remove non-printing ASCII/8859-1 control characters but
        # make sure we keep \t \n \r
        s/[\x00-\x08\x0B-\x0C\x0E-\x1F\x7F-\x9F]//g;

        # debug output for still-unhandled xC0/xC3/xC8 bad characters
        if (not $opt_quiet) {
            my @bad_chars = $page =~ /([\xC0\xC3\xC8][\xA0-\xFF]{1})/g;
            if (@bad_chars) {
                say ("\n");
                my $bad_char;
                foreach $bad_char (@bad_chars) {
                    warn "Bad character seen '$bad_char' in listings file";
                }
                say("\n");
            }
        }
    }

    foreach (split /\n/, $page) {
	my @fields = split /\~/;
	if (@fields != 23) {
	    if (not $opt_quiet) {
	        warn "Wrong number of fields in line:\n$_\n"
	          unless $warned_wrong_num_fields{$ch}++;
            }
	    next;
	}
	foreach (@fields) { s/^\s+//; s/\s+$//; undef $_ if not length }
	
	# Description of Radio Times data fields (23 in total):
	#
	# title - the programme title (text)
	# sub_title - infrequently defined - preference is given to episode
	#             if defined
	# episode - the name of a particular episode of the programme or 
	# the episode's position in the current series (text)
	# year - the year of production (text)
	# director - the programme's director(s) (text)
	# cast - the programme's cast (may include character details) (text)
	# premiere - whether this is a film's first showing (boolean)
	# film - whether the programme is a film (boolean)
	# repeat - whether the programme has been shown before (boolean)
	# subtitles - whether subtitles are available (boolean)
	# widescreen - whether the broadcast is 16:9 widescreen (boolean)
	# new_series - whether the programme is the first episode in a 
	#              series new (boolean)
	# deaf_signed - whether in-vision signing is available (boolean)
	# blank_and_white - whether the broadcast is not in colour (boolean)
	# star_rating - a star rating between 0 and 5 for films (text)
	# certificate - the BBFC certificate for the programme (text)
	# genre - the genre of the programme (text)
	# desc - a description of the programme. Can be a specific review by a
	#        Radio Times reviewer (text)
	# choice - whether the programme is recommended by the 
	#          Radio Times (boolean)
	# date - the transmission date (text)
	# start - the transmission start time for the programme (text)
	# stop - the transmissions stop time for the programme (text)
	# duration_mins - the duration of the programme in minutes (text)
	my ($title, $sub_title, $episode, $year, $director, $cast,
	    $premiere, $film, $repeat, $subtitles, $widescreen,
	    $new_series, $deaf_signed, $black_and_white, $star_rating,
	    $certificate, $genre, $desc, $choice, $date, $start, $stop,
	    $duration_mins) = @fields;
	foreach ($premiere, $film, $repeat, $subtitles, $widescreen,
		 $new_series, $deaf_signed, $black_and_white, $choice) {
	    die "true/false value not defined" if not defined;
	    if ($_ eq 'true') { $_ = 1 }
	    elsif ($_ eq 'false') { $_ = 0 }
	    else { die "bad true/false value $_" }
	}

	warn "Ignoring sub-title $sub_title since episode also given\n"
	  if defined $sub_title and defined $episode and not $opt_quiet;
	$sub_title = $episode if defined $episode;

	if (not defined $title) {
	    warn("Missing title in: $_") if not $opt_quiet;
	    next;
        }

	# FIXME - need to ensure transitions are handled correctly
	#
	# Roundabout the summer time changeover they include timezone
	# in the title. Remove the DST information from the title.
	#
	my $explicit_tz = '';
	if ($title =~ s/^\((GMT|UTC|BST|UTC\+1)\)\s*//) {
	    $explicit_tz = $1;
	}
	
	# Remove extra non-title programme information from title. Leaving
	# this information in the title results in PVR applications not
	# being able to consistently match programme titles. 
	for($title) {
	    s/^3 Minute Wonder\s*:\s*//;
	    s/^4 Music\s*:\s*//;
	    s/^4Play\s*:\s*//;
	    s/^Bond Season\s*:\s*//;
	    s/^CBBC\s*:\s*//;
	    s/^CBeebies\s*:\s*//;
	    s/^CITV\s*:\s*//;
	    s/^Comedy Season\s*:\s*//;
	    s/^Sign Zone\s*:\s*//;
	    s/^T4\s*:\s*//;
	}

	my %p = (channel => $ch, title => [ [ $title ] ]);

        if (defined $sub_title && 
            ($sub_title =~ /^(\d+)\/(\d+)$/ ||
             $sub_title =~ /^(\d+)\/(\d+)\s+-\s+/))
        {
            my $episode = $1 - 1;
            my $episodes = $2;

            $p{'episode-num'} = [ [ " . ${episode}/${episodes} . ", "xmltv_ns" ] ];

            $sub_title =~ s/^(\d+)\/(\d+)(?:\s+-\s+)?//;

            undef $sub_title if $sub_title =~ /^\s*$/;
        }
	for ($sub_title) { $p{'sub-title'} = [ [ $_ ] ] if defined }
	for ($desc) {
	    if (defined) {
		s/\s+/ /g;
		s!</?[A-Za-z]+>!!g;
		$p{desc} = [ [ $_, 'en' ] ];
	    }
        }
	for ($director) { $p{credits}{director} = [ $_ ] if defined }

	# The Radio Times includes cast information in 2 formats:
        #
        # a) pairings of 'character*actor' with subsequent pairings 
        #    separated by '|' - '*' does not appear in any text
        # b) a comma separated list of actors with no character details
        #
        # If 'Director' appears in the character entry, this is to be used 
        # as a regular cast member, not the programme's director
	if (defined $cast) {
	    my @cast;
            
            $cast =~ s/\s+/ /g;
            
            # first we check for 'character*actor' entries
            if ($cast =~ tr/*//) {
                # multiple 'character*actor'entries
                if ($cast =~ tr/|//) {
		    @cast = split /\|/, $cast;
                }
                # single 'character*actor' entry
                else {
                    push @cast, $cast;
                }
                
		# we remove the 'character*' portion of the entry
		foreach (@cast) {
		    unless ( s/^.*[*]// ) {
		        warn "Bad cast entry for '$title': $_" if not $opt_quiet;
                    }
		}
	    }
            # next we check for CSV-style actor entries
	    elsif ($cast =~ tr/,//) {
		@cast = split /,/, $cast;
	    }
	    # finally we assume a single actor's name that contains neither 
	    # '*' nor ','
	    else {
	        push @cast, $cast;
	    }
	    # trim whitespace from beginning/end of actor names
	    foreach (@cast) { s/^\s+//; s/\s+$//; }
	    $p{credits}{actor} = \@cast;
        }
	for ($year) { $p{date} = $_ if defined }
        push @{$p{category}}, [ $genre, 'en' ] if defined $genre and not $film;
	push @{$p{category}}, [ 'Film', 'en' ] if $film;
	$p{video}{aspect} = '16:9' if $widescreen;
	$p{video}{colour} = 0 if $black_and_white;
	$p{'previously-shown'} = {} if $repeat;
	$p{premiere} = [ '' ] if $premiere;
	$p{new} = 1 if $new_series;
	push @{$p{subtitles}},{type=>'teletext'} if $subtitles;
	push @{$p{subtitles}},{type=>'deaf-signed'} if $deaf_signed;
        $p{rating} = [ [ $certificate, 'BBFC' ] ] if defined $certificate;
        push @{$p{'star-rating'}}, [ "$star_rating/5", 'Radio Times Film Rating' ] 
            if defined $star_rating and $film;
        push @{$p{'star-rating'}}, [ '1/1', 'Radio Times Recommendation' ] if $choice;

	# Date, start and stop time.
	my ($yyyy, $mm, $dd);
	for ($date) {
	    die "Missing date in $_" if not defined;
	    m!(\d\d)/(\d\d)/(\d{4})$! or die "Bad date $_";
	    ($dd, $mm, $yyyy) = ($1, $2, $3);
	}

	$p{start} = utc_offset "$yyyy$mm$dd$start $explicit_tz", $base_tz;
	$p{stop} = utc_offset "$yyyy$mm$dd$stop $explicit_tz", $base_tz;
	if (Date_Cmp($p{start}, $p{stop}) > 0) {
	    $p{stop} = utc_offset(DateCalc("$yyyy$mm$dd$stop $explicit_tz",
					   '+ 1 day'),
				  $base_tz);
	}
	# Ignore $duration_mins since it may not be reliable.

	$writer->write_programme(\%p);
    
    }
    
    # Update the progres bar by one increment
    if (defined $listings_bar) {
        $listings_bar->update();
    }
}

$writer->end;

if (defined $listings_bar) {
    # Only update the progress bar to 100% if we need to
    $listings_bar->update($num_req_chans) if $need_final_update;
    $listings_bar->finish();
    say( "\n" ) if not $opt_quiet;
}

# Keep output on STDERR preserving STDOUT for XML data
say( "Finished!\n" ) if not $opt_quiet;
