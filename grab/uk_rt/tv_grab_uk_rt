#!/usr/bin/perl -w

use IO::Socket;
use strict;
use LWP::Simple;
use XMLTV;
use Date::Manip;
use Getopt::Long;

# Use Log::TraceMessages if installed.
BEGIN {
    eval { require Log::TraceMessages };
    if ($@) {
	*t = sub {};
	*d = sub { '' };
    }
    else {
	*t = \&Log::TraceMessages::t;
	*d = \&Log::TraceMessages::d;
	Log::TraceMessages::check_argv();
    }
}

sub get_url( $ );
sub human_date( $ );
sub get_programmes( $$$ );
sub get_programme_details( $$ );
sub get_channels();
sub get_categories();
sub get_available_dates();
sub get_progs_in_cat( $$$ );
sub rt_to_xmltv( $ );
sub xmltv_to_rt( $ );

# GLOBAL CONSTANTS
my $TIME_INTERVAL = 120;
my $LANG = 'en';
my $host='www.radiotimes.beeb.com';
my $domain = $host; $domain =~ s/^www\.//;

# Whether to fetch categories (makes everything slower)
my $GET_CATEGORIES = 0;

# Tables to convert between Radio Times and XMLTV ids of channels.
# The way to access these is through the routines rt_to_xmltv() and
# xmltv_to_rt(), not directly.  Those will deal sensibly with a new RT
# channel that isn't mentioned here.
#
my %rt_to_xmltv =
  (
   '39' => 'animalplanet.discoveryeurope.com', # Animal Planet (Digital)
   '92' => 'south-east.bbc1.bbc.co.uk', # BBC1 South East
   '105' => 'south-east.bbc2.bbc.co.uk', # BBC2 South East
   '45' => 'choice.bbc.co.uk',	# BBC Choice
   '47' => 'knowledge.bbc.co.uk', # BBC Knowledge
   '48' => 'news-24.bbc.co.uk', # BBC News 24
   '49' => 'parliament.bbc.co.uk', # BBC Parliament
   '123' => 'british.eurosport.com', # British Eurosport
   '26' => 'carlton.com',	# Carlton
   '127' => 'cinema.carlton.com', # Carlton Cinema
   '132' => 'channel4.com',	# Channel 4
   '134' => 'channel5.co.uk',	# Channel 5
   '147' => 'discoveryeurope.com', # Discovery (Digital)
   '158' => 'e4.channel4.com',	# E4
   '160' => 'filmfour.channel4.com', # Film on Four
   '177' => 'plus.granadatv.co.uk', # Granada Plus
   '182' => 'thehistorychannel.co.uk', # History Channel (Digital)
   '185' => 'itv2.itv.co.uk',	# ITV2
   '213' => 'nationalgeographic.co.uk', # National Geographic (Digital)
   '224' => 'paramountcomedy.com', # Paramount Comedy
   '225' => 'performancetv.co.uk', # Performance
   '248' => 'sky-one.sky.com',	# Sky One
   '252' => '2.moviemax.sky.com', # Sky Moviemax 2
   '253' => '3.moviemax.sky.com', # Sky Moviemax 3
   '254' => '4.moviemax.sky.com', # Sky Moviemax 4
   '255' => '5.moviemax.sky.com', # Sky Moviemax 5
   '251' => 'moviemax.sky.com', # Sky Moviemax
   '249' => 'cinema.sky.com',	# Sky Cinema (Digital)
   '248' => 'ondigital.sky-one.sky.com', # Sky One (Ondigital)
   '258' => '2.premier.sky.com', # Sky Premier 2
   '259' => '3.premier.sky.com', # Sky Premier 3
   '260' => '4.premier.sky.com', # Sky Premier 4
   '257' => 'ondigital.premier.sky.com', # Sky Premier - Ondigital
   '261' => 'widescreen.premier.sky.com', # Sky Premier - Widescreen
   '264' => '2.sports.sky.com', # Sky Sports 2
   '265' => '3.sports.sky.com', # Sky Sports 3
   '250' => '2.cinema.sky.com', # Sky Cinema 2
   '262' => '1.sports.sky.com', # Sky Sports 1 (ITV Digital)
   '119' => 'biography-channel.biography.com', # Biography Channel
   '40' => 'artsworld.com',	# Artsworld
   '283' => 'studio.com',	# Studio
   '271' => 'tcm.turner.com',	# TCM (Digital)
   '292' => 'uk-drama.flextech.telewest.co.uk', # UK Drama
   '288' => 'uk-gold.flextech.telewest.co.uk', # UK Gold
   '290' => 'uk-horizons.flextech.telewest.co.uk', # UK Horizons
   '272' => 'wcw.tcm.turner.com ' # TCM/WCW
  );
my %xmltv_to_rt = reverse %rt_to_xmltv;

# get the channel options. Channels can be entered as a commar separated list
#     eg 92,105
# if no channels are specifed then listings for terestrial channels will be fetched
# if 'ALL' is specified then all available channels will be fetched

print STDERR 'Finding Channels:';
my %channels = get_channels();
print STDERR "\n";

my @dates_specified;
my @dates_to_get;

my $channels = '92,105,26,132,134'; # default: 5 terrestrial
GetOptions ('dates:s' => \@dates_specified, 'channels:s' => \$channels);
my %write_channels; # to be written as <channel> elements
foreach (split /,/, $channels) {
    if (m/ALL/) {
	# Get all available channels
	foreach (keys %channels) {
	    $write_channels{$_} = $channels{$_};
	}
    }
    elsif (not tr/0-9//c) {
	my $xmltv_id = rt_to_xmltv($_);
	if (not defined $channels{$xmltv_id}) {
	    die "no channel with RT id $_";
	}
	$write_channels{$xmltv_id} = $channels{$xmltv_id};
    }
    else {
	die "bad channel specification $_";
    }
}

# Get the dates options. Dates can be specified as a commar sperated list
#     eg 03/02/2002,04/02/2002
# if no dates are specifed then todays listings will be fetched
# if 'ALL' is specified then all available dates will be specifed
# if 'LATEST' is specified the listings for the latest available  day
# will be fetched

@dates_specified = split(/,/,join(',',@dates_specified));
foreach (@dates_specified) {
	if (m/ALL/) {
		print STDERR 'Finding available dates:';
		my @available_dates = get_available_dates ();
		print STDERR "\n";
		push (@dates_to_get, @available_dates);
	}
	elsif (m/LATEST/) {
		print STDERR 'Finding available dates:';
                my @available_dates = get_available_dates ();
                print STDERR "\n";
		my $latest_date = pop @available_dates;
		push (@dates_to_get, $latest_date);
	}
	elsif (m/^[0-9]{2}\/[0-9]{2}\/[0-9]{4}$/) {
		push (@dates_to_get, $_);
	}
	else {
	    die "bad date specification $_";
	}
}
#push (@dates_to_get, @dates_specified);

unless (@dates_specified) {
	# Get todays date
	my $today = UnixDate(ParseDate('today'), '%d/%m/%Y');
	die if not defined $today;
	push (@dates_to_get, $today);
}

# set up the XML writer
my $writer = new XMLTV::Writer(encoding => 'ISO-8859-1');
$writer->start({ 'source-info-url'     =>
          'http://http://www.radiotimes.co.uk/',
                 'source-info-name'    => 'RadioTimes',
                 'generator-info-name' => 'XMLTV',
                 'generator-info-url'  =>
          'http://membled.com/work/apps/xmltv/',
               });


# Find all the categories
print STDERR 'Finding Categories:';
my %categories = get_categories ();
print STDERR "\n";

# Find all the programes on the channels
my %prog_to_cat;
my %encounted_progs;

# get the listings for each date
my @programmes;
foreach my $date (@dates_to_get) {
    # Create the time string according to the TIME_INTERVAL
    my $hrs = 0;
    my $mns = 0;
    while ($hrs < 24) {
	my $time_str = "$hrs:$mns";
	$time_str =~ s/^([0-9]:)/0$1/;
	$time_str =~ s/:([0-9])$/:0$1/;
	$mns += $TIME_INTERVAL;
	$hrs += $mns / 60;
	$mns = $mns % 60;

	# first find all the new programmes for this time slot
	my @new_programmes;

	foreach my $chan (sort keys %write_channels) {
	    print STDERR "Finding the programmes on $chan at $date $time_str:";
	    push @new_programmes, get_programmes($chan, $date, $time_str);
	    print STDERR "\n";
	}

	# Next find all the programes in each category (if there are new progs
	# FIX ME we dont need to check all channels only those with new progs
	# FIX ME we also need to check if there are more than 100 results and
	# search over less channels
	if (@new_programmes) {
	    if ($GET_CATEGORIES) {
		print STDERR "Finding the categories at $time_str:";
		%prog_to_cat =
		  get_progs_in_cat([ sort keys %write_channels ], $date, $time_str);
		print STDERR "\n";
	    }
	}

	# Set the category for each new programme
	foreach my $new_prog (@new_programmes) {
	    my $channelId = $new_prog->{_chanID};
	    my $programmeId = $new_prog->{_progID};
	    if ($GET_CATEGORIES) {
		my $cat_ID = $prog_to_cat{"$channelId$programmeId"};
		my $cat = $categories{$cat_ID};
		if (defined $cat) {
		    push @{$new_prog->{category}}, [ lc $cat ];
		}
		else {
		    warn "unknown category id $cat\n";
		}
	    }
	}

	# push the new channels into the completlist
	push (@programmes, @new_programmes);
    }
}

# write out the xml
# write out the channels
$writer->write_channels(\%write_channels);

#write out the programmes
foreach (@programmes) {
    $writer->write_programme($_);
}
$writer->end();

exit;


# Function to get a url.  This also seems like a sensible place to do
# HTML-demoronizing.  I've removed the automatic retrying because it
# won't interact well with memozing LWP::get() and I'd prefer to be
# warned whenever a page fails to download.  Could add it back later.
#
sub get_url( $ ) {
    my $url = shift;
    for (my $data = get($url)) {
	die "cannot get $url\n" if not defined;
	tr/\222\222\226/''-/;
	# There could be other illegal chars but I haven't seen them.
	return $_;
    }
}


sub human_date( $ ) {
    #
    # produce a human readable date string
    # Usage human_date($seconds_since_epoch)
    #
    my $date = shift;
    my ($year,$month,$day,$hour,$minute,$second)
      = (localtime($date))[5,4,3,2,1,0];
    $year += 1900;
    $month++;
    return sprintf '%2.2d%2.2d%2.2d%2.2d:%2.2d:%2.2d',
      $year,$month,$day,$hour,$minute,$second;
}

# Function to find all the programmes on a channel (at a given date + time)
sub get_programmes( $$$ ) {
    my $channelId = xmltv_to_rt(shift);
    my $searchDate = shift;
    my $searchTime = shift;

    my @p;

    my $url = "http://$host/ListingsServlet?event=4&";
    $url .= 'jspGridLocation=%2Fjsp%2Ftv_listings_grid.jsp&';
    $url .= 'jspListLocation=%2Fjsp%2Ftv_listings_single.jsp&';
    $url .= 'jspError=%2Fjsp%2Ferror.jsp&';
    $url .= "searchDate=$searchDate&";
    $url .= "searchTime=$searchTime&";
    $url .= "channels=$channelId";
    my $data = get_url($url);
    $data =~ tr/\n//d;

    my @results = ($data =~ m/<!-- start of a result -->.*?<!-- end of a result -->/ig);
    warn 'no results found in HTML' if not @results;

    # print STDERR "$channelId $searchDate $searchTime\n";

    foreach (@results) {
	m/programmeId=([0-9]+)/ or die "cannot find programmeId= in $_";
	my $programmeId = $1;

	unless ($encounted_progs{"$channelId$programmeId"}) {
	    $encounted_progs{"$channelId$programmeId"} = 1;
	    #print STDERR "ChannelId:$channelId ProgrammeId:$programmeId\n";
	    my %r = get_programme_details ($channelId, $programmeId);
	    push @p, \%r;
	}
    }
    return @p;
}

# Function to parse the HTML and get all the info we need
sub get_programme_details( $$ ) {
    my $channelId = shift;
    my $programmeId = shift;

    my %p;
    $p{channel} = rt_to_xmltv($channelId);
    $p{_chanID} = $channelId;
    $p{_progID} = $programmeId;
    if ($GET_CATEGORIES) {
	my $cat_ID = $prog_to_cat{"$channelId$programmeId"};
	my $cat = $categories{$cat_ID};
	push @{$p{category}}, [ lc $cat ];
    }

    my $url = "http://$host/ListingsServlet?event=10&";
    $url .= "channelId=$channelId&";
    $url .= "programmeId=$programmeId&";
    $url .= 'jspLocation=/jsp/prog_details.jsp';
    my $prog_details_string = get_url($url);
    $prog_details_string  =~ s/\n//g;
    $prog_details_string  =~ m/\/\/-->(.*?)<!-- end main table -->/
      or die "cannot find /-->.*<!-- end main table/ in $_";
    my $prog_details = $1;
    #chop off anything before //-->
    $prog_details =~ s/.*\/\/-->//;
    #get rid of the tag which messes things up
    $prog_details =~ s/<!--.*?-->/\|/g;
    # replace html tags with pipes
    $prog_details =~ s/<[ ]*[^0-9][^>]*?>/\|/g;
    #replace multiple spaces
    $prog_details =~ s/\s+/ /g;
    #replace pipe followed by space
    $prog_details =~ s/\|\s/\|/g;
    #replace multiple pipes
    $prog_details =~ s/\|+/\|/g;
    $prog_details =~ s/&nbsp;//g;

    # chop of related features or related websites
    $prog_details =~ s/Related Features\|.*//;
    $prog_details =~ s/Related Websites\|.*//;

    $prog_details =~ m/ \|(.*?)\|Channel:/
      or die "cannot find title in HTML $_";
    my $title = $1;
    my $sub_title;
    if ($title =~ s/\|(.*)//) {
	$sub_title = $1;
    }
    for ($title) {
	s/^\s+//; s/\s+$//;
    }
    $p{title} = [ [ $title, $LANG ] ];

    $prog_details =~ m/Channel:\|(.*?)\|/
      or die "cannot find channel name in HTML $_";
    my $channel_name = $1;

    $prog_details =~ m/Date:\|.*? ([0-9]*? .*?)\|/
      or die "cannot find date in HTML $_";
    my $date = $1;

    $prog_details =~ m/Time:\|([0-9,a,m,p,:]*) to ([0-9,a,m,p,:]*)/
      or die "cannot find time in HTML $_";
    my $start_time = $1;
    my $stop_time = $2;
    my $start = UnixDate(ParseDate("$date $start_time"), '%s');
    my $stop = UnixDate(ParseDate("$date $stop_time"), '%s');

    # Some programmes have thir stop time on the next day
    if (($start_time =~ m/pm$/) and ($stop_time =~ m/am$/)) {
	$stop += 86400;
    }

    my $start_string = human_date($start);
    my $stop_string = human_date($stop);

    $p{start} = $start_string;
    $p{stop} = $stop_string;

    #chop of all the stuff we have parsed
    $prog_details =~ s/.*Time:\|$start_time to $stop_time\|//;

    my ($options,$subtitles,$widescreen,$repeat,$black_and_white,
	$certificate,$episode,$review,$director,$filmed_in,$cast);

    if ($prog_details =~ m/(.*?)\|/) {
	# FIXME warn about options other than these.
	$options = $1;
	if ($options eq 'Review') {
	    $options ='';
	}
	if ($options eq 'Episode') {
	    $options ='';
	}
	if ($options eq 'Certificate:') {
	    $options ='';
	}

	if ($options =~m/Subtitled/) {
	    $subtitles = 'yes';
	    $p{subtitles} = [ { type => 'teletext' } ];
	}
	if ($options =~m/Widescreen/) {
	    # FIXME I think this can be handled under <video>.
	    $widescreen = 'yes';
	    $p{_widescreen} = 'yes';
	}
	if ($options =~m/Repeat/) {
	    $repeat = 'yes';
	    $p{'previously-shown'} = {}
	}
	if ($options =~m/Black and White/) {
	    $black_and_white = 'yes';
	    $p{video}{present} = 1;
	    $p{video}{colour} = 0;
	}

	$prog_details =~ s/$options\|//;
    }

    if ($prog_details =~ m/Certificate:\|\[(.*?)\]\|/) {
	$certificate = $1;
	$p{_certificate} = $1;
    }

    # episode corresponds to badly named 'sub -title'
    if ($prog_details =~ m/Episode\|(.*?)\|/) {
	$episode = $1;
	$p{'sub-title'} = [ [ $1, $LANG ] ];
    }

    # Review corresponds to description
    if ($prog_details =~ m/Review\|(.*?)\|/) {
	$review = $1;
	for ($review) {
	    s/^\s+//; s/\s+$//;
	}
	$p{desc} = [ [ $review, $LANG ] ];
    }

    #chop of all the stuff we have parsed
    # FIXME should have removed this while parsing.
    $prog_details =~ s/.*Certificate:\|(.*?)\|//;
    $prog_details =~ s/.*Episode\|(.*?)\|//;
    $prog_details =~ s/.*Review\|(.*?)\|//;

    if ($prog_details =~ m/Directed by:\|(.*?)\|/) {
	$director = $1;
	push @{$p{credits}{director}}, $1;
    }
    if ($prog_details =~ m/Filmed in:\|(.*?)\|/) {
	$filmed_in = $1;$p{'_filmed_in'} = $1;
    }
    if ($prog_details =~ m/Cast List\|(.*)/) {
	$cast = $1;
	$cast =~ s/\s*\|$//;

	if ($cast =~ m/\|\.\.\.\.\.\|/) {
	    $cast =~ s/(\|\.\.\.\.\.)+/\@/;
	    #$cast =~ s/\@+/\@/g;
	    my @splitter = split /\@\|/, $cast;
	    my $roles_string = shift @splitter;
	    my $names_string = shift @splitter;
	    my @act_roles = split /\|/, $roles_string;
	    my @act_names = split /\|/, $names_string;
	    $cast = '';
	    foreach my $act_name (@act_names) {
		my $act_role = shift @act_roles;
		$cast .= "|$act_name,$act_role";
	    }
	    $cast =~ s/^\|//;
	}
	else {
	    $cast =~ s/\|/,actor\|/g;
	    $cast =~ s/,/,actor\|/g;
	    $cast =~ s/\|\s/\|/g;
	    $cast =~ s/$/,actor/;
	}

	my @cast_list = split /\|/, $cast;
	foreach (@cast_list) {
	    m/^([^,]*),([^,]*)$/;
	    my $name = $1;
	    my $role = $2;

	    # FIXME The XMLTV doesnt seem to allow anything but actor or
	    # director so we must just ignore role for now
	    push @{$p{credits}{actor}}, $name;
	}
    }

    #print STDERR "Title: $title\n";
    #print STDERR "Sub Title: $sub_title\n";
    #print STDERR "Channel: $channel_name\n";
    #print STDERR "Date: $date\n";
    #print STDERR "Start: $start_string\n";
    #print STDERR "Stop: $stop_string\n";
    #print STDERR "Subtitles: $subtitles\n";
    #print STDERR "WideScreen: $widescreen\n";
    #print STDERR "Repeat: $repeat\n";
    #print STDERR "Black and White: $black_and_white\n";
    #print STDERR "Certificate: $certificate\n";
    #print STDERR "Episode: $episode\n";
    #print STDERR "Review: $review\n";
    #print STDERR "Directed By: $director\n";
    #print STDERR "Filmed in: $filmed_in\n";
    #print STDERR "Cast List: $cast\n";
    #print STDERR "\n";

    return %p;
}

# Function which will locate all the available channels and return a hash
# with channelId as the key and a chanel description
sub get_channels() {
    my $data = get_url("http://$host/");
    $data =~ tr/\n\r/\n/ds;
    t 'got channels page: ' . d $data;
    $data =~ s/\n//g;
    $data =~ m/<select name="channels"[^>]*?>(.*?)<\/select>/
      or die "cannot find channel string in HTML $_";
    my $channel_string = $1;
    t 'got string of channels: ' . d $channel_string;
    $channel_string =~ s/\s+/ /g;
    my @channels = ($channel_string =~ m/<option value="[0-9]+" >[^<]*/ig);
    t 'channels in string: ' . d @channels;
    warn "no channels found in $channel_string" if not @channels;
    my %c;

    foreach (@channels) {
	t 'doing channel string: ' . d $_;
	m/"([0-9]*)"/ or die "cannot find numeric channel id in $_";
	my $channelId = $1;
	t 'got numeric id: ' . d $channelId;
	m/>(.*)/ or die "cannot find channel description in $_";
	my $channelDesc = $1;
	for ($channelDesc) {
	    s/^\s+//; s/\s+$//;
	}
	t 'got description: ' . d $channelDesc;
	my $chanID_to_output = rt_to_xmltv($channelId);
	t 'XMLTV id to use: ' . d $chanID_to_output;
	die if not defined $chanID_to_output;
	die if not defined $domain;
	die if not defined $channelId;
	my $ch = { 'display-name' => [ [ $channelDesc, $LANG ] ],
		   'id' => $chanID_to_output };
	t 'channel object: ' . d $ch;
	$c{$chanID_to_output} = $ch;
	t "added to channels hash under key $chanID_to_output";
    }

    t 'returning hash: ' . d \%c;
    return %c;
}

# Function which will locate all the available categories and return a hash
# with categoryId as the key and a category description
sub get_categories() {
    my $data = get_url("http://$host/jsp/listings_search.jsp");
    $data =~ s/\n//g;
    $data =~ m/<select name="genres"[^>]*?>(.*?)<\/select>/
      or die "cannot find category in HTML $_";
    my $category_string = $1;
    $category_string =~ s/\s+/ /g;
    my @categories =
      ($category_string =~ m/<option value="[0-9]+">[^<]*/ig);
    warn "cannot find categories in $category_string" if not @categories;
    my %c;

    foreach (@categories) {
	m/"([0-9]*)"/
	  or die "cannot find number in category $_";
	my $categoryId = $1;
	m/>(.*)/
	  or die "cannot find description in category $_";
	my $categoryDesc = $1;
	#print STDERR "Found Category: $categoryId CategoryDesc: $categoryDesc\n";
	my $cast;

	$c{$categoryId} = $categoryDesc;
    }

    return %c;
}

# Function which will locate all the available dates and return a list
sub get_available_dates() {
    my $data = get_url("http://$host/jsp/listings_search.jsp");
    $data =~ s/\n//g;
    $data =~ m/<select name="searchDate"[^>]*?>(.*?)<\/select>/
      or die "cannot find searchDate string in HTML $_";
    my $dates_string = $1;
    $dates_string =~ s/\s+/ /g;
    my @dates =
      ($dates_string =~ m/[0-9]{2}\/[0-9]{2}\/[0-9]{4}/ig);
    warn "cannot find dates in $dates_string" if not @dates;
    return @dates;
}


# Function which will locate all the programes in a category
# (at a given date and time)
# will return a hash with "chanIDProgID" as the key
sub get_progs_in_cat( $$$ ) {
    my @channels_to_search = map { xmltv_to_rt($_) } @{shift()};
    my $searchDate = shift;
    my $searchTime = shift;

    my %cats;

    # For each category find all the programmes in that category
    foreach my $category (keys %categories) {
	my $url = "http://$host/ListingsServlet?event=7&";
	$url .= 'jspGridLocation=%2Fjsp%2Ftv_listings_grid.jsp&';
	$url .= 'jspListLocation=%2Fjsp%2Ftv_listings_list.jsp&';
	$url .= 'jspError=%2Fjsp%2Ferror.jsp&';
	$url .= 'channels=' . join(',', @channels_to_search) . '&';
	$url .= "genres=$category&";
	$url .= "searchDate=$searchDate&";
	$url .= "searchTime=$searchTime";
	#print STDERR "$url\n";
	my $data = get_url($url);
	$data =~ s/\n//g;

	my @results = ($data =~ m/<!-- start of a result -->.*?<!-- end of a result -->/ig);
	warn "cannot find results in $data" if not @results;

	#print STDERR "$category $searchDate $searchTime\n";

	foreach (@results) {

	    m/channelId=([0-9]+)/
	      or die "cannot find channelId= in $_";
	    my $channelId = $1;

	    m/programmeId=([0-9]+)/
	      or die "cannot find programmeId= in $_";
	    my $programmeId = $1;

	    $cats{"$channelId$programmeId"} = $category;
	    #print STDERR "ChannelId:$channelId ProgrammeId:$programmeId\n";
	}
    }
    return %cats;
}

sub rt_to_xmltv( $ ) {
    my $n = shift;
    if (not defined $rt_to_xmltv{$n}) {
	my $new = "$n.radiotimes.beeb.com";
	die "channel id $new already exists" if defined $xmltv_to_rt{$new};
	$rt_to_xmltv{$n} = $new;
	$xmltv_to_rt{$new} = $n;
    }
    return $rt_to_xmltv{$n};
}
sub xmltv_to_rt( $ ) {
    my $x = shift;
    for ($xmltv_to_rt{$x}) {
	die "no RT id known for $x" if not defined;
	return $_;
    }
}
