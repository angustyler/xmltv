#!/usr/bin/perl -w

use strict;
use IO::Socket;
use LWP::Simple;
use Date::Manip;
use Getopt::Long;
use XMLTV;
use XMLTV::Memoize;
use XMLTV::Ask;
use XMLTV::Usage <<END
To configure: $0 --configure [--config-file FILE]
To grab listings: $0 [--config-file FILE] [--output FILE] [--days N]
END
  ;

# Use Log::TraceMessages if installed.
BEGIN {
    eval { require Log::TraceMessages };
    if ($@) {
	*t = sub {};
	*d = sub { '' };
    }
    else {
	*t = \&Log::TraceMessages::t;
	*d = \&Log::TraceMessages::d;
	Log::TraceMessages::check_argv();
    }
}

sub get_url( $ );
sub get_programmes( $$$$ );
sub get_programme_details( $$$$ );
sub do_cast( $$ );
sub get_channels();
sub get_categories();
sub get_available_dates();
sub get_progs_in_cat( $$$ );
sub rt_to_xmltv( $ );
sub xmltv_to_rt( $ );
sub grab( @ );
sub configure();

# GLOBAL CONSTANTS
my $TIME_INTERVAL = 120;
my $LANG = 'en';
my $DOMAIN = 'radiotimes.beeb.com';
my $BASE_URL = "http://www.$DOMAIN";

# Whether to fetch categories (makes everything slower)
my $GET_CATEGORIES = 0;

# Tables to convert between Radio Times and XMLTV ids of channels.
# The way to access these is through the routines rt_to_xmltv() and
# xmltv_to_rt(), not directly.  Those will deal sensibly with a new RT
# channel that isn't mentioned here.
#
my %rt_to_xmltv =
  (
   26  => 'carlton.com',                         # Carlton
   39  => 'animalplanet.discoveryeurope.com',    # Animal Planet (Digital)
   40  => 'artsworld.com',                       # Artsworld
   45  => 'choice.bbc.co.uk',                    # BBC Choice
   47  => 'knowledge.bbc.co.uk',                 # BBC Knowledge
   48  => 'news-24.bbc.co.uk',                   # BBC News 24
   49  => 'parliament.bbc.co.uk',                # BBC Parliament
   92  => 'south-east.bbc1.bbc.co.uk',           # BBC1 South East
   105 => 'south-east.bbc2.bbc.co.uk',           # BBC2 South East
   119 => 'biography-channel.biography.com',     # Biography Channel
   123 => 'british.eurosport.com',               # British Eurosport
   127 => 'cinema.carlton.com',                  # Carlton Cinema
   132 => 'channel4.com',                        # Channel 4
   134 => 'channel5.co.uk',                      # Channel 5
   147 => 'discoveryeurope.com',                 # Discovery (Digital)
   158 => 'e4.channel4.com',                     # E4
   160 => 'filmfour.channel4.com',               # Film on Four
   177 => 'plus.granadatv.co.uk',                # Granada Plus
   182 => 'thehistorychannel.co.uk',             # History Channel (Digital)
   185 => 'itv2.itv.co.uk',                      # ITV2
   213 => 'nationalgeographic.co.uk',            # National Geographic (Digital)
   224 => 'paramountcomedy.com',                 # Paramount Comedy
   225 => 'performancetv.co.uk',                 # Performance
   248 => 'ondigital.sky-one.sky.com',           # Sky One (Ondigital)
   248 => 'sky-one.sky.com',                     # Sky One
   249 => 'cinema.sky.com',                      # Sky Cinema (Digital)
   250 => '2.cinema.sky.com',                    # Sky Cinema 2
   251 => 'moviemax.sky.com',                    # Sky Moviemax
   252 => '2.moviemax.sky.com',                  # Sky Moviemax 2
   253 => '3.moviemax.sky.com',                  # Sky Moviemax 3
   254 => '4.moviemax.sky.com',                  # Sky Moviemax 4
   255 => '5.moviemax.sky.com',                  # Sky Moviemax 5
   257 => 'ondigital.premier.sky.com',           # Sky Premier - Ondigital
   258 => '2.premier.sky.com',                   # Sky Premier 2
   259 => '3.premier.sky.com',                   # Sky Premier 3
   260 => '4.premier.sky.com',                   # Sky Premier 4
   261 => 'widescreen.premier.sky.com',          # Sky Premier - Widescreen
   262 => '1.sports.sky.com',                    # Sky Sports 1 (ITV Digital)
   264 => '2.sports.sky.com',                    # Sky Sports 2
   265 => '3.sports.sky.com',                    # Sky Sports 3
   271 => 'tcm.turner.com',                      # TCM (Digital)
   272 => 'wcw.tcm.turner.com',                  # TCM/WCW
   283 => 'studio.com',                          # Studio
   288 => 'uk-gold.flextech.telewest.co.uk',     # UK Gold
   290 => 'uk-horizons.flextech.telewest.co.uk', # UK Horizons
   292 => 'uk-drama.flextech.telewest.co.uk',    # UK Drama
  );
my %xmltv_to_rt = reverse %rt_to_xmltv;

# Check options.  First do the undocumented --cache option (to cache
# get(), which retrieves web pages), then the normal ones.
#
my $using_cache = XMLTV::Memoize::check_argv('get');
my ($opt_days, $opt_help, $opt_output, $opt_share,
    $opt_configure, $opt_config_file);
# No default for $opt_days, we determine it from the site.
GetOptions('days=i'        => \$opt_days,
	   'help'          => \$opt_help,
	   'configure'     => \$opt_configure,
	   'config-file=s' => \$opt_config_file,
	   'output=s'      => \$opt_output,
	   'share=s'       => \$opt_share, # also undocumented
	  )
  or usage(0);
die 'number of days must not be negative'
  if (defined $opt_days && $opt_days < 0);
if ($opt_help) {
    usage(1);
}
if ($opt_configure) {
    print STDERR "Going to configure channels to download, please wait\n";
}
die if defined $opt_share; # TODO
die if defined $opt_output; # TODO

# File that stores which channels to download.
my $CONFIG_FILE = $opt_config_file;
my $PROGNAME = 'tv_grab_uk_rt'; # too confusing to use $0
if (not defined $CONFIG_FILE) {
    if (defined($ENV{HOME})) {
	my $conf_dir = "$ENV{HOME}/.xmltv";
	(-d $conf_dir) or mkdir($conf_dir, 0777)
	  or die "cannot mkdir $conf_dir: $!";
	$CONFIG_FILE = "$conf_dir/$PROGNAME";
    }
    else {
	# $HOME not set, use current directory.
	$CONFIG_FILE = $PROGNAME;
    }
}

if ($opt_configure) {
    if (-e $CONFIG_FILE) {
	print <<END
The configuration file $CONFIG_FILE already exists.  There is
currently no support for altering an existing configuration, you have
to reconfigure from scratch.

END
  ;
	if (not askBooleanQuestion
	    ('Do you wish to overwrite the old configuration?', 0)) {
	    print "Exiting.\n";
	    exit 0;
	}
    }
}
else {
    if (-e $CONFIG_FILE) {
	print STDERR "using config file $CONFIG_FILE\n";
    }
    else {
	die "config file $CONFIG_FILE does not exist, run me with --configure\n";
    }
}

print STDERR 'Finding Channels:';
my %channels = get_channels();
print STDERR "\n";

if ($opt_configure) {
    configure();
}
else {
    my %g_args = ();
    if (defined $opt_output) {
	my $fh = new IO::File ">$opt_output";
	die "cannot write to $opt_output\n" if not $fh;
	%g_args = (OUTPUT => $fh);
    }
    grab(%g_args);
}
exit();

# Grab listings and write them in XML.  Arguments are to be passed to
# XMLTV::Writer (but encoding is always ISO-8859-1).
#
sub grab( @ ) {
    my $writer = new XMLTV::Writer(@_, encoding => 'ISO-8859-1');
    my %write_channels;		# to be written as <channel> elements

    # Read the configuration file.  At present the lines must be one
    # of two forms:
    #
    # channel <xmltv id>
    # ALL
    #
    open(CONF, $CONFIG_FILE)
      or die "cannot read $CONFIG_FILE: $!\n";
    while (<CONF>) {
	s/\#.*//; s/^\s+//; s/\s+$//;
	next if not length;
	t "got line from config file: $_";
	if ($_ eq 'ALL') {
	    %write_channels = %channels;
	}
	elsif (/^channel\s+(.+)/) {
	    my $xmltv_id = $1;
	    if (not defined $channels{$xmltv_id}) {
		warn "$CONFIG_FILE:$.: no channel with XMLTV id $xmltv_id, skipping\n";
		next;
	    }
	    $write_channels{$xmltv_id} = $channels{$xmltv_id};
	}
	else { die "$CONFIG_FILE:$.: bad line\n" }
    }

    my @available_dates = get_available_dates();
    t 'available dates: ' . d \@available_dates;
    die 'apparently, there are no days of listings on the site'
      if not @available_dates;
    my $today = ParseDate('today midnight');

    my $is_available = sub( $ ) {
	my $d = shift;
	foreach (@available_dates) {
	    return 1 if not Date_Cmp($d, $_);
	}
	return 0;
    };

    my @dates_to_get;
    for (my $d = $today; $is_available->($d); $d = DateCalc($d, '+ 1 day')) {
	push @dates_to_get, $d;
    }
    die "listings for today ($today) not available" if not @dates_to_get;
    my $last_day = $dates_to_get[-1];
    foreach (@available_dates) {
	if (Date_Cmp($last_day, $_) < 0) {
	    warn "strangely, day $_ is available but there are gaps before it";
	}
    }

    if (defined $opt_days) {
	if ($opt_days > @dates_to_get) {
	    warn 'only ' . (scalar @dates_to_get)
	      . ' days of consecutive listings available';
	}
	else {
	    @dates_to_get = @dates_to_get[0 .. $opt_days - 1];
	}
    }
    my $days = @dates_to_get > 1 ? 'days' : 'day';
    print STDERR 'getting ' . (scalar @dates_to_get) . " $days of listings\n";
    t 'getting dates:' . d \@dates_to_get;

    $writer->start({ 'source-info-url'     => "$BASE_URL/",
		     'source-info-name'    => 'Radio Times',
		     'generator-info-name' => 'XMLTV',
		     'generator-info-url'  =>
		     'http://membled.com/work/apps/xmltv/',
		   });


    # Find all the categories
    print STDERR 'Finding Categories:';
    my %categories = get_categories ();
    print STDERR "\n";

    # Find all the programes on the channels
    my %prog_to_cat;

    # get the listings for each date
    my @programmes;
    foreach my $date (@dates_to_get) {
	# Create the time string according to the TIME_INTERVAL
	my $mns = 0;
	while ($mns < 24 * 60) {
	    my $time = DateCalc($date, "+ $mns minutes");
	    $mns += $TIME_INTERVAL;

	    # first find all the new programmes for this time slot
	    my @new_programmes;

	    foreach my $chan (sort keys %write_channels) {
		t "Finding the programmes on $chan at $time:";
		push @new_programmes, get_programmes($chan, $time, \%prog_to_cat, \%categories);
	    }

	    # Next find all the programes in each category (if there are new progs
	    # FIX ME we dont need to check all channels only those with new progs
	    # FIX ME we also need to check if there are more than 100 results and
	    # search over less channels
	    if (@new_programmes) {
		if ($GET_CATEGORIES) {
		    print STDERR "Finding the categories at $time:";
		    %prog_to_cat =
		      get_progs_in_cat([ sort keys %write_channels ], $time, \%categories);
		    print STDERR "\n";
		}
	    }

	    # Set the category for each new programme
	    foreach my $new_prog (@new_programmes) {
		my $channelId = $new_prog->{_chanID};
		my $programmeId = $new_prog->{_progID};
		if ($GET_CATEGORIES) {
		    my $cat_ID = $prog_to_cat{"$channelId$programmeId"};
		    my $cat = $categories{$cat_ID};
		    if (defined $cat) {
			push @{$new_prog->{category}}, [ lc $cat ];
		    }
		    else {
			warn "unknown category id $cat\n";
		    }
		}
	    }

	    # push the new channels into the completlist
	    push (@programmes, @new_programmes);
	}
    }

    # write out the xml
    # write out the channels
    $writer->write_channels(\%write_channels);

    #write out the programmes
    foreach (@programmes) {
	foreach my $k (keys %$_) {
	    die "undef $_->{$k}" if not defined $_->{$k};
	}
	$writer->write_programme($_);
    }
    $writer->end();
}


# Function to get a url.  This also seems like a sensible place to do
# HTML-demoronizing.  I've removed the automatic retrying because it
# won't interact well with memozing LWP::get() and I'd prefer to be
# warned whenever a page fails to download.  Could add it back later.
#
sub get_url( $ ) {
    my $url = shift;
    for (my $data = get($url)) {
	die "cannot get $url\n" if not defined;
	tr/\222\222\226/''-/;
	# There could be other illegal chars but I haven't seen them.
	return $_;
    }
}


# Function to find all the programmes on a channel (at a given date +
# time).
#
# Parameters:
#   XMLTV id of channel
#   Date::Manip object giving date and time
#   prog_to_cat hash (see elsewhere for details)
#   categories hash
#
# I think this relies on the page returning exactly $TIME_INTERVAL
# worth of listings.
#
my %seen_prog;
sub get_programmes( $$$$ ) {
    my $channel_xid = shift;
    my $time = shift;
    my $prog_to_cat = shift;
    my $categories = shift;

    my @p;

    my $url = "$BASE_URL/ListingsServlet?event=4&";
    $url .= 'jspGridLocation=%2Fjsp%2Ftv_listings_grid.jsp&';
    $url .= 'jspListLocation=%2Fjsp%2Ftv_listings_single.jsp&';
    $url .= 'jspError=%2Fjsp%2Ferror.jsp&';
    $url .= 'searchDate=' . UnixDate($time, '%d/%m/%Y') . '&';
    $url .= 'searchTime=' . UnixDate($time, '%R') . '&';
    $url .= 'channels=' . xmltv_to_rt($channel_xid);
    my $data = get_url($url);
    $data =~ tr/\n//d;

    my @results = ($data =~ /<!-- start of a result -->.*?<!-- end of a result -->/ig);
    warn 'no results found in HTML' if not @results;

    # print STDERR "$channel_xid $searchDate $searchTime\n";

    foreach (@results) {
	m/programmeId=([0-9]+)/ or die "cannot find programmeId= in $_";
	my $programmeId = $1;

	unless ($seen_prog{$channel_xid}->{$programmeId}++) {
	    #print STDERR "ChannelId:$channel_xid ProgrammeId:$programmeId\n";
	    my $progs = get_programme_details($channel_xid, $programmeId,
					      $prog_to_cat, $categories);
	    if (not $progs) {
		warn "could not get programme $programmeId on channel $channel_xid";
	    }
	    elsif (not @$progs) {
		warn "strange, $programmeId on channel $channel_xid seems to be empty";
	    }
	    else {
		push @p, @$progs;
	    }
	}
    }
    return @p;
}

# Function to parse the HTML and get all the info we need
#
# Parameters:
#   XMLTV id of channel
#   RT id of programme
#   hash mapping 'channelidprogrammeid' to RT category id
#   hash of categories
#
# Returns a listref of programmes: normally with just one element, but
# can be more when two programmes share a timeslot.  (The clumpidxes
# will be set.)
#
# Uses the global %channels hash.
#
sub get_programme_details( $$$$ ) {
#    local $Log::TraceMessages::On = 1;
    my $channel_xid = shift;
    my $channelId = xmltv_to_rt($channel_xid);
    my $programmeId = shift;
    use vars '%prog_to_cat'; local *prog_to_cat = shift;
    use vars '%categories'; local *categories = shift;

    # %p is the main programme we will return.
    my %p;
    $p{channel} = $channel_xid;
    $p{_chanID} = $channelId;
    $p{_progID} = $programmeId;

    # @followons are small extra programmes sharing its slot.  Things
    # like news bulletins which come in the middle of a film are also
    # counted as 'after' it, for simplicity.
    #
    my @followons;

    if ($GET_CATEGORIES) {
	my $cat_ID = $prog_to_cat{"$channelId$programmeId"};
	my $cat = $categories{$cat_ID};
	push @{$p{category}}, [ lc $cat ];
    }

    my $url = "$BASE_URL/ListingsServlet?event=10&";
    $url .= "channelId=$channelId&";
    $url .= "programmeId=$programmeId&";
    $url .= 'jspLocation=/jsp/prog_details.jsp';
    my $prog_details_string = get_url($url);
    $prog_details_string  =~ tr/\r//d;
#    t 'whole page: ' . d $prog_details_string;
    $prog_details_string  =~ m{</script>\s*(<table .*?)<!-- end main table -->}s
      or die "cannot main table in HTML $_";
    my $prog_details = $1;
#    local $Log::TraceMessages::On = 1;

    for ($prog_details) {
	my $C = '<!-- -->'; # used to stop strings running together

	# Remove scripting.
	s{<script>[^<]*</script>}{$C}g;
	
 	# Turn hyperlinks with only 'alt' text into ones with content.
 	s!<a href="(.+?)"[^>]*alt="(.+?)"[^>]*></a>!<a href="$1">$2</a>!g;

 	# Remove hyperlinks within the RT site (keep only external
 	# ones).  Hmm, sometimes Related Features might be relative
 	# links, and we might want to keep those.  Should check.
 	#
 	s{<a href="\W.+?"[^>]*>([^<]*)</a>}{$C$1$C}g;

 	# Replace <a> elements with just the URL and link text.
 	s{<a href="(.+?)"[^>]*>([^<]*)</a>}{$C$1$C$2$C}g;
 	t 'after href munging: ' . d $_;

	# Now we're ready to strip all markup.  We use pipe characters
	# as a delimiter between bits of text.  So first, check there
	# aren't any in there already.
	#
	tr/|//d;
	
	# Replace comments and HTML tags with pipes.
	s/<!--.*?-->/\|/g;
	s/<[ ]*[^0-9][^>]*?>/\|/g;
	
	# Tidy up the pipes and whitespace.  Hey, ASCII art!
	s/&nbsp;/ /g;
        s/\s+/ /g;
	s/\s+\|/\|/g;
	s/\|\s+/\|/g;
	tr/|/|/s;
	s/^\|//;
	s/\|$//;
	
#	local $Log::TraceMessages::On = 1;
	t 'after barification: ' . d $_;
    }

#    # chop of related features or related websites.  FIXME do better.
#    $prog_details =~ s/Related Features\|.*//;
#    $prog_details =~ s/Related Websites\|.*//;

    my @bits = split /\|/, $prog_details;
    (warn('no programme details found in HTML'), return undef)
      if not @bits;

    my $title = shift @bits;
    my $sub_title;
    if (@bits and $bits[0] ne 'Channel:') {
	$sub_title = shift @bits;
    }

    $p{title} = [ [ $title, $LANG ] ];

    my ($channel_name, $date, $times, $cert, $sub_title_1, $desc,
	$director, $filmed_in, $cast);
    # Map heading to [ where to put it, multiplicity ].
    my %fields = (Channel       => [ \$channel_name, '1' ],
		  Date          => [ \$date,         '1' ],
		  Time          => [ \$times,        '1' ],
		  Certificate   => [ \$cert,         '?' ],
		  Episode       => [ \$sub_title_1,  '?' ],
		  Review        => [ \$desc,         '?' ], # hmm
		  'Directed by' => [ \$director,     '?' ],
		  'Filmed in'   => [ \$filmed_in,    '?' ],
		 );
    FIELD: foreach my $f (sort keys %fields) {
	  my ($var, $mult) = @{$fields{$f}};
	  for (my $i = 0; $i < @bits; $i++) {
	      die if not defined $bits[$i];
	      if ($bits[$i] =~ /^$f:? *$/) {
		  my $val = $bits[$i + 1];
		  (warn("found $f: but nothing after it"), return undef)
		    if not defined $val;
		  $$var = $val;
		  splice @bits, $i, 2;
		  next FIELD;
	      }
	  }

	  if ($mult eq '1') {
	      # Mandatory item, and we didn't find it.
	      warn "could not find $f: in programme details";
	      return undef;
	  }
	  elsif ($mult eq '?') {
	      # No worry.
	  }
	  else {
	      die "bad multiplicity specifier $mult";
	  }
      }

    # Check the channel name found matches the channel we thought.
    my $ch = $channels{$channel_xid};
    die "no channel data for $channel_xid" if not defined $ch;
    my $dn = $ch->{'display-name'}->[0]->[0];
    die "no display name for $channel_xid" if not defined $dn;
    if ($dn ne $channel_name) {
	warn "channel name '$channel_name' for programme doesn't match $dn";
    }

    my ($start, $stop);
    if ($times =~ /^(.*) to (.*)$/) {
	$start = ParseDate("$date $1");
	(warn("cannot parse date $date with start time $1"), return undef)
	  if not defined $start;
	$stop = ParseDate("$date $2");
	(warn("cannot parse date $date with stop time $2"), return undef)
	  if not defined $stop;
    }
    else {
	warn "bad Time value $times";
	return undef;
    }
    # Some programmes have thir stop time on the next day
    if (Date_Cmp($start, $stop) > 0) {
	$stop = DateCalc($stop, '+ 1 day');
	die if not defined $stop;
    }
    $p{start} = $start;
    $p{stop} = $stop;

    if (defined $cert) {
	for ($cert) {
	    s/^\[//;
	    s/\]$//;
	    warn "ignoring certificate $_\n";
	}
    }

    if (not defined $sub_title and not defined $sub_title_1) {
	# No secondary title.
    }
    elsif (not defined $sub_title and defined $sub_title_1) {
	$p{'sub-title'} = [ [ $sub_title_1, $LANG ] ];
    }
    elsif (defined $sub_title and not defined $sub_title_1) {
	$p{'sub-title'} = [ [ $sub_title, $LANG ] ];
    }
    elsif (defined $sub_title and defined $sub_title_1) {
	warn "two sub-titles: $sub_title, $sub_title_1";
	$p{'sub-title'} = [ [ $sub_title, $LANG ],
			    [ $sub_title_1, $LANG ] ];
    }
    else { die }

    if (defined $desc) {
	$p{'desc'} = [ [ $desc, $LANG ] ];
    }
    if (defined $director) {
	push @{$p{credits}{director}}, $director;
    }
    if (defined $filmed_in) {
	warn "discarding filmed in $filmed_in\n";
    }

    if (defined $cast) {
	if ($cast =~ /(?:\.){5}/) {
	    # The style giving part.....actor.  There used to be code
	    # for this, but it seems the website has stopped producing
	    # it.
	    #
	    warn "discarding cast $cast";
	}
	else {
	    $p{credits}->{actor} = [ split /,\s*/, $cast ];
	}
    }

    my ($options,$subtitles,$widescreen,$repeat,$black_and_white,
	$episode,$review);
  BIT: while (@bits) {
	my $bit = shift @bits;
	if ($bit eq 'Cast List') {
	    # Some of the following bits are a cast list.
	    do_cast(\%p, \@bits);
	}
	elsif ($bit eq 'Related Websites') {
	    my ($url, $link_text, $desc, @bits) = @bits;
	    if (not defined $url) {
		warn "strange, no URL after 'Related Websites'";
		next;
	    }
	    # Remove moronic use of Javascript.
	    for ($url) {
		if (s/^javascript://) {
		    if (s/^(\w+)\('(.+?)'\);$/$2/) {
			warn "unknown Javascript function $1"
			  if ($1 ne 'exitpopup' and $1 ne 'refreshOpener');
		    }
		    else {
			warn "unknown Javascript statement $url";
		    }
		}
		else {
		    # I don't think this code will ever execute, alas.
		    warn "Hooray!  A non-Javascript link!\n";
		}
		# Not sure how spaces get in there, but they do.
		s/^\s+//; s/\s+$//;
		# (Could warn about all non-URL characters.)
	    }
	    push @{$p{url}}, $url;
	    if (not defined $link_text) {
		warn "strange, no link text after 'Related Websites'";
	    }
	    else {
		# Damned if you do, and damned if you don't :-).
		warn "discarding link text $link_text\n";
	    }
	    if (not defined $desc) {
		warn "strange, no description after 'Related Websites'";
	    }
	    else {
		# Damned if you do, and damned if you don't :-).
		warn "discarding link description $desc\n";
	    }
	    # And what if there was more than one related site?
	}
	else {
	    push @followons, do_misc(\%p, $bit);
	}
    }

    foreach (keys %p) {
	die "undef $_" if not defined $p{$_};
    }

    if (@followons) {
	my $num = 1 + @followons;
	my $i = 0;
	foreach (\%p, @followons) {
	    $_->{clumpidx} = "$i/$num";
	    ++ $i;
	}
    }
    return [ \%p, @followons ];
}
# Process a single bit, probably containing flags like 'Repeat'.
# Warns about unknown stuff.
#
# Parameters:
#   programme (will be modified)
#   bit of text (will be modified)
#
# Also returns any follow-on programmes which are found.
#
sub do_misc( $$ ) {
    use vars '%p'; local *p = shift;
    local $_ = shift;
    my @r;
    while (length) {
	if (s/^Subtitled,?\s*//) {
	    warn 'seen subtitling twice' if defined $p{subtitles};
	    $p{subtitles} = [ { type => 'teletext' } ];
	} elsif (s/^Widescreen,?\s*//) {
	    warn 'seen widescreen twice' if defined $p{_widescreen};
	    # FIXME I think this can be handled under <video>.
	    $p{_widescreen} = 'yes';
	} elsif (s/^Repeat,?\s*//) {
	    warn 'seen repeat twice' if defined $p{'previously-shown'};
	    $p{'previously-shown'} = {};
	} elsif (s/^(Black (?:and|&) White),?\s*//) {
	    warn 'seen black-and-white twice' if defined $p{video}{colour};
	    warn "assuming $1 is 'Black and White'\n";
	    $p{video}{present} = 1;
	    $p{video}{colour} = 0;
	} elsif (s/^(?:Followed by|Including) ([^,]+),?\s*//) {
	    push @r, { channel => $p{channel},
		       title   => [ [ $1, $LANG ] ],
		       start   => $p{start},
		       stop    => $p{stop},
		     };
	    # The caller must add the clumpidx later.
	} elsif (s/^Deaf Signed,?\s*//) {
	    warn "discarding deaf-signed\n";
	} else {
	    warn "unknown remnant bit $_";
	    last;
	}
    }
    return @r;
}
# Process a list of bits and store them in the {credits} part of a
# programme hash.
#
# Parameters:
#   (ref to) programme hash to modify,
#   (ref to) list of 'bits' of text, also modified
#
# This routine removes elements from the front of the list, as much as
# looks like a cast list.
#
sub do_cast( $$ ) {
    my $prog = shift;
    use vars '@bits'; local *bits = shift;
    t 'got cast list bits: ' . d \@bits;

    # Magic string that the site uses between part name and actor.
    my $DOTS = '.....';

    my $has_dots = 0;
    foreach (@bits) {
	if ($_ eq $DOTS) {
	    $has_dots = 1;
	    last;
	}
    }

    if ($has_dots) {
	# Gives the name of the part and of the actor.
	my (@parts, @actors);
      PART: while (@bits) {
	    for (shift @bits) {
		if ($_ eq $DOTS) {
		    unshift @bits, $_;
		    last PART;
		}
		elsif (/\w/) {
		    push @parts, $_;
		}
		else {
		    warn "bad part name $_";
		    push @bits, $_; # just so it doesn't get lost
		    last PART;
		}
	    }
	}

	my $n = 0;
      DOTS: while (@bits) {
	    for (shift @bits) {
		if ($_ eq $DOTS) {
		    ++ $n;
		} else {
		    unshift @bits, $_;
		    last DOTS;
		}
	    }
	}
	if ($n != @parts) {
	    warn 'found ' . (scalar @parts) . " parts in cast list, but only $n dots";
	}

      ACTOR: while (@bits && $n--) {
	    for (shift @bits) {
		if (not defined) {
		    warn "not enough actors for all parts in cast list";
		    last ACTOR;
		} elsif (not /\w/) {
		    warn "bad actor name $_";
		    unshift @bits, $_;
		    last ACTOR;
		} else {
		    push @actors, $_;
		}
	    }
	}

	while (@parts) {
	    my $p = shift @parts;
	    my $a = shift @actors;
	    warn "discarding information that $p is played by $a\n";
	    push @{$prog->{credits}->{actor}}, $a;
	}
    }
    else {
	t 'just a list of actors';
	for (shift @bits) {
	    if (not defined) {
		warn "nothing in cast list";
		return;
	    }
	    else {
		while (length) {
		    if (s/^([^,]+),?\s*//) {
			push @{$prog->{credits}->{actor}}, $1;
		    }
		    else {
			warn "weird bit in comma-separated cast list: $_";
			last;
		    }
		}
	    }
	}
    }
}


# Function which will locate all the available channels and return a hash
# with channelId as the key and a chanel description
sub get_channels() {
    my $data = get_url("$BASE_URL/");
    $data =~ tr/\n\r/\n/ds;
    t 'got channels page: ' . d $data;
    $data =~ s/\n//g;
    $data =~ /<select name="channels"[^>]*?>(.*?)<\/select>/
      or die "cannot find channel string in HTML $data";
    my $channel_string = $1;
    t 'got string of channels: ' . d $channel_string;
    $channel_string =~ s/\s+/ /g;
    my @channels = ($channel_string =~ /<option value="[0-9]+" >[^<]*/ig);
    t 'channels in string: ' . d @channels;
    warn "no channels found in $channel_string" if not @channels;
    my %c;

    foreach (@channels) {
	t 'doing channel string: ' . d $_;
	m/"([0-9]*)"/ or die "cannot find numeric channel id in $_";
	my $channelId = $1;
	t 'got numeric id: ' . d $channelId;
	m/>(.*)/ or die "cannot find channel description in $_";
	my $channelDesc = $1;
	for ($channelDesc) {
	    s/^\s+//; s/\s+$//;
	}
	t 'got description: ' . d $channelDesc;
	my $chanID_to_output = rt_to_xmltv($channelId);
	t 'XMLTV id to use: ' . d $chanID_to_output;
	die if not defined $chanID_to_output;
	die if not defined $channelId;
	my $ch = { 'display-name' => [ [ $channelDesc, $LANG ] ],
		   'id' => $chanID_to_output };
	t 'channel object: ' . d $ch;
	$c{$chanID_to_output} = $ch;
	t "added to channels hash under key $chanID_to_output";
    }

    t 'returning hash: ' . d \%c;
    return %c;
}

# Function which will locate all the available categories and return a hash
# with categoryId as the key and a category description
sub get_categories() {
    my $data = get_url("$BASE_URL/jsp/listings_search.jsp");
    $data =~ s/\n//g;
    $data =~ /<select name="genres"[^>]*?>(.*?)<\/select>/
      or die "cannot find category in HTML $data";
    my $category_string = $1;
    $category_string =~ s/\s+/ /g;
    my @categories =
      ($category_string =~ /<option value="[0-9]+">[^<]*/ig);
    warn "cannot find categories in $category_string" if not @categories;
    my %c;

    foreach (@categories) {
	m/"([0-9]*)"/
	  or die "cannot find number in category $_";
	my $categoryId = $1;
	m/>(.*)/
	  or die "cannot find description in category $_";
	my $categoryDesc = $1;
	#print STDERR "Found Category: $categoryId CategoryDesc: $categoryDesc\n";
	my $cast;

	$c{$categoryId} = $categoryDesc;
    }

    return %c;
}

# Function which will locate all the available dates and return a list
# of Date::Manip objects, one for each day.
#
# (I was tempted to make this a hash (so you could say $available{$d}
# to see if a day exists) but string equality is a bit dirty for
# comparing two Date::Manip objects.  There needs to be a tied hash
# class which can use a specified equality operation.)
#
sub get_available_dates() {
    my @r;
    my $data = get_url("$BASE_URL/jsp/listings_search.jsp");
    $data =~ s/\n//g;
    $data =~ /<select name="searchDate"[^>]*?>(.*?)<\/select>/
      or die "cannot find searchDate string in HTML $data";
    local $_ = $1;
    s/&nbsp;/ /g;
    s/\s+/ /g;
    s/^\s*//;
    t 'date string: ' . d $_;
    while (length) {
	if (not s!<option value="(\d\d)/(\d\d)/(\d{4})" ?(?:selected)?>([^<]+)!!) {
	    warn "remnant junk in date string: $_";
	    return @r;
	}

	my $parsed_val = ParseDate("$3-$2-$1");
	die "cannot parse option value $1/$2/$3"
	  if not defined $parsed_val;

	# Paranoia, or 'use all the information'.
	my $parsed_text = ParseDate($4);
	if (defined $parsed_text) {
	    warn "dates '$1/$2/$3' and '$4' from same option differ"
	      if Date_Cmp($parsed_val, $parsed_text);
	}
	else {
	    warn "cannot parse option text $4";
	}

	push @r, $parsed_val;
    }
    return @r;
}


# Function which will locate all the programes in a category
# (at a given date and time)
# will return a hash with "chanIDProgID" as the key
#
# Parameters:
#   (reference to) list of XMLTV ids of channels to search
#   Date::Manip object giving date and time
#   (reference to) hash of categories
#
# I think this searches $TIME_INTERVAL time starting from the time
# given.
#
sub get_progs_in_cat( $$$ ) {
    my @channels_to_search = map { xmltv_to_rt($_) } @{shift()};
    my $time = shift;
    use vars '%categories'; local *categories = shift;

    my %cats;

    # For each category find all the programmes in that category
    foreach my $category (keys %categories) {
	my $url = "$BASE_URL/ListingsServlet?event=7&";
	$url .= 'jspGridLocation=%2Fjsp%2Ftv_listings_grid.jsp&';
	$url .= 'jspListLocation=%2Fjsp%2Ftv_listings_list.jsp&';
	$url .= 'jspError=%2Fjsp%2Ferror.jsp&';
	$url .= 'channels=' . join(',', @channels_to_search) . '&';
	$url .= "genres=$category&";
	$url .= 'searchDate=' . UnixDate($time, '%d/%m/%Y') . '&';
	$url .= 'searchTime=' . UnixDate($time, '%R');
	#print STDERR "$url\n";
	my $data = get_url($url);
	$data =~ s/\n//g;

	my @results = ($data =~ /<!-- start of a result -->.*?<!-- end of a result -->/ig);
	warn "cannot find results in $data" if not @results;

	#print STDERR "$category $searchDate $searchTime\n";

	foreach (@results) {

	    /channelId=([0-9]+)/
	      or die "cannot find channelId= in $_";
	    my $channelId = $1;

	    /programmeId=([0-9]+)/
	      or die "cannot find programmeId= in $_";
	    my $programmeId = $1;

	    $cats{"$channelId$programmeId"} = $category;
	    #print STDERR "ChannelId:$channelId ProgrammeId:$programmeId\n";
	}
    }
    return %cats;
}

sub rt_to_xmltv( $ ) {
    my $n = shift;
    if (not defined $rt_to_xmltv{$n}) {
	my $new = "$n.$DOMAIN";
	die "channel id $new already exists" if defined $xmltv_to_rt{$new};
	$rt_to_xmltv{$n} = $new;
	$xmltv_to_rt{$new} = $n;
    }
    return $rt_to_xmltv{$n};
}
sub xmltv_to_rt( $ ) {
    my $x = shift;
    for ($xmltv_to_rt{$x}) {
	die "no RT id known for $x" if not defined;
	return $_;
    }
}


# Ask the user which channels to download, and write $CONFIG_FILE.
#
# Uses global %channels hash.
#
# FIXME commonize the whole damn configure routine with tv_grab_uk!
#
sub configure() {
#    local $Log::TraceMessages::On = 1;
    # FIXME need to make directory
    open(CONF, ">$CONFIG_FILE") or die "cannot write to $CONFIG_FILE: $!";
    my %chose_ch;
    t 'channels: ' . d \%channels;

    # For now we just let the user pick among the 'standard' channels.
    for (;;) {
	print "Enter the name of a channel, or '.' to finish: ";
	my $in = <STDIN>;
	$in =~ s/^\s+//; $in =~ s/\s+$//;
	last if $in eq '.';

	# FIXME commonize this matching by display name.  To do that I
	# think you'd have to eliminate the silly Ananova_Channel
	# stuff from tv_grab_uk and just use ordinary channel hashes.
	#
	my @poss;
      CH: foreach my $k (sort keys %channels) {
	    my $ch = $channels{$k};
	    my $dns = $ch->{'display-name'};
	    unless ($dns and @$dns) {
		warn "channel with id $ch->{id} has no display name, so cannot be configured\n";
		next CH;
	    }
	    foreach (map { $_->[0] } @$dns) {
		if (/$in/i) {
		    push @poss, $ch;
		    next CH;
		}
	    }
	}

	# We only matched based on display names, so we can assume
	# that each possible channel has at least one.
	#
	if (@poss == 0) {
	    print "No channel matching that.\n";
	}
	elsif (@poss == 1) {
	    my $ch = $poss[0];
	    if (askBooleanQuestion('Add channel ' .
				   $ch->{'display-name'}->[0]->[0] . '?', 1)) {
		my $xmltv_id = $ch->{id};
		unless ($chose_ch{$xmltv_id}++) {
		    print CONF "channel $xmltv_id\n";
		}
	    }
	}
	elsif (1 <= @poss and @poss < 25) {
	    my %dn_to_ch;
	    foreach (@poss) {
		my $dn = $_->{'display-name'}->[0]->[0];
		warn "more than one channel called $dn"
		  if exists $dn_to_ch{$dn};
		$dn_to_ch{$dn} = $_;
	    }
	    my $none_option = 'None of the above are what I wanted';
	    die 'silly channel name' if exists $dn_to_ch{$none_option};
	    my $r = askQuestion('Which channel to add?',
				$poss[0]->{'display-name'}->[0]->[0],
				(sort keys %dn_to_ch), $none_option);
	    next if $r eq $none_option;
	    my $ch = $dn_to_ch{$r}; die if not defined $ch;
	    my $xmltv_id = $ch->{id};
	    unless ($chose_ch{$xmltv_id}++) {
		print CONF "channel $xmltv_id\n";
	    }
	}
	elsif (25 <= @poss) {
	    print "'$in' matches lots of channels, be more specific.\n";
	}
	else { die }
    }

    close CONF or warn "cannot close $CONFIG_FILE: $!";
    print "All done, run with no arguments to grab a week's listings.\n";
    exit();
}
