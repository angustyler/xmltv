#!/usr/bin/perl -w

use IO::Socket;
use strict;
use Time::ParseDate;
use LWP::Simple;
use XMLTV;
use Date::Manip;
use Getopt::Long;

# Use Log::TraceMessages if installed.
BEGIN {
    eval { require Log::TraceMessages };
    if ($@) {
	*t = sub {};
	*d = sub { '' };
    }
    else {
	*t = \&Log::TraceMessages::t;
	*d = \&Log::TraceMessages::d;
	Log::TraceMessages::check_argv();
    }
}

# GLOBAL CONSTANTS
my $TIME_INTERVAL = 120;
my $MAX_RETRYS = 3;
my $LANG = "en";
my $host="www.radiotimes.beeb.com";
my $domain = $host; $domain =~ s/^www\.//;

# Whether to fetch categories (makes everything slower)
my $GET_CATEGORIES = 0;

my %ch_to_output =
  (
   '39' => 'animalplanet.discoveryeurope.com', # Animal Planet (Digital)
   '92' => 'south-east.bbc1.bbc.co.uk', # BBC1 South East
   '105' => 'south-east.bbc2.bbc.co.uk', # BBC2 South East
   '45' => 'choice.bbc.co.uk',	# BBC Choice
   '47' => 'knowledge.bbc.co.uk', # BBC Knowledge
   '48' => 'news-24.bbc.co.uk', # BBC News 24
   '49' => 'parliament.bbc.co.uk', # BBC Parliament
   '123' => 'british.eurosport.com', # British Eurosport
   '26' => 'carlton.com',	# Carlton
   '127' => 'cinema.carlton.com', # Carlton Cinema
   '132' => 'channel4.com',	# Channel 4
   '134' => 'channel5.co.uk',	# Channel 5
   '147' => 'discoveryeurope.com', # Discovery (Digital)
   '158' => 'e4.channel4.com',	# E4
   '160' => 'filmfour.channel4.com', # Film on Four
   '177' => 'plus.granadatv.co.uk', # Granada Plus
   '182' => 'thehistorychannel.co.uk', # History Channel (Digital)
   '185' => 'itv2.itv.co.uk',	# ITV2
   '213' => 'nationalgeographic.co.uk', # National Geographic (Digital)
   '224' => 'paramountcomedy.com', # Paramount Comedy
   '225' => 'performancetv.co.uk', # Performance
   '248' => 'sky-one.sky.com',	# Sky One
   '252' => '2.moviemax.sky.com', # Sky Moviemax 2
   '253' => '3.moviemax.sky.com', # Sky Moviemax 3
   '254' => '4.moviemax.sky.com', # Sky Moviemax 4
   '255' => '5.moviemax.sky.com', # Sky Moviemax 5
   '251' => 'moviemax.sky.com', # Sky Moviemax
   '249' => 'cinema.sky.com',	# Sky Cinema (Digital)
   '248' => 'ondigital.sky-one.sky.com', # Sky One (Ondigital)
   '258' => '2.premier.sky.com', # Sky Premier 2
   '259' => '3.premier.sky.com', # Sky Premier 3
   '260' => '4.premier.sky.com', # Sky Premier 4
   '257' => 'ondigital.premier.sky.com', # Sky Premier - Ondigital
   '261' => 'widescreen.premier.sky.com', # Sky Premier - Widescreen
   '264' => '2.sports.sky.com', # Sky Sports 2
   '265' => '3.sports.sky.com', # Sky Sports 3
   '250' => '2.cinema.sky.com', # Sky Cinema 2
   '262' => '1.sports.sky.com', # Sky Sports 1 (ITV Digital)
   '119' => 'biography-channel.biography.com', # Biography Channel
   '40' => 'artsworld.com',	# Artsworld
   '283' => 'studio.com',	# Studio
   '271' => 'tcm.turner.com',	# TCM (Digital)
   '292' => 'uk-drama.flextech.telewest.co.uk', # UK Drama
   '288' => 'uk-gold.flextech.telewest.co.uk', # UK Gold
   '290' => 'uk-horizons.flextech.telewest.co.uk', # UK Horizons
   '272' => 'wcw.tcm.turner.com ' # TCM/WCW
  );

# get the channel options. Channels can be entered as a commar separated list
#     eg 92,105
# if no channels are specifed then listings for terestrial channels will be fetched
# if 'ALL' is specified then all available channels will be fetched

# default channels are BBC1, BBC2, Carlton, Channel 4, Channel 5
my @DEFAULT_CHANS = (92,105,26,132,134);

print STDERR "Finding Channels:";
my %channels = get_channels();
print STDERR "\n";

my @channels_specified = ();
my @channels_to_get = ();
my @dates_specified = ();
my @dates_to_get = ();

GetOptions ("dates:s" => \@dates_specified, "channels:s" => \@channels_specified);
@channels_specified = split(/,/,join(',',@channels_specified));
foreach (@channels_specified) {
    if (m/ALL/) {
	# Get all available channels
	foreach (keys %channels) {
	    push (@channels_to_get, $_);
	}
    }
    if (m/^[0-9]*$/) {
	push (@channels_to_get, $_);
    }
}
#push (@channels_to_get, @channels_specified);

unless (@channels_specified) {
    push (@channels_to_get, @DEFAULT_CHANS);
}

my $channels_to_get_string = "";
foreach my $chan (@channels_to_get) { $channels_to_get_string .= "$chan,"; }
$channels_to_get_string =~ s/,$//;


# Get the dates options. Dates can be specified as a commar sperated list
#     eg 03/02/2002,04/02/2002
# if no dates are specifed then todays listings will be fetched
# if 'ALL' is specified then all available dates will be specifed
# if 'LATEST' is specified the listings for the latest available  day
# will be fetched

@dates_specified = split(/,/,join(',',@dates_specified));
foreach (@dates_specified) {
	if (m/ALL/) {
		print STDERR "Finding available dates:";
		my @available_dates = get_available_dates ();
		print STDERR "\n";
		push (@dates_to_get, @available_dates);
	}
	if (m/LATEST/) {
		print STDERR "Finding available dates:";
                my @available_dates = get_available_dates ();
                print STDERR "\n";
		my $latest_date = pop @available_dates;
		push (@dates_to_get, $latest_date);
	}
	if (m/^[0-9]{2}\/[0-9]{2}\/[0-9]{4}$/) {
		push (@dates_to_get, $_);
	}
}
#push (@dates_to_get, @dates_specified);

unless (@dates_specified) { 
	# Get todays date
	Date_Init('TZ=UT');
	my $today = ParseDate('today'); die if not defined $today;
	$today =~ s/^([0-9]{4})([0-9]{2})([0-9]{2}).*$/$3\/$2\/$1/i;
	push (@dates_to_get, $today);
}

# set up the XML writer
my $writer = new XMLTV::Writer(encoding => 'ISO-8859-1');
$writer->start({ 'source-info-url'     =>
          'http://http://www.radiotimes.co.uk/',
                 'source-info-name'    => 'RadioTimes',
                 'source-data-url'     => "",
                 'generator-info-name' => 'XMLTV/0.4',
                 'generator-info-url'  =>
          'http://membled.com/work/apps/xmltv/',
               });


# Find all the categories
print STDERR "Finding Categories:";
my %categories = get_categories ();
print STDERR "\n";

# Find all the programes on the channels
my %prog_to_cat;
my %encounted_progs;

# get the listings for each date
my @programmes;
foreach my $date (@dates_to_get) {


	# Create the time string according to the TIME_INTERVAL 
	my $hrs = 0;
	my $mns = 0;
	while ($hrs < 24) {
		my $time_str = "$hrs:$mns";
		$time_str =~ s/^([0-9]:)/0$1/;
		$time_str =~ s/:([0-9])$/:0$1/;
		$mns += $TIME_INTERVAL;
        	$hrs += $mns / 60;
        	$mns = $mns % 60;

		# first find all the new programmes for this time slot
		my @new_programmes;

		foreach my $chan (@channels_to_get) {
                	print STDERR "Finding the programmes on $chan at $date $time_str:";
                	my @this_chan_new_programmes = get_programmes($chan,$date,$time_str);
                	push (@new_programmes, @this_chan_new_programmes);
                	print STDERR "\n";
        	}

		# Next find all the programes in each category (if there are new progs
		# FIX ME we dont need to check all channels only those with new progs
		# FIX ME we also need to check if there are more than 100 results and
		# search over less channels
		if (@new_programmes) {
		    if ($GET_CATEGORIES) {
			print STDERR "Finding the categories for $channels_to_get_string at $time_str:";
			%prog_to_cat =
			get_progs_in_cat($channels_to_get_string,$date,$time_str); 
			print STDERR "\n";
		    }
		}

		#foreach my $chan (@channels_to_get) {
		#        print STDERR "Finding the programmes on $chan at $time_str:";
        	#	my @new_programmes = get_programmes($chan,$date,$time_str);
        	#	push (@programmes, @new_programmes);
        	#	print STDERR "\n";
		#}
	
		# Set the category for each new programme 
		foreach my $new_prog (@new_programmes) {
			my $channelId = $new_prog->{chanID};
			my $programmeId = $new_prog->{progID};
			if ($GET_CATEGORIES) {
			    my $cat_ID = $prog_to_cat{"$channelId$programmeId"};
			    my $cat = $categories{$cat_ID};
			    if (defined $cat) {
				push @{$new_prog->{category}}, [ lc $cat ];
			    }
			    else {
				warn "unknown category id $cat\n";
			    }
			}

		}

		# push the new channels into the completlist
		push (@programmes, @new_programmes);
	} 
}

# write out the xml
# write out the channels
$writer->write_channels(\%channels);

#write out the programmes
foreach (@programmes) {
        $writer->write_programme($_);
}
$writer->end();

exit;




# Function to get a url 
sub get_url {
	my $url= shift;
	my $data;
	my $trys = 0;
	
	while ((!$data) and ($trys < $MAX_RETRYS)) {
		($data = get $url) or $trys++;
		print STDERR "#";
	}
	
	return $data;
}

sub human_date {
#
# produce a human readable date string
# Usage human_date($seconds_since_epoch)
#
        my $date = shift;
        my ($year,$month,$day,$hour,$minute,$second) 
			= (localtime($date))[5,4,3,2,1,0];
        $year += 1900;
	$month++;
        return sprintf "%2.2d%2.2d%2.2d%2.2d:%2.2d:%2.2d",
			$year,$month,$day,$hour,$minute,$second;
}

# Function to find all the programmes on a channel (at a given date + time)
sub get_programmes {
	my $channelId = shift;
	my $searchDate = shift;
	my $searchTime = shift;

	my @p;

	my $url = "http://$host/ListingsServlet?event=4&";
        $url .= "jspGridLocation=%2Fjsp%2Ftv_listings_grid.jsp&";
        $url .= "jspListLocation=%2Fjsp%2Ftv_listings_single.jsp&";
        $url .= "jspError=%2Fjsp%2Ferror.jsp&";
        $url .= "searchDate=$searchDate&";
        $url .= "searchTime=$searchTime&";
        $url .= "channels=$channelId";
	my $data = get_url($url);

	$data =~ s/\n//g;

	my @results = ($data =~ m/<!-- start of a result -->.*?<!-- end of a result -->/ig);

	# print STDERR "$channelId $searchDate $searchTime\n";

	foreach (@results) {

        	m/programmeId=([0-9]+)/;
        	my $programmeId = $1;
	
		unless ($encounted_progs{"$channelId$programmeId"}) {
			$encounted_progs{"$channelId$programmeId"} = 1;

			#print STDERR "ChannelId:$channelId ProgrammeId:$programmeId\n";
		
			my %r = get_programme_details ($channelId, $programmeId);
	
			push @p, \%r;
		}
	}
	return @p;
}

# Function to parse the HTML and get all the info we need
sub get_programme_details {

	my $channelId = shift;
	my $programmeId = shift;

	my %p;
	$p{channel} = chan_to_output($channelId);
	$p{chanID} = $channelId;
	$p{progID} = $programmeId;
	if ($GET_CATEGORIES) {
	    my $cat_ID = $prog_to_cat{"$channelId$programmeId"};
	    my $cat = $categories{$cat_ID};
	    push @{$p{category}}, [ lc $cat ];
	}

	my $url = "http://$host/ListingsServlet?event=10&";
        $url .= "channelId=$channelId&";
        $url .= "programmeId=$programmeId&";
        $url .= "jspLocation=/jsp/prog_details.jsp";
	my $prog_details_string = get_url($url);
	$prog_details_string  =~ s/\n//g;
	$prog_details_string  =~ m/\/\/-->(.*?)<!-- end main table -->/;
	my $prog_details = $1;
	#chop off anything before //-->
	$prog_details =~ s/.*\/\/-->//;
	#get rid of the tag which messes things up
	$prog_details =~ s/<!--.*?-->/\|/g;
	# replace html tags with pipes
	$prog_details =~ s/<[ ]*[^0-9][^>]*?>/\|/g;
	#replace multiple spaces
	$prog_details =~ s/\s+/ /g;
	#replace pipe followed by space
	$prog_details =~ s/\|\s/\|/g;
	#replace multiple pipes
	$prog_details =~ s/\|+/\|/g;
	$prog_details =~ s/&nbsp;//g;

	# chop of related features or related websites
	$prog_details =~ s/Related Features\|.*//;
	$prog_details =~ s/Related Websites\|.*//;

	$prog_details =~ m/ \|(.*?)\|Channel:/;
	my $title = $1;

	my $sub_title;
	if ($title =~ s/\|(.*)//) {$sub_title = $1;}
	
	$p{title} = [ [ $title, $LANG ] ];

	$prog_details =~ m/Channel:\|(.*?)\|/;
	my $channel_name = $1;

	$prog_details =~ m/Date:\|.*? ([0-9]*? .*?)\|/;
	my $date = $1;

	$prog_details =~ m/Time:\|([0-9,a,m,p,:]*) to ([0-9,a,m,p,:]*)/;
        my $start_time = $1;
	my $stop_time = $2;
	my $start = parsedate("$date $start_time");
	my $stop = parsedate("$date $stop_time");
	
	# Some programmes have thir stop time on the next day
        if (($start_time =~ m/pm$/) and ($stop_time =~ m/am$/)) {$stop += 86400;}

	my $start_string = human_date($start);
	my $stop_string = human_date($stop);

	$p{start} = $start_string;
	$p{stop} = $stop_string;

	#chop of all the stuff we have parsed
	$prog_details =~ s/.*Time:\|$start_time to $stop_time\|//;

	my ($options,$subtitles,$widescreen,$repeat,$black_and_white,
	    $certificate,$episode,$review,$director,$filmed_in,$cast);

	if ($prog_details =~ m/(.*?)\|/) {
	    $options = $1;
	    if ($options eq "Review") {$options ='';}
	    if ($options eq "Episode") {$options ='';} 
	    if ($options eq "Certificate:") {$options ='';}
	    
	    if ($options =~m/Subtitled/) {
		$subtitles = "yes";
		$p{subtitles} = [ { type => 'teletext' } ];
	    }
	    if ($options =~m/Widescreen/) {
		$widescreen = "yes";
		$p{widescreen} = "yes";
	    }
	    if ($options =~m/Repeat/) {
		$repeat = "yes";
		$p{'previously-shown'} = {}
	    }
	    if ($options =~m/Black and White/) {
		$black_and_white = "yes";
		$p{video}{present} = 1;
	    	$p{video}{colour} = 0;
	    }

	    $prog_details =~ s/$options\|//;
	}
	
	if ($prog_details =~ m/Certificate:\|\[(.*?)\]\|/) {
		$certificate = $1;
		$p{'certificate'} = $1;
	}
		
	# episode corresponds to badly named 'sub -title'
	if ($prog_details =~ m/Episode\|(.*?)\|/) {
		$episode = $1;
		$p{'sub-title'} = [ [ $1, $LANG ] ];
	}
		
	# Review corresponds to description
	if ($prog_details =~ m/Review\|(.*?)\|/) {
		$review = $1;
		$p{desc} = [ [ $1, $LANG ] ];
	}

	#chop of all the stuff we have parsed
	$prog_details =~ s/.*Certificate:\|(.*?)\|//;
	$prog_details =~ s/.*Episode\|(.*?)\|//;
        $prog_details =~ s/.*Review\|(.*?)\|//;

	if ($prog_details =~ m/Directed by:\|(.*?)\|/) {
		$director = $1; 
		push @{$p{credits}{director}}, $1;
	}
	if ($prog_details =~ m/Filmed in:\|(.*?)\|/) {
		$filmed_in = $1;$p{'filmed-in'} = $1;
	}
	if ($prog_details =~ m/Cast List\|(.*)/) {
		$cast = $1;
		$cast =~ s/\s*\|$//;
		
		if ($cast =~ m/\|\.\.\.\.\.\|/) {
			$cast =~ s/(\|\.\.\.\.\.)+/\@/;
			#$cast =~ s/\@+/\@/g;
			my @splitter = split /\@\|/, $cast;
			my $roles_string = shift @splitter;
			my $names_string = shift @splitter;
			my @act_roles = split /\|/, $roles_string;
			my @act_names = split /\|/, $names_string;
			$cast = "";
			foreach my $act_name (@act_names) {
				my $act_role = shift @act_roles;
				$cast .= "|$act_name,$act_role";
			}
			$cast =~ s/^\|//;

			
		}
		else { 
			$cast =~ s/\|/,actor\|/g;
			$cast =~ s/,/,actor\|/g;
			$cast =~ s/\|\s/\|/g;
			$cast =~ s/$/,actor/;
		}

		my @cast_list = split /\|/, $cast;
		foreach (@cast_list) {
		    m/^([^,]*),([^,]*)$/;
		    my $name = $1;
		    my $role = $2;
		    
		    # FIXME The XMLTV doesnt seem to allow anything but actor or 
		    # director so we must just ignore role for now
		    push @{$p{credits}{actor}}, $name;
		}
	    }

	#print STDERR "Title: $title\n";
	#print STDERR "Sub Title: $sub_title\n";
	#print STDERR "Channel: $channel_name\n";
	#print STDERR "Date: $date\n";
	#print STDERR "Start: $start_string\n";
	#print STDERR "Stop: $stop_string\n";
	#print STDERR "Subtitles: $subtitles\n";
        #print STDERR "WideScreen: $widescreen\n";
        #print STDERR "Repeat: $repeat\n";
	#print STDERR "Black and White: $black_and_white\n";
	#print STDERR "Certificate: $certificate\n";
	#print STDERR "Episode: $episode\n";
	#print STDERR "Review: $review\n";
	#print STDERR "Directed By: $director\n";
	#print STDERR "Filmed in: $filmed_in\n";
	#print STDERR "Cast List: $cast\n";
	#print STDERR "\n";
	
	return %p;
}

# Function which will locate all the available channels and return a hash
# with channelId as the key and a chanel description
sub get_channels {
	my $data = get_url("http://$host/");
	$data =~ s/\n//g;
	$data =~ m/<select name="channels"[^>]*?>(.*?)<\/select>/;
	my $channel_string = $1;
	$channel_string =~ s/\s+/ /g;
	my @channels = ($channel_string =~ m/<option value="[0-9]+" >[^<]*/ig);
	my %c;
	
	foreach (@channels) {
		m/"([0-9]*)"/;
		my $channelId = $1;
		m/>(.*)/;
		my $channelDesc = $1;
		# print  STDERR "Found Channel: ChannelId: $channelId"; 
		# print  STDERR " ChannelDes: $channelDesc\n";
		my $chanID_to_output = chan_to_output($channelId);
		die if not defined $chanID_to_output;
		die if not defined $domain;
		die if not defined $channelId;
		$c{$chanID_to_output}
		  = { 'display-name' => [ [ $channelDesc, $LANG ] ],
		      'id' => "$channelId.$domain" };
	}

	return %c;
}

# Function which will locate all the available categories and return a hash
# with categoryId as the key and a category description
sub get_categories {
	my $data = get_url("http://$host/jsp/listings_search.jsp");
	$data =~ s/\n//g;
	$data =~ m/<select name="genres"[^>]*?>(.*?)<\/select>/;
	my $category_string = $1;
	$category_string =~ s/\s+/ /g;
	my @categories = 
		($category_string =~ m/<option value="[0-9]+">[^<]*/ig);
	my %c;

	foreach (@categories) {
        	m/"([0-9]*)"/;
        	my $categoryId = $1;
        	m/>(.*)/;
        	my $categoryDesc = $1;
        	#print STDERR "Found Category: $categoryId CategoryDesc: $categoryDesc\n";
	my $cast;

		$c{$categoryId} = $categoryDesc;
	}

	return %c;
}

# Function which will locate all the available dates and return a list 
sub get_available_dates {
        my $data = get_url("http://$host/jsp/listings_search.jsp");
        $data =~ s/\n//g;
        $data =~ m/<select name="searchDate"[^>]*?>(.*?)<\/select>/;
        my $dates_string = $1;
        $dates_string =~ s/\s+/ /g;
        my @dates =
                ($dates_string =~ m/[0-9]{2}\/[0-9]{2}\/[0-9]{4}/ig);
        return @dates;
}


# Function which will locate all the programes in a category 
# (at a given date and time)
# will return a hash with "chanIDProgID" as the key 
sub get_progs_in_cat {
	my $channels_to_search = shift;
        my $searchDate = shift;
        my $searchTime = shift;

	my %cats;
	
	# For each category find all the programmes in that category
	foreach my $category (keys %categories) {
		my $url = "http://$host/ListingsServlet?event=7&";
                $url .= "jspGridLocation=%2Fjsp%2Ftv_listings_grid.jsp&";
                $url .= "jspListLocation=%2Fjsp%2Ftv_listings_list.jsp&";
                $url .= "jspError=%2Fjsp%2Ferror.jsp&";
                $url .= "channels=$channels_to_search&";
                $url .= "genres=$category&";
                $url .= "searchDate=$searchDate&";
                $url .= "searchTime=$searchTime";
		my $data = get_url($url);
        
                #print STDERR "$url\n";

		$data =~ s/\n//g;
	
		my @results = ($data =~ m/<!-- start of a result -->.*?<!-- end of a result -->/ig);

		#print STDERR "$category $searchDate $searchTime\n";

        	foreach (@results) {

                	m/channelId=([0-9]+)/;
                	my $channelId = $1;

                	m/programmeId=([0-9]+)/;
                	my $programmeId = $1;

			$cats{"$channelId$programmeId"} = $category;
                	#print STDERR "ChannelId:$channelId ProgrammeId:$programmeId\n";
        	}
	}
	return %cats;
}

sub chan_to_output() {
    my $n = shift;
    if (not defined $ch_to_output{$n}) {
	$ch_to_output{$n} = "$n.radiotimes.beeb.com";
    }
    return $ch_to_output{$n};
}

