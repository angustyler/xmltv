#!/usr/bin/perl -w

use strict;
use IO::Socket;
use LWP::Simple;
use Date::Manip;
use Getopt::Long;
use XMLTV;
use XMLTV::Memoize;
use XMLTV::Ask;
use XMLTV::Usage <<END
To configure: $0 --configure [--config-file FILE]
To grab listings: $0 [--config-file FILE] [--output FILE] [--days N]
END
  ;

# Use Log::TraceMessages if installed.
BEGIN {
    eval { require Log::TraceMessages };
    if ($@) {
	*t = sub {};
	*d = sub { '' };
    }
    else {
	*t = \&Log::TraceMessages::t;
	*d = \&Log::TraceMessages::d;
	Log::TraceMessages::check_argv();
    }
}

sub get_url( $ );
sub human_date( $ );
sub get_programmes( $$$$ );
sub get_programme_details( $$$$ );
sub get_channels();
sub get_categories();
sub get_available_dates();
sub get_progs_in_cat( $$$ );
sub rt_to_xmltv( $ );
sub xmltv_to_rt( $ );
sub grab( @ );
sub configure();

# GLOBAL CONSTANTS
my $TIME_INTERVAL = 120;
my $LANG = 'en';
my $DOMAIN = 'radiotimes.beeb.com';
my $BASE_URL = "http://www.$DOMAIN";

# Whether to fetch categories (makes everything slower)
my $GET_CATEGORIES = 0;

# Tables to convert between Radio Times and XMLTV ids of channels.
# The way to access these is through the routines rt_to_xmltv() and
# xmltv_to_rt(), not directly.  Those will deal sensibly with a new RT
# channel that isn't mentioned here.
#
my %rt_to_xmltv =
  (
   26  => 'carlton.com',                         # Carlton
   39  => 'animalplanet.discoveryeurope.com',    # Animal Planet (Digital)
   40  => 'artsworld.com',                       # Artsworld
   45  => 'choice.bbc.co.uk',                    # BBC Choice
   47  => 'knowledge.bbc.co.uk',                 # BBC Knowledge
   48  => 'news-24.bbc.co.uk',                   # BBC News 24
   49  => 'parliament.bbc.co.uk',                # BBC Parliament
   92  => 'south-east.bbc1.bbc.co.uk',           # BBC1 South East
   105 => 'south-east.bbc2.bbc.co.uk',           # BBC2 South East
   119 => 'biography-channel.biography.com',     # Biography Channel
   123 => 'british.eurosport.com',               # British Eurosport
   127 => 'cinema.carlton.com',                  # Carlton Cinema
   132 => 'channel4.com',                        # Channel 4
   134 => 'channel5.co.uk',                      # Channel 5
   147 => 'discoveryeurope.com',                 # Discovery (Digital)
   158 => 'e4.channel4.com',                     # E4
   160 => 'filmfour.channel4.com',               # Film on Four
   177 => 'plus.granadatv.co.uk',                # Granada Plus
   182 => 'thehistorychannel.co.uk',             # History Channel (Digital)
   185 => 'itv2.itv.co.uk',                      # ITV2
   213 => 'nationalgeographic.co.uk',            # National Geographic (Digital)
   224 => 'paramountcomedy.com',                 # Paramount Comedy
   225 => 'performancetv.co.uk',                 # Performance
   248 => 'ondigital.sky-one.sky.com',           # Sky One (Ondigital)
   248 => 'sky-one.sky.com',                     # Sky One
   249 => 'cinema.sky.com',                      # Sky Cinema (Digital)
   250 => '2.cinema.sky.com',                    # Sky Cinema 2
   251 => 'moviemax.sky.com',                    # Sky Moviemax
   252 => '2.moviemax.sky.com',                  # Sky Moviemax 2
   253 => '3.moviemax.sky.com',                  # Sky Moviemax 3
   254 => '4.moviemax.sky.com',                  # Sky Moviemax 4
   255 => '5.moviemax.sky.com',                  # Sky Moviemax 5
   257 => 'ondigital.premier.sky.com',           # Sky Premier - Ondigital
   258 => '2.premier.sky.com',                   # Sky Premier 2
   259 => '3.premier.sky.com',                   # Sky Premier 3
   260 => '4.premier.sky.com',                   # Sky Premier 4
   261 => 'widescreen.premier.sky.com',          # Sky Premier - Widescreen
   262 => '1.sports.sky.com',                    # Sky Sports 1 (ITV Digital)
   264 => '2.sports.sky.com',                    # Sky Sports 2
   265 => '3.sports.sky.com',                    # Sky Sports 3
   271 => 'tcm.turner.com',                      # TCM (Digital)
   272 => 'wcw.tcm.turner.com',                  # TCM/WCW
   283 => 'studio.com',                          # Studio
   288 => 'uk-gold.flextech.telewest.co.uk',     # UK Gold
   290 => 'uk-horizons.flextech.telewest.co.uk', # UK Horizons
   292 => 'uk-drama.flextech.telewest.co.uk',    # UK Drama
  );
my %xmltv_to_rt = reverse %rt_to_xmltv;

# Check options.  First do the undocumented --cache option (to cache
# get(), which retrieves web pages), then the normal ones.
#
my $using_cache = XMLTV::Memoize::check_argv('get');
my ($opt_days, $opt_help, $opt_output, $opt_share,
    $opt_configure, $opt_config_file);
# No default for $opt_days, we determine it from the site.
GetOptions('days=i'        => \$opt_days,
	   'help'          => \$opt_help,
	   'configure'     => \$opt_configure,
	   'config-file=s' => \$opt_config_file,
	   'output=s'      => \$opt_output,
	   'share=s'       => \$opt_share, # also undocumented
	  )
  or usage(0);
die 'number of days must not be negative'
  if (defined $opt_days && $opt_days < 0);
if ($opt_help) {
    usage(1);
}
if ($opt_configure) {
    print STDERR "Going to configure channels to download, please wait\n";
}
die if defined $opt_share; # TODO
die if defined $opt_output; # TODO

# File that stores which channels to download.
my $CONFIG_FILE = $opt_config_file;
my $PROGNAME = 'tv_grab_uk_rt'; # too confusing to use $0
if (not defined $CONFIG_FILE) {
    if (defined($ENV{HOME})) {
	my $conf_dir = "$ENV{HOME}/.xmltv";
	(-d $conf_dir) or mkdir($conf_dir, 0777)
	  or die "cannot mkdir $conf_dir: $!";
	$CONFIG_FILE = "$conf_dir/$PROGNAME";
    }
    else {
	# $HOME not set, use current directory.
	$CONFIG_FILE = $PROGNAME;
    }
}

if ($opt_configure) {
    if (-e $CONFIG_FILE) {
	print <<END
The configuration file $CONFIG_FILE already exists.  There is
currently no support for altering an existing configuration, you have
to reconfigure from scratch.

END
  ;
	if (not askBooleanQuestion
	    ('Do you wish to overwrite the old configuration?', 0)) {
	    print "Exiting.\n";
	    exit 0;
	}
    }
}
else {
    if (-e $CONFIG_FILE) {
	print STDERR "using config file $CONFIG_FILE\n";
    }
    else {
	die "config file $CONFIG_FILE does not exist, run me with --configure\n";
    }
}

print STDERR 'Finding Channels:';
my %channels = get_channels();
print STDERR "\n";

if ($opt_configure) {
    configure();
}
else {
    my %g_args = ();
    if (defined $opt_output) {
	my $fh = new IO::File ">$opt_output";
	die "cannot write to $opt_output\n" if not $fh;
	%g_args = (OUTPUT => $fh);
    }
    grab(%g_args);
}
exit();

# Grab listings and write them in XML.  Arguments are to be passed to
# XMLTV::Writer (but encoding is always ISO-8859-1).
#
sub grab( @ ) {
    my $writer = new XMLTV::Writer(@_, encoding => 'ISO-8859-1');
    my %write_channels;		# to be written as <channel> elements

    # Read the configuration file.  At present the lines must be one
    # of two forms:
    #
    # channel <xmltv id>
    # ALL
    #
    open(CONF, $CONFIG_FILE)
      or die "cannot read $CONFIG_FILE: $!\n";
    while (<CONF>) {
	s/\#.*//; s/^\s+//; s/\s+$//;
	next if not length;
	t "got line from config file: $_";
	if ($_ eq 'ALL') {
	    %write_channels = %channels;
	}
	elsif (/^channel\s+(.+)/) {
	    my $xmltv_id = $1;
	    if (not defined $channels{$xmltv_id}) {
		warn "$CONFIG_FILE:$.: no channel with XMLTV id $xmltv_id, skipping\n";
		next;
	    }
	    $write_channels{$xmltv_id} = $channels{$xmltv_id};
	}
	else { die "$CONFIG_FILE:$.: bad line\n" }
    }

    my @available_dates = get_available_dates();
    t 'available dates: ' . d \@available_dates;
    die 'apparently, there are no days of listings on the site'
      if not @available_dates;
    my $today = ParseDate('today midnight');

    my $is_available = sub( $ ) {
	my $d = shift;
	foreach (@available_dates) {
	    return 1 if not Date_Cmp($d, $_);
	}
	return 0;
    };

    my @dates_to_get;
    for (my $d = $today; $is_available->($d); $d = DateCalc($d, '+ 1 day')) {
	push @dates_to_get, $d;
    }
    die "listings for today ($today) not available" if not @dates_to_get;
    my $last_day = $dates_to_get[-1];
    foreach (@available_dates) {
	if (Date_Cmp($last_day, $_) < 0) {
	    warn "strangely, day $_ is available but there are gaps before it";
	}
    }

    if (defined $opt_days) {
	if ($opt_days > @dates_to_get) {
	    warn 'only ' . (scalar @dates_to_get)
	      . ' days of consecutive listings available';
	}
	else {
	    @dates_to_get = @dates_to_get[0 .. $opt_days - 1];
	}
    }
    my $days = @dates_to_get > 1 ? 'days' : 'day';
    print STDERR 'getting ' . (scalar @dates_to_get) . " $days of listings\n";
    t 'getting dates:' . d \@dates_to_get;

    $writer->start({ 'source-info-url'     => "$BASE_URL/",
		     'source-info-name'    => 'Radio Times',
		     'generator-info-name' => 'XMLTV',
		     'generator-info-url'  =>
		     'http://membled.com/work/apps/xmltv/',
		   });


    # Find all the categories
    print STDERR 'Finding Categories:';
    my %categories = get_categories ();
    print STDERR "\n";

    # Find all the programes on the channels
    my %prog_to_cat;

    # get the listings for each date
    my @programmes;
    foreach my $date (@dates_to_get) {
	# Create the time string according to the TIME_INTERVAL
	my $mns = 0;
	while ($mns < 24 * 60) {
	    my $time = DateCalc($date, "+ $mns minutes");
	    $mns += $TIME_INTERVAL;

	    # first find all the new programmes for this time slot
	    my @new_programmes;

	    foreach my $chan (sort keys %write_channels) {
		t "Finding the programmes on $chan at $time:";
		push @new_programmes, get_programmes($chan, $time, \%prog_to_cat, \%categories);
	    }

	    # Next find all the programes in each category (if there are new progs
	    # FIX ME we dont need to check all channels only those with new progs
	    # FIX ME we also need to check if there are more than 100 results and
	    # search over less channels
	    if (@new_programmes) {
		if ($GET_CATEGORIES) {
		    print STDERR "Finding the categories at $time:";
		    %prog_to_cat =
		      get_progs_in_cat([ sort keys %write_channels ], $time, \%categories);
		    print STDERR "\n";
		}
	    }

	    # Set the category for each new programme
	    foreach my $new_prog (@new_programmes) {
		my $channelId = $new_prog->{_chanID};
		my $programmeId = $new_prog->{_progID};
		if ($GET_CATEGORIES) {
		    my $cat_ID = $prog_to_cat{"$channelId$programmeId"};
		    my $cat = $categories{$cat_ID};
		    if (defined $cat) {
			push @{$new_prog->{category}}, [ lc $cat ];
		    }
		    else {
			warn "unknown category id $cat\n";
		    }
		}
	    }

	    # push the new channels into the completlist
	    push (@programmes, @new_programmes);
	}
    }

    # write out the xml
    # write out the channels
    $writer->write_channels(\%write_channels);

    #write out the programmes
    foreach (@programmes) {
	$writer->write_programme($_);
    }
    $writer->end();
}


# Function to get a url.  This also seems like a sensible place to do
# HTML-demoronizing.  I've removed the automatic retrying because it
# won't interact well with memozing LWP::get() and I'd prefer to be
# warned whenever a page fails to download.  Could add it back later.
#
sub get_url( $ ) {
    my $url = shift;
    for (my $data = get($url)) {
	die "cannot get $url\n" if not defined;
	tr/\222\222\226/''-/;
	# There could be other illegal chars but I haven't seen them.
	return $_;
    }
}


sub human_date( $ ) {
    #
    # produce a human readable date string
    # Usage human_date($seconds_since_epoch)
    #
    my $date = shift; die if not defined $date;
    my ($year,$month,$day,$hour,$minute,$second)
      = (localtime($date))[5,4,3,2,1,0];
    $year += 1900;
    $month++;
    return sprintf '%2.2d%2.2d%2.2d%2.2d:%2.2d:%2.2d',
      $year,$month,$day,$hour,$minute,$second;
}

# Function to find all the programmes on a channel (at a given date +
# time).
#
# Parameters:
#   XMLTV id of channel
#   Date::Manip object giving date and time
#   prog_to_cat hash (see elsewhere for details)
#   categories hash
#
# I think this relies on the page returning exactly $TIME_INTERVAL
# worth of listings.
#
my %encounted_progs;
sub get_programmes( $$$$ ) {
    my $channelId = xmltv_to_rt(shift);
    my $time = shift;
    my $prog_to_cat = shift;
    my $categories = shift;

    my @p;

    my $url = "$BASE_URL/ListingsServlet?event=4&";
    $url .= 'jspGridLocation=%2Fjsp%2Ftv_listings_grid.jsp&';
    $url .= 'jspListLocation=%2Fjsp%2Ftv_listings_single.jsp&';
    $url .= 'jspError=%2Fjsp%2Ferror.jsp&';
    $url .= 'searchDate=' . UnixDate($time, '%d/%m/%Y') . '&';
    $url .= 'searchTime=' . UnixDate($time, '%R') . '&';
    $url .= "channels=$channelId";
    my $data = get_url($url);
    $data =~ tr/\n//d;

    my @results = ($data =~ /<!-- start of a result -->.*?<!-- end of a result -->/ig);
    warn 'no results found in HTML' if not @results;

    # print STDERR "$channelId $searchDate $searchTime\n";

    foreach (@results) {
	m/programmeId=([0-9]+)/ or die "cannot find programmeId= in $_";
	my $programmeId = $1;

	unless ($encounted_progs{"$channelId$programmeId"}) {
	    $encounted_progs{"$channelId$programmeId"} = 1;
	    #print STDERR "ChannelId:$channelId ProgrammeId:$programmeId\n";
	    my %r = get_programme_details($channelId, $programmeId, $prog_to_cat, $categories);
	    push @p, \%r;
	}
    }
    return @p;
}

# Function to parse the HTML and get all the info we need
#
# Parameters:
#   XMLTV id of channel
#   RT id of programme
#   hash mapping 'channelidprogrammeid' to RT category id
#   hash of categories
#
sub get_programme_details( $$$$ ) {
#    local $Log::TraceMessages::On = 1;
    my $channelId = shift;
    my $programmeId = shift;
    use vars '%prog_to_cat'; local *prog_to_cat = shift;
    use vars '%categories'; local *categories = shift;

    my %p;
    $p{channel} = rt_to_xmltv($channelId);
    $p{_chanID} = $channelId;
    $p{_progID} = $programmeId;
    if ($GET_CATEGORIES) {
	my $cat_ID = $prog_to_cat{"$channelId$programmeId"};
	my $cat = $categories{$cat_ID};
	push @{$p{category}}, [ lc $cat ];
    }

    my $url = "$BASE_URL/ListingsServlet?event=10&";
    $url .= "channelId=$channelId&";
    $url .= "programmeId=$programmeId&";
    $url .= 'jspLocation=/jsp/prog_details.jsp';
    my $prog_details_string = get_url($url);
    $prog_details_string  =~ tr/\r//d;
    t 'whole page: ' . d $prog_details_string;
    $prog_details_string  =~ m{</script>\s*(<table .*?)<!-- end main table -->}s
      or die "cannot main table in HTML $_";
    my $prog_details = $1;
    t 'programme details from page: ' . d $prog_details;

    for ($prog_details) {
	# We use pipe characters as a delimiter between bits of text.  So
	# first, check there aren't any in there already.
	#
	tr/|//d;
	
	# Replace comments and HTML tags with pipes.
	s/<!--.*?-->/\|/g;
	s/<[ ]*[^0-9][^>]*?>/\|/g;
	
	# Tidy up the pipes and whitespace.  Hey, ASCII art!
	$_ = "|$_|";
	s/&nbsp;/ /g;
        s/\s+/ /g;
	s/\s+\|/\|/g;
	s/\|\s+/\|/g;
	tr/|/|/s;
	
	t 'after barification: ' . d $_;
    }

    # chop of related features or related websites
    $prog_details =~ s/Related Features\|.*//;
    $prog_details =~ s/Related Websites\|.*//;

    $prog_details =~ /\|(.*?)\|Channel:/
      or die "cannot find title in HTML $prog_details";
    my $title = $1;
    my $sub_title;
    if ($title =~ s/\|(.*)//) {
	$sub_title = $1;
    }
    for ($title) {
	s/^\s+//; s/\s+$//;
    }
    $p{title} = [ [ $title, $LANG ] ];

    $prog_details =~ /Channel:\|(.*?)\|/
      or die "cannot find channel name in HTML $prog_details";
    my $channel_name = $1;

    $prog_details =~ /Date:\|([^|]+)\|/
      or die "cannot find date in HTML $prog_details";
    my $date = $1; die if not defined $date;

    $prog_details =~ /Time:\|([0-9,a,m,p,:]*) to ([0-9,a,m,p,:]*)/
      or die "cannot find time in HTML $prog_details";
    my $start_time = $1; die if not defined $start_time;
    my $stop_time = $2; die if not defined $stop_time;
    my $start = UnixDate(ParseDate("$date $start_time"), '%s');
    die if not defined $start;
    my $stop = UnixDate(ParseDate("$date $stop_time"), '%s');
    die if not defined $stop;

    # Some programmes have thir stop time on the next day
    if (($start_time =~ /pm$/) and ($stop_time =~ /am$/)) {
	$stop += 86400;
    }

    my $start_string = human_date($start);
    my $stop_string = human_date($stop);

    $p{start} = $start_string;
    $p{stop} = $stop_string;

    #chop of all the stuff we have parsed
    $prog_details =~ s/.*Time:\|$start_time to $stop_time\|//;

    my ($options,$subtitles,$widescreen,$repeat,$black_and_white,
	$certificate,$episode,$review,$director,$filmed_in,$cast);

    if ($prog_details =~ /(.*?)\|/) {
	# FIXME warn about options other than these.
	$options = $1;
	if ($options eq 'Review') {
	    $options ='';
	}
	if ($options eq 'Episode') {
	    $options ='';
	}
	if ($options eq 'Certificate:') {
	    $options ='';
	}

	if ($options =~m/Subtitled/) {
	    $subtitles = 'yes';
	    $p{subtitles} = [ { type => 'teletext' } ];
	}
	if ($options =~m/Widescreen/) {
	    # FIXME I think this can be handled under <video>.
	    $widescreen = 'yes';
	    $p{_widescreen} = 'yes';
	}
	if ($options =~m/Repeat/) {
	    $repeat = 'yes';
	    $p{'previously-shown'} = {}
	}
	if ($options =~m/Black and White/) {
	    $black_and_white = 'yes';
	    $p{video}{present} = 1;
	    $p{video}{colour} = 0;
	}

	$prog_details =~ s/$options\|//;
    }

    if ($prog_details =~ /Certificate:\|\[(.*?)\]\|/) {
	$certificate = $1;
	$p{_certificate} = $1;
    }

    # episode corresponds to badly named 'sub -title'
    if ($prog_details =~ /Episode\|(.*?)\|/) {
	$episode = $1;
	$p{'sub-title'} = [ [ $1, $LANG ] ];
    }

    # Review corresponds to description
    if ($prog_details =~ /Review\|(.*?)\|/) {
	$review = $1;
	for ($review) {
	    s/^\s+//; s/\s+$//;
	}
	$p{desc} = [ [ $review, $LANG ] ];
    }

    #chop of all the stuff we have parsed
    # FIXME should have removed this while parsing.
    $prog_details =~ s/.*Certificate:\|(.*?)\|//;
    $prog_details =~ s/.*Episode\|(.*?)\|//;
    $prog_details =~ s/.*Review\|(.*?)\|//;

    if ($prog_details =~ /Directed by:\|(.*?)\|/) {
	$director = $1;
	push @{$p{credits}{director}}, $1;
    }
    if ($prog_details =~ /Filmed in:\|(.*?)\|/) {
	$filmed_in = $1;$p{'_filmed_in'} = $1;
    }
    if ($prog_details =~ /Cast List\|(.*)/) {
	$cast = $1;
	$cast =~ s/\s*\|$//;

	if ($cast =~ /\|\.\.\.\.\.\|/) {
	    $cast =~ s/(\|\.\.\.\.\.)+/\@/;
	    #$cast =~ s/\@+/\@/g;
	    my @splitter = split /\@\|/, $cast;
	    my $roles_string = shift @splitter;
	    my $names_string = shift @splitter;
	    my @act_roles = split /\|/, $roles_string;
	    my @act_names = split /\|/, $names_string;
	    $cast = '';
	    foreach my $act_name (@act_names) {
		my $act_role = shift @act_roles;
		$cast .= "|$act_name,$act_role";
	    }
	    $cast =~ s/^\|//;
	}
	else {
	    $cast =~ s/\|/,actor\|/g;
	    $cast =~ s/,/,actor\|/g;
	    $cast =~ s/\|\s/\|/g;
	    $cast =~ s/$/,actor/;
	}

	my @cast_list = split /\|/, $cast;
	foreach (@cast_list) {
	    /^([^,]*),([^,]*)$/;
	    my $name = $1;
	    my $role = $2;

	    # FIXME The XMLTV doesnt seem to allow anything but actor or
	    # director so we must just ignore role for now
	    push @{$p{credits}{actor}}, $name;
	}
    }

    #print STDERR "Title: $title\n";
    #print STDERR "Sub Title: $sub_title\n";
    #print STDERR "Channel: $channel_name\n";
    #print STDERR "Date: $date\n";
    #print STDERR "Start: $start_string\n";
    #print STDERR "Stop: $stop_string\n";
    #print STDERR "Subtitles: $subtitles\n";
    #print STDERR "WideScreen: $widescreen\n";
    #print STDERR "Repeat: $repeat\n";
    #print STDERR "Black and White: $black_and_white\n";
    #print STDERR "Certificate: $certificate\n";
    #print STDERR "Episode: $episode\n";
    #print STDERR "Review: $review\n";
    #print STDERR "Directed By: $director\n";
    #print STDERR "Filmed in: $filmed_in\n";
    #print STDERR "Cast List: $cast\n";
    #print STDERR "\n";

    return %p;
}

# Function which will locate all the available channels and return a hash
# with channelId as the key and a chanel description
sub get_channels() {
    my $data = get_url("$BASE_URL/");
    $data =~ tr/\n\r/\n/ds;
    t 'got channels page: ' . d $data;
    $data =~ s/\n//g;
    $data =~ /<select name="channels"[^>]*?>(.*?)<\/select>/
      or die "cannot find channel string in HTML $data";
    my $channel_string = $1;
    t 'got string of channels: ' . d $channel_string;
    $channel_string =~ s/\s+/ /g;
    my @channels = ($channel_string =~ /<option value="[0-9]+" >[^<]*/ig);
    t 'channels in string: ' . d @channels;
    warn "no channels found in $channel_string" if not @channels;
    my %c;

    foreach (@channels) {
	t 'doing channel string: ' . d $_;
	m/"([0-9]*)"/ or die "cannot find numeric channel id in $_";
	my $channelId = $1;
	t 'got numeric id: ' . d $channelId;
	m/>(.*)/ or die "cannot find channel description in $_";
	my $channelDesc = $1;
	for ($channelDesc) {
	    s/^\s+//; s/\s+$//;
	}
	t 'got description: ' . d $channelDesc;
	my $chanID_to_output = rt_to_xmltv($channelId);
	t 'XMLTV id to use: ' . d $chanID_to_output;
	die if not defined $chanID_to_output;
	die if not defined $channelId;
	my $ch = { 'display-name' => [ [ $channelDesc, $LANG ] ],
		   'id' => $chanID_to_output };
	t 'channel object: ' . d $ch;
	$c{$chanID_to_output} = $ch;
	t "added to channels hash under key $chanID_to_output";
    }

    t 'returning hash: ' . d \%c;
    return %c;
}

# Function which will locate all the available categories and return a hash
# with categoryId as the key and a category description
sub get_categories() {
    my $data = get_url("$BASE_URL/jsp/listings_search.jsp");
    $data =~ s/\n//g;
    $data =~ /<select name="genres"[^>]*?>(.*?)<\/select>/
      or die "cannot find category in HTML $data";
    my $category_string = $1;
    $category_string =~ s/\s+/ /g;
    my @categories =
      ($category_string =~ /<option value="[0-9]+">[^<]*/ig);
    warn "cannot find categories in $category_string" if not @categories;
    my %c;

    foreach (@categories) {
	m/"([0-9]*)"/
	  or die "cannot find number in category $_";
	my $categoryId = $1;
	m/>(.*)/
	  or die "cannot find description in category $_";
	my $categoryDesc = $1;
	#print STDERR "Found Category: $categoryId CategoryDesc: $categoryDesc\n";
	my $cast;

	$c{$categoryId} = $categoryDesc;
    }

    return %c;
}

# Function which will locate all the available dates and return a list
# of Date::Manip objects, one for each day.
#
# (I was tempted to make this a hash (so you could say $available{$d}
# to see if a day exists) but string equality is a bit dirty for
# comparing two Date::Manip objects.  There needs to be a tied hash
# class which can use a specified equality operation.)
#
sub get_available_dates() {
    my @r;
    my $data = get_url("$BASE_URL/jsp/listings_search.jsp");
    $data =~ s/\n//g;
    $data =~ /<select name="searchDate"[^>]*?>(.*?)<\/select>/
      or die "cannot find searchDate string in HTML $data";
    local $_ = $1;
    s/&nbsp;/ /g;
    s/\s+/ /g;
    s/^\s*//;
    t 'date string: ' . d $_;
    while (length) {
	if (not s!<option value="(\d\d)/(\d\d)/(\d{4})" ?(?:selected)?>([^<]+)!!) {
	    warn "remnant junk in date string: $_";
	    return @r;
	}

	my $parsed_val = ParseDate("$3-$2-$1");
	die "cannot parse option value $1/$2/$3"
	  if not defined $parsed_val;

	# Paranoia, or 'use all the information'.
	my $parsed_text = ParseDate($4);
	if (defined $parsed_text) {
	    warn "dates '$1/$2/$3' and '$4' from same option differ"
	      if Date_Cmp($parsed_val, $parsed_text);
	}
	else {
	    warn "cannot parse option text $4";
	}

	push @r, $parsed_val;
    }
    return @r;
}


# Function which will locate all the programes in a category
# (at a given date and time)
# will return a hash with "chanIDProgID" as the key
#
# Parameters:
#   (reference to) list of XMLTV ids of channels to search
#   Date::Manip object giving date and time
#   (reference to) hash of categories
#
# I think this searches $TIME_INTERVAL time starting from the time
# given.
#
sub get_progs_in_cat( $$$ ) {
    my @channels_to_search = map { xmltv_to_rt($_) } @{shift()};
    my $time = shift;
    use vars '%categories'; local *categories = shift;

    my %cats;

    # For each category find all the programmes in that category
    foreach my $category (keys %categories) {
	my $url = "$BASE_URL/ListingsServlet?event=7&";
	$url .= 'jspGridLocation=%2Fjsp%2Ftv_listings_grid.jsp&';
	$url .= 'jspListLocation=%2Fjsp%2Ftv_listings_list.jsp&';
	$url .= 'jspError=%2Fjsp%2Ferror.jsp&';
	$url .= 'channels=' . join(',', @channels_to_search) . '&';
	$url .= "genres=$category&";
	$url .= 'searchDate=' . UnixDate($time, '%d/%m/%Y') . '&';
	$url .= 'searchTime=' . UnixDate($time, '%R');
	#print STDERR "$url\n";
	my $data = get_url($url);
	$data =~ s/\n//g;

	my @results = ($data =~ /<!-- start of a result -->.*?<!-- end of a result -->/ig);
	warn "cannot find results in $data" if not @results;

	#print STDERR "$category $searchDate $searchTime\n";

	foreach (@results) {

	    /channelId=([0-9]+)/
	      or die "cannot find channelId= in $_";
	    my $channelId = $1;

	    /programmeId=([0-9]+)/
	      or die "cannot find programmeId= in $_";
	    my $programmeId = $1;

	    $cats{"$channelId$programmeId"} = $category;
	    #print STDERR "ChannelId:$channelId ProgrammeId:$programmeId\n";
	}
    }
    return %cats;
}

sub rt_to_xmltv( $ ) {
    my $n = shift;
    if (not defined $rt_to_xmltv{$n}) {
	my $new = "$n.$DOMAIN";
	die "channel id $new already exists" if defined $xmltv_to_rt{$new};
	$rt_to_xmltv{$n} = $new;
	$xmltv_to_rt{$new} = $n;
    }
    return $rt_to_xmltv{$n};
}
sub xmltv_to_rt( $ ) {
    my $x = shift;
    for ($xmltv_to_rt{$x}) {
	die "no RT id known for $x" if not defined;
	return $_;
    }
}


# Ask the user which channels to download, and write $CONFIG_FILE.
#
# Uses global %channels hash.
#
# FIXME commonize the whole damn configure routine with tv_grab_uk!
#
sub configure() {
#    local $Log::TraceMessages::On = 1;
    # FIXME need to make directory
    open(CONF, ">$CONFIG_FILE") or die "cannot write to $CONFIG_FILE: $!";
    my %chose_ch;
    t 'channels: ' . d \%channels;

    # For now we just let the user pick among the 'standard' channels.
    for (;;) {
	print "Enter the name of a channel, or '.' to finish: ";
	my $in = <STDIN>;
	$in =~ s/^\s+//; $in =~ s/\s+$//;
	last if $in eq '.';

	# FIXME commonize this matching by display name.  To do that I
	# think you'd have to eliminate the silly Ananova_Channel
	# stuff from tv_grab_uk and just use ordinary channel hashes.
	#
	my @poss;
      CH: foreach my $k (sort keys %channels) {
	    my $ch = $channels{$k};
	    my $dns = $ch->{'display-name'};
	    unless ($dns and @$dns) {
		warn "channel with id $ch->{id} has no display name, so cannot be configured\n";
		next CH;
	    }
	    foreach (map { $_->[0] } @$dns) {
		if (/$in/i) {
		    push @poss, $ch;
		    next CH;
		}
	    }
	}

	# We only matched based on display names, so we can assume
	# that each possible channel has at least one.
	#
	if (@poss == 0) {
	    print "No channel matching that.\n";
	}
	elsif (@poss == 1) {
	    my $ch = $poss[0];
	    if (askBooleanQuestion('Add channel ' .
				   $ch->{'display-name'}->[0]->[0] . '?', 1)) {
		my $xmltv_id = $ch->{id};
		unless ($chose_ch{$xmltv_id}++) {
		    print CONF "channel $xmltv_id\n";
		}
	    }
	}
	elsif (1 <= @poss and @poss < 25) {
	    my %dn_to_ch;
	    foreach (@poss) {
		my $dn = $_->{'display-name'}->[0]->[0];
		warn "more than one channel called $dn"
		  if exists $dn_to_ch{$dn};
		$dn_to_ch{$dn} = $_;
	    }
	    my $none_option = 'None of the above are what I wanted';
	    die 'silly channel name' if exists $dn_to_ch{$none_option};
	    my $r = askQuestion('Which channel to add?',
				$poss[0]->{'display-name'}->[0]->[0],
				(sort keys %dn_to_ch), $none_option);
	    next if $r eq $none_option;
	    my $ch = $dn_to_ch{$r}; die if not defined $ch;
	    my $xmltv_id = $ch->{id};
	    unless ($chose_ch{$xmltv_id}++) {
		print CONF "channel $xmltv_id\n";
	    }
	}
	elsif (25 <= @poss) {
	    print "'$in' matches lots of channels, be more specific.\n";
	}
	else { die }
    }

    close CONF or warn "cannot close $CONFIG_FILE: $!";
    print "All done, run with no arguments to grab a week's listings.\n";
    exit();
}
