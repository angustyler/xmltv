#!/usr/bin/perl -w

=head1 NAME

tv_grab_sn - Grab TV listings for Sweden.

=head1 SYNOPSIS

tv_grab_sn --help

tv_grab_sn [--config-file FILE] --configure

tv_grab_sn [--config-file FILE] [--output FILE] [--days N]

=head1 DESCRIPTION

Output TV listings for several channels available in Sweden or Norway.
The data comes from www.dagenstv.com which is owned by the largest
company providing TV listings in Sweden.  The grabber relies on
parsing HTML so it might stop working at any time.

First run B<tv_grab_sn --configure> to choose whether you want Swedish
or Norwegian listings.  Then running B<tv_grab_sn> with no arguments
will output listings in XML format to standard output.

B<--configure> Prompt for Sweden or Norway and write the configuration
file.

B<--config-file FILE> Set the name of the configuration file, the
default is B<~/.xmltv/tv_grab_sn>.  This is the file written by
B<--configure> and read when grabbing.

B<--output FILE> write to FILE rather than standard output.

B<--days N> grab N days starting from today.  The default is ten.

=head1 SEE ALSO

L<xmltv(5)>.

=head1 AUTHOR

Stefan Görling, stefan@gorling.se

=head1 BUGS

The data source does not include full channels information and the
channels are identified by short names rather than the RFC2838 form
recommended by the XMLTV DTD.

I havenE<39>t even considered what happends whith DST issues.

=cut

use strict;
use Getopt::Long;
use Date::Manip;
use LWP::Simple;
use HTML::TableExtract; # parse html nicer than regular expressions.
use XMLTV;
use XMLTV::Memoize; XMLTV::Memoize::check_argv();
use XMLTV::Ask;
# Todo: perhaps we should internationalize messages and docs?
use XMLTV::Usage <<END
$0: get Swedish or Norwegian television listings in XMLTV format
To configure: $0 --configure [--config-file FILE]
To grab listings: $0 [--config-file FILE] [--output FILE] [--days N]
END
  ;

# Get options.
XMLTV::Memoize::check_argv('get');
my ($opt_days, $opt_help, $opt_output,
    $opt_configure, $opt_config_file);
$opt_days = 10; # default
GetOptions('days=i'        => \$opt_days,
	   'help'          => \$opt_help,
	   'configure'     => \$opt_configure,
	   'config-file=s' => \$opt_config_file,
	   'output=s'      => \$opt_output,
	  )
  or usage(0);
die 'number of days must not be negative'
  if (defined $opt_days && $opt_days < 0);
usage(1) if $opt_help;

# File that stores which channels to download.
my $CONFIG_FILE = $opt_config_file;
if (not defined $CONFIG_FILE) {
    if (defined($ENV{HOME})) {
	my $conf_dir = "$ENV{HOME}/.xmltv";
	(-d $conf_dir) or mkdir($conf_dir, 0777)
	  or die "cannot mkdir $conf_dir: $!";
	$CONFIG_FILE = "$conf_dir/tv_grab_sn";
    }
    else {
	# $HOME not set, use current directory.
	$CONFIG_FILE = 'tv_grab_sn';
    }
}

# FIXME commonize this configuration stuff within the XMLTV project.
if ($opt_configure) {
    if (-e $CONFIG_FILE) {
	print <<END
The configuration file $CONFIG_FILE already exists.  There is
currently no support for altering an existing configuration, you have
to reconfigure from scratch.

END
  ;
	if (not askBooleanQuestion
	    ('Do you wish to overwrite the old configuration?', 0)) {
	    print "Exiting.\n";
	    exit 0;
	}
    }
}
else {
    if (-e $CONFIG_FILE) {
	print STDERR "using config file $CONFIG_FILE\n";
    }
    else {
	die "config file $CONFIG_FILE does not exist, run me with --configure\n";
    }
}

if ($opt_configure) {
    open(CONF, ">$CONFIG_FILE") or die "cannot write to $CONFIG_FILE: $!";
    my %cs = (Sweden => 'se', Norway => 'no');
    my $default_cn = 'Sweden';
    my $cn = askQuestion('Grab listings for which country?',
			 $default_cn,
			 sort keys %cs);
    my $c = $cs{$cn}; die if not defined $c;
    print CONF "country $c\t# $cn\n";
    close CONF or warn "cannot close $CONFIG_FILE: $!";
    print "All done, run with no arguments to grab listings.\n";
    exit();
}

my $country;
open(CONF, $CONFIG_FILE) or die "cannot read $CONFIG_FILE: $!\n";
while (<CONF>) {
    s/\#.*//; s/^\s+//; s/\s+$//;
    next if not length;
    if (/^country\s+(\w\w)$/) {
	warn "$CONFIG_FILE:$.: already seen country\n"
	  if defined $country;
	$country = $1;
    }
    else {
	warn "$CONFIG_FILE:$.: bad line\n";
    }
}

# Assume the listings source uses CET (see BUGS above).
Date_Init('TZ=CET');
my $now = ParseDate('now'); die if not defined $now;
my $today = UnixDate($now, '%Q');
my $startDate=$today;
my $data;

my $row;
my $table;

#defines what table to reach.
my $channel_name="";
my $channel_id="";
my $program_name="";
my $program_description="";
my $showview_code="";
my $program_start="";
my $program_stop="";

sub tidy ($ );
sub nextday( $ );
sub print_record();
sub process_table();

#Find Channels.

if (!$opt_output) {
  open(OUTFILE,">-");
}else{
  open(OUTFILE,">".$opt_output);
}

my $local_data=get("http://www.dagenstv.com/$country/frontpage");
if ($local_data=~m/<select\s*name=\"cha\"(.*?)<\/select>/s) {
    $local_data=$1;


    print OUTFILE <<END
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE tv SYSTEM "xmltv.dtd">

<tv>
END
  ;

    # for each channel
    while ($local_data=~m/<option\s*value=\"([0-9]+)\"\s*>([^>]+)<\/option>/sg) {
	$channel_name=tidy($2);
	$channel_id=$1;
	$today=$startDate;
	my $local_startDate=$startDate;
	for (my $i=0;$i<$opt_days;$i++) {
	    $program_start="";
	    $program_stop="";
	    #for each day
	    if ($i>0) {
		$local_startDate=nextday($local_startDate);
	    }
	    $today=$local_startDate;
	    #get info
	    process_table();
	}
    }
    print OUTFILE "</tv>\n";
    close(OUTFILE);
}else{
    die "Could not find channel listing.";
}



sub process_table() {
my $URL_BASE = "http://www.dagenstv.com/$country/chart/";
if ($today=~m/([0-9]{4,4})([0-9][0-9])([0-9][0-9])/) {
    $data=get("$URL_BASE?dat=$1-$2-$3&cha=$channel_id");
}else{
    die "Could not parse date";
}
my $te = new HTML::TableExtract(depth=>3, count=>5,keep_html=>1 );
my $ts;
$te->parse($data);
$table=$te->first_table_found();
          foreach $row ($te->rows($table)) {
	      my $tmp;
	      $tmp=tidy(@$row[0]);

	      if ($tmp=~m/[0-9]{2,2}:[0-9]{2,2}/) {
	      if ($program_name && $tmp && !$program_stop) {
		  #We have a record without endtime. use next starttime as endtime
		  $program_stop=$tmp;
		  $program_stop=~s/://sg;
		  print_record();
  	          $program_start=$tmp;
	      }
	      elsif($tmp) {
		  $program_start=$tmp;
	      }
	      #Format startdate
	      $program_start=~s/://sg;

	     $tmp=@$row[2];
	     if ($tmp=~m/<span class=\"charteventname\">\s*([^<]+)\s*</s) {
		 $program_name=tidy($1);

	     }
	     if ($tmp=~m/<span class=\"chartshowview\">\s*\[([^\]]+)\]\s*</s) {
		 $showview_code=tidy($1);
	     }
	     if ($tmp=~m/<span class=\"chartdescription\">\s*([^<]+)\s*</s) {
		 $program_description=tidy($1);
	     }

	      if ($tmp=~m/<\/span>\s*\(([0-9]{2,2}:[0-9]{2,2})\)\s*</s) {
		  $program_stop=$1;
		  $program_stop=~s/://sg;
		  print_record();
	     }



	  }# if we have a time row.

          }

}

#print a program record. We're using nasty global declarations here.
sub print_record() {

    #we have some null-programs which is really a content package, containing sub-programs. we're dealing with real programs only.

    # FIXME wouldn't undef be better here than empty string?
    if ($program_start eq '') {
	warn "program with unknown start time\n";
    }
    elsif ($program_stop eq '') {
	warn "program with unknown stop time\n";
    }
    elsif ($program_start!=$program_stop) {
	if (($program_stop)>$program_start) {
	    $program_start=$today.$program_start;
	    $program_stop=$today.$program_stop;
	}else{
	    $program_start=$today.$program_start;
	    $today=nextday($today);#Wrap the day!
	    $program_stop=$today.$program_stop;
	}
	
	print OUTFILE "<programme channel=\"$channel_name\" showview=\"$showview_code\" start=\"$program_start CET\" stop=\"$program_stop CET\">\n";
	print OUTFILE "<title>$program_name</title>\n";
	print OUTFILE "<desc>$program_description</desc>\n";
	print OUTFILE "</programme>\n";
    }

    $program_name="";
    $program_description="";
    $showview_code="";
    $program_start="";
    $program_stop="";
}

# Trim spaces and newlines, fix rogue characters.
sub tidy($) {
    for (my $tmp=shift) {
	s/\n$//sg;
	s/\s*$//sg;
	s/^\s*//sg;
	s/& /&amp; /g;

	# Some weird characters need removing.
	s/([\200-\237])/sprintf('&#%o;', ord($1))/eg;
	s/([\000-\037])//g;
	return $_;
    }
}

# Bump a YYYYMMDD date by one.
sub nextday( $ ) {
    my $d = shift; $d =~ /^\d{8}$/ or die;
    my $p = ParseDate($d); die if not defined $p;
    my $n = DateCalc($p, '+ 1 day'); die if not defined $n;
    return UnixDate($n, '%Q');
}

