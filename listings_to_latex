#!/usr/bin/perl -w
# 
# listings_to_latex
# 
# Convert TV listings to LaTeX source.
# 
# Usage: listings_to_latex [filename]
# 
# XML listings data will be read from filename, or from stdin if no
# filename is given.  LaTeX source will be written to stdout.
# 
# -- Ed Avis, epa98@doc.ic.ac.uk, 2000-08-16
# 

use strict;
use XML::DOM;
use IO::File;
use Date::Manip;
use POSIX 'tmpnam';
require 'uk_tz.pl';

die "usage: $0 [filename]" if @ARGV >= 2;

########
# Configuration
#

# Channel names to numbers.  We use use DNS-style names as suggested
# by RFC 2838,
# <http://ietf.org/internet-drafts/draft-zigmond-tv-url-04.txt>.  The
# output listings give number, not the channel's display name, so
# reading channels.xml is not needed.  (We could have another
# configuration file saying which channels are at which numbers, but
# for the time being it's configured by editing this file.)
# 
# If the hash doesn't contain an entry for a particular channel name,
# the name is left alone.  So just leave this empty if you want your
# LaTeX output to have the internal channel names.
# 
my %ch_to_num = ();

# British terrestrial analogue television
%ch_to_num = (%ch_to_num,
	      'bbc1.bbc.co.uk'           => 1,
	      'bbc2.bbc.co.uk'           => 2,
	      'carlton.com'              => 3, # FIXME LWT, other franchises
	      'channel4.com'             => 4,
	      'channel5.co.uk'           => 5,

# ...and stuff on digital
	      'sky-one.sky.com'          => 'S1',
	      'radio-1.bbc.co.uk'        => 'R1',
	      'radio-2.bbc.co.uk'        => 'R2',
	      'radio-3.bbc.co.uk'        => 'R3',
	      'radio-4.bbc.co.uk'        => 'R4',
	      'radio-5-mw.bbc.co.uk'     => 'R5-MW',
	      'bbc-parliament.bbc.co.uk' => 'BBC Parl',
	      'bbc-choice.bbc.co.uk'     => 'BBC Choice',
	      'world-svc.bbc.com'        => 'World Svc',
	      'bbc-knowledge.bbc.co.uk'  => 'BBC Know',
	      'sky-news.sky.com'         => 'Sky News',
	     );

# Width of programme title
my $WIDTH = '0.7\textwidth';

# Number of programmes in each table (should fit onto a page)
my $CHUNK_SIZE = 30;

########
# End of configuration
# 

# Memoize some subroutines if possible
my $memoize_avail;
eval { require Memoize };
if ($@) {
    warn "could not load Memoize module, things will run slowly";
    $memoize_avail = 0;
}
else {
    foreach (qw/start_date ParseDate UnixDate gettz ParseDate_PreservingTZ/) {
	Memoize::memoize($_) or die "cannot memoize $_: $!";
    }
    $memoize_avail = 1;
}

# Prototype declarations
sub chunk($$);
sub start_date($);
sub get_u8_to_latin1();
sub get_programmes($);
sub quote($);                                                            

# Reference to sub converting UTF-8 to Latin-1
my $u8_to_latin1 = get_u8_to_latin1();
$u8_to_latin1 = Memoize::memoize($u8_to_latin1) if $memoize_avail;

# Print the start of the LaTeX document
print <<'END';
\documentclass[a4paper]{article}
\usepackage[latin1]{inputenc}
\begin{document}
\sf
\begin{flushleft}
END

# Parse the input and make it into chunks of programmes
@ARGV = ('-') if not @ARGV;
my $p = new XML::DOM::Parser;
my $doc = $p->parsefile($ARGV[0]);
my @chunks = @{chunk($CHUNK_SIZE, get_programmes($doc))};

# Print each chunk as a table
my ($curr_date, $curr_tz);
foreach (@chunks) {
    my @programmes = @$_;
    
    my $chunk_date = start_date($programmes[0]);
    if (not defined $curr_date or $curr_date ne $chunk_date) {
	my $df = UnixDate($chunk_date, "%m-%d (%A)");
	print "\\section*{\\sf $df}\n";
	$curr_date = $chunk_date;
    }

    print "\\begin{tabular}{r\@{--}lp{$WIDTH}r} \n";
    my $top_of_table = 1;
    foreach (@programmes) {
	my %h = %$_;
	my ($start, $stop, $channel) = @h{qw(start stop channel)};

	# Title and sub-title can be multi-valued, so they're a list
	my $title = join(' / ', @{$h{title}});
	my $sub_title = join(' / ', @{$h{'sub-title'}});
	
	# Convert date-and-time to just hhmm, adding explicit timezone
	# whenever it changes.
	# 
	my $start_tz = gettz($start) || 'UT';
	my $start_p = ParseDate_PreservingTZ($start)
	  or die "bad date '$start'";
	my $start_h = UnixDate($start_p, '%R');

	if ($top_of_table and not defined $curr_tz) {
	    # Assume that the first listing on a page doesn't need an
	    # explicit timezone.  (FIXME not perfect)
	    # 
	    $curr_tz = $start_tz;
	}
	$top_of_table = 0;

	my $stop_h;
	if (defined $stop) {
	    # Stop time is defined, sort out its timezone too
	    my $stop_tz = gettz($stop) || 'UT';
	    my $stop_p = ParseDate_PreservingTZ($stop)
	      or die "bad date '$stop'";
	    $stop_h = UnixDate($stop_p, '%R');
	    
	    if ((not defined $curr_tz)
		or ($curr_tz ne $start_tz)
		or ($start_tz ne $stop_tz) )
	    {
		  # The timezone has changed somehow - make it explicit.
		  $start_h .= " $start_tz";
		  $stop_h .= " $stop_tz";
		  undef $curr_tz;
	    }
	    
	    if ($start_tz eq $stop_tz) {
		# The programme starts and stops in the same TZ - we
		# can assume that this is the one to use from now on.
		# 
		$curr_tz = $start_tz;
	    }
	}
	else {
	    # Missing stop time.  Still need to check the timezone.
	    if ((not defined $curr_tz) or ($curr_tz ne $start_tz)) {
		$start_h .= " $start_tz";
		undef $curr_tz;
	    }
	}

	# Hardcoded channel lookup
	my $ch_num = $ch_to_num{$channel};
	$channel = $ch_num if defined $ch_num;
	
	$channel = quote($channel);
	$title .= " // $sub_title" if $sub_title ne '';
	$title = quote($u8_to_latin1->($title));

	# Apparently, you have to put \smallskip _before_ each line
	# (even the first) in order to get consistent spacing.  The
	# blank line after $title is to explicitly end the paragraph,
	# so that \raggedright takes effect.
	# 
	# Er, this needs fixing.  See my post to comp.text.tex.
	# 
	die 'no start'   if not defined $start_h;
	$stop_h = '' if not defined $stop_h;
	die 'no title'   if not defined $title;
	die 'no channel' if not defined $channel;

	print <<END;
\\smallskip
$start_h & $stop_h &
{ \\small \\raggedright
$title
} & $channel \\\\
END
    }

print "\\end{tabular} \\\\ \n";
}
print "\\end{flushleft}\n";
print "\\end{document}\n";


# chunk()
# 
# Split up a list of programmes into chunks of a certain maximum size,
# also starting a new chunk for each day.
# 
sub chunk($$) {
    die 'usage: chunk(chunk size, ref to list of programmes)'
      if @_ != 2;
    my ($chunksize, $list) = @_;

    my @r;
    my @currchunk = ();
    while (@$list) {
	push @currchunk, scalar (shift @$list);

	if (@currchunk == $chunksize
	    or @$list == 0
	    or start_date($currchunk[-1]) ne start_date($list->[0]) )
        {
	    push @r, [ @currchunk ];
	    @currchunk = ();
	}
    }
    return \@r;
}


# start_date()
# 
# Returns the day on which a programme starts, in the form YYYYMMDD.
# 
sub start_date($) {
    my $prog = shift;
    die "bad programme" if not defined $prog->{title};
    die "no start date for $prog->{title}"
      if not defined $prog->{start};

    my $p = ParseDate_PreservingTZ($prog->{start});
    die "bad start date for programme" if not defined $p or $p eq '';
    return UnixDate($p, '%Q');
}


# get_u8_to_latin1()
# 
# Do some poking around and try to come up with a subroutine that
# converts UTF-8 strings to Latin-1 encoded strings.  What gets used
# will depend on what the user has installed.
# 
sub get_u8_to_latin1() {
    die 'usage: get_u8_to_latin1()' if @_;
    
    # First preference is for Unicode::String.  With perl 5.6 we could
    # probably use the internal Unicode support, but I'm still using
    # an older version.
    # 
    unless ($u8_to_latin1) {
	eval { require Unicode::String };
	if ($@) {
	    warn "could not load Unicode::String, trying alternatives";
	}
	else {
	    $u8_to_latin1 = sub {
		Unicode::String::utf8($_[0])->latin1()
	    };
	}
    }
    
    # The next best thing is to run GNU recode.  Slow but it works.
    unless ($u8_to_latin1) {
	my $RECODE = 'recode UTF-8..ISO-8859-1';
	chomp(my $r = `echo test | $RECODE`);
	if ($r ne 'test') {
	    warn "GNU recode doesn't seem to work, trying alternatives";
	}
	else {
	    $u8_to_latin1 = sub {
		my $tmp = tmpnam();
		my $fh = new IO::File(">$tmp")
		  or die  "cannot open $tmp for writing: $!";
		print $fh $_[0] or die  "cannot write to $tmp: $!";
		close $fh or warn "cannot close $tmp: $!";
		
		chomp(my $r = `$RECODE <$tmp`);
		return $r;
	    };
	}
    }
    
    # Finally we just strip non-ASCII characters.
    unless ($u8_to_latin1) {
	warn "stripping all non-ASCII characters";
	$u8_to_latin1 = sub {
	    local $_ = shift;
	    tr/\000-\177//cd;
	    return $_;
	};
    }
}


# get_programmes()
# 
# Read an XMLTV file and get out the relevant information for each
# programme.
# 
# Parameters: Root element of document
# Returns: ref to list of hashes with start, titles, etc.
# 
sub get_programmes($) {
    die 'usage: get_programmes(root element from XML::DOM)' if @_ != 1;
    my $doc = shift;
    
    my $nodes = $doc->getElementsByTagName('programme');
    my $n = $nodes->getLength();

    my @programmes = ();
    for (my $i = 0; $i < $n; $i++) {
	my $node = $nodes->item($i);
	my %programme;
	
	foreach (qw<start stop channel>) {
	    my $v = $node->getAttribute($_);
	    $programme{$_} = $v unless $v eq '';
	}
	
	my @titles = ();
	foreach ($node->getElementsByTagName('title', 0)) {
	    push @titles, $_->getFirstChild()->getData();
	}
	$programme{title} = \@titles;
	
	my @sub_titles = ();
	foreach ($node->getElementsByTagName('sub-title', 0)) {
	    push @sub_titles, $_->getFirstChild()->getData();
	}
	$programme{'sub-title'} = \@sub_titles;
	
	push @programmes, \%programme;
    }
    return \@programmes;
}


# quote()
# 
# Quote at least some characters which do funny things in LaTeX
# 
# Parameters: string to quote
# Returns: quoted version
# 
# Copied from <http://www.doc.ic.ac.uk/~epa98/work/apps/dtd2latex/>;
# should put something like this into a 'LaTeX' module some day.
# 
sub quote($) {
    die 'usage: quote(string)' if @_ != 1;
    local $_ = shift;

    # Quote characters
    s/\\/\\(\\backslash\\)/g;
    foreach my $ch ('_', '#', '%', '{', '}', '&') {
	s/$ch/\\$ch/g;
    }
    s/\$/\\\$/g;
    foreach my $ch ('<', '>') {
	s/$ch/\\($ch\\)/g;
    }
    s/~/\\(\\sim\\)/;
    s/\^/\\(\\hat{}\\)/;

    # Lines of dots
    s/\.{3,}\s*$/\\dotfill/mg;

    return $_;
}
