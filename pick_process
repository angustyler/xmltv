#!/usr/bin/perl -w
# 
# pick_process
# 
# Get numbered programmes from a TV listings file.  This is so
# that after running pick.cgi, you can filter its output with this
# program to get an XML file of the programmes you want to watch.
# 
# For example, if foo.xml contains:
# 
# <tv>
#   <programme>A</programme>
#   <programme>B</programme>
#   <programme>C</programme>
# </tv>
# 
# and picked contains
# 
# foo.xml/0
# foo.xml/1
# 
# then 'pick_process <picked' will produce:
# 
# <tv>
#   <programme>A</programme>
#   <programme>B</programme>
# <tv>
# 
# because it has picked subelements zero and one from foo.xml.  But
# the order in which they appear is always the same as in the input
# XML - and they cannot appear twice in the output.
# 
# This could be generalized a bit (eg arbitrary XML DTDs,
# sub-sub-elements, more than one input file) but I haven't bothered.
# 
# -- Ed Avis, epa98@doc.ic.ac.uk, 2000-06-29
# 

use strict;
use XML::DOM;

die "usage: $0 [filename]" if @ARGV >= 2;
@ARGV = ('-') unless @ARGV;

my $xmlfile;
my %nums;
while (<>) {
    s/^\s+//; s/\s+$//;
    s/\#.*//;
    next if $_ eq '';
    m!^(.+)/(\d+)$!
      or die "$ARGV:$.: bad line (expected FILENAME/NUMBER)";

    if (not defined $xmlfile) {
	$xmlfile = $1;
    }
    else {
	die "$ARGV:$.: $1 does not match previous filename $xmlfile"
	  unless $1 eq $xmlfile;
    }
    $nums{$2}++ && die "$ARGV:$.: programme $2 chosen twice";
}

die 'expect one or more input lines FILENAME/NUMBER'
  if not defined $xmlfile;
die 'cannot read XML from stdin' if $xmlfile eq '-';
my $p = new XML::DOM::Parser;
my $doc = $p->parsefile($xmlfile);
my $nodes = $doc->getElementsByTagName('programme');
my $n = $nodes->getLength();

for (my $i = 0; $i < $n; $i++) {
    my $node = $nodes->item($i);
    unless ($nums{$i}) {
	# This subelement wasn't chosen
	$doc->getDocumentElement()->removeChild($node);
    }
}

$doc->printToFileHandle(\*STDOUT);
