#!/usr/bin/perl -w
#
# parallel_test
#
# Quick and dirty test rig I use for checking that changes to
# tv_grab_uk give the same results.  Should be possible to
# use it for testing any program where you want to make sure there are
# no differences between the old and new versions.
#
# At present, the command to run is hardcoded in the script.  You'll
# need to make a copy of this script and edit it.
#
# Should not be installed as part of XMLTV, but can be included in
# source tarball.
#
# -- Ed Avis, epa98@doc.ic.ac.uk, 2002-01-31
# $Id: parallel_test,v 1.3 2002/02/27 18:10:53 epaepa Exp $
#
use strict;

# Old command - directory it should run from, and command to run.
my $a_dir = '/homes/epa98/work/apps/xmltv/old_version';
my @a_cmd = qw(perl -Iblib/lib blib/script/tv_grab_uk);
die "no such directory $a_dir - edit the script for your setup\n" if not -d $a_dir;

# New command in its directory.
my $b_dir = '/homes/epa98/work/apps/xmltv/cvs_working';
my @b_cmd = qw(perl -Iblib/lib blib/script/tv_grab_uk --share blib/share);
die "no such directory $b_dir - edit the script for your setup\n" if not -d $b_dir;

# Arguments to pass to both commands for each test.
my @tests = ([],
	     [qw(--days 1 carlton)],
	     [qw(--days 1 BBC1)],
	     [qw(carlton)],
	     [qw(tyne)],
	     [qw(radio)],
	     [qw(satellite)],
	     [qw(ALL)],
	     [qw(gratis)],
	     [qw(gratis radio)],
	     [qw(music nickelodeon e4)]);

# Arguments at the start of the command line for every test.
my @constant_args = qw(--cache /homes/epa98/vol/tmp/tv_grab_uk.cache);

# Directory to store test results.
my $tmp = '/homes/epa98/vol/tmp';

# Normally this script checks for identical output.  But you may give
# fixups to be applied to the old version's output before comparison.
#
my $fixup;
#$fixup = q[perl -pe 's/"xmltv_ns">/"xmltv_ns">. . /; s/_ch5_10/_ch5_0/;'];
#$fixup = q[perl -pe 's/(start|stop)="(.+?)"/$1="$2 UT"/'];
#$fixup = q[perl -pe 's/(2001 Ananova Ltd )/$1\n/; s/(use please see )/$1\n/; s/(terms.html)/$1\n/'];
#$fixup = q[perl -pe 's/west.bbc1.bbc.co.uk/bbc1.bbc.co.uk/g; s/bbc1w_8/bbc1_2/g; s/BBC1 West/BBC1/g; s/BBC Points West/Regional News Programmes/g'];

use Getopt::Std;
use vars '$opt_q'; getopts('q');

my $starting_test = $ARGV[0] || 0;
my $num_failures = 0;
$SIG{__WARN__} = sub { ++ $num_failures; warn @_ };
for (my $test_num = $starting_test; $test_num < @tests; $test_num++) {
    local $_ = $tests[$test_num];
    print STDERR "test $test_num: @$_\n";

    chdir $a_dir or die;
    my $old_out = "$tmp/$test_num.old.out";
    unless ($opt_q) {
	system("time @a_cmd @constant_args @$_ >$old_out") && die "@a_cmd failed";
    }
    if (defined $fixup) {
	system("$fixup <$old_out >$old_out.fixed") && die "$fixup failed";
	$old_out = "$old_out.fixed";
    }

    chdir $b_dir or die;
    my $new_out = "$tmp/$test_num.new.out";
    unless ($opt_q) {
	system("time @b_cmd @constant_args @$_ >$new_out") && die "@b_cmd failed";
    }

    my $diff = "$tmp/$test_num.diff";
    if (system("diff -u $old_out $new_out >$diff")) {
	print STDERR "diff found differences: \n";
	open(DIFF, $diff) or die;
	while (<DIFF>) {
	    if ($. > 1000) {
		print "...\n";
		last;
	    }
	    print;
	}
	exit 1;
    }
}
print STDERR "$num_failures errors\n";
exit($num_failures < 255 ? $num_failures : 255);
