#!/usr/bin/perl -w
#
# parallel_test
#
# Quick and dirty test rig I use for checking that changes to
# tv_grab_uk give the same results.  Should be possible to
# use it for testing any program where you want to make sure there are
# no differences between the old and new versions.
#
# At present, the command to run is hardcoded in the script.  You'll
# need to make a copy of this script and edit it.
#
# Should not be installed as part of XMLTV, but can be included in
# source tarball.
#
# -- Ed Avis, epa98@doc.ic.ac.uk, 2002-01-31
# $Id: parallel_test,v 1.10 2002/05/19 17:29:45 epaepa Exp $
#
use strict;

# Old command - directory it should run from, and command to run.
my $a_dir = '/homes/epa98/work/apps/xmltv/older_version';
my @a_cmd = qw(perl -Iblib/lib blib/script/tv_grab_uk --share blib/share);
die "no such directory $a_dir - edit the script for your setup\n" if not -d $a_dir;

# New command in its directory.
my $b_dir = '/homes/epa98/work/apps/xmltv/old_version';
my @b_cmd = qw(perl -Iblib/lib blib/script/tv_grab_uk --share blib/share);
die "no such directory $b_dir - edit the script for your setup\n" if not -d $b_dir;

# Arguments to pass to each command for each test.  A list of pairs
# and each element of a pair is a list of arguments.
#
my @tests = map { [ $_, $_ ] }
  (
   [qw(--config-file grab/uk/test_configs/carlton)],
   [qw(--days 1 --config-file grab/uk/test_configs/carlton)],
   [qw(--days 1 --config-file grab/uk/test_configs/bbc1)],
   [qw(--config-file grab/uk/test_configs/carlton)],
   [qw(--config-file grab/uk/test_configs/tynetees)],
   [qw(--config-file grab/uk/test_configs/radio)],
   [qw(--config-file grab/uk/test_configs/satellite)],
   [qw(--config-file grab/uk/test_configs/all)],
   [qw(--config-file grab/uk/test_configs/gratis)],
   [qw(--config-file grab/uk/test_configs/gratis_radio)],
   [qw(--config-file grab/uk/test_configs/music_nickelodeon_e4)],
  );

# Arguments at the start of the command line for every test.
my @constant_args;
#@constant_args = qw(--cache /homes/epa98/vol/tmp/tv_grab_uk.cache);

# Directory to store test results.
my $tmp = '/homes/epa98/vol/tmp';

# Normally this script checks for identical output.  But you may give
# fixups to be applied to either version's output before comparison.
#
my (@a_fixups, @b_fixups);
@a_fixups = (q[tv_sort --by-channel]);
@b_fixups = (q[tv_sort --by-channel]);

use Getopt::Std;
use vars qw($opt_q $opt_a $opt_b); getopts('qab');
if ($opt_q) {
    warn "use -a to reuse results from old version, -b for new, -ab for both\n";
    $opt_a = $opt_b = 1;
}

my $starting_test = $ARGV[0] || 0;
my $num_failures = 0;
$SIG{__WARN__} = sub { ++ $num_failures; warn @_ };
for (my $test_num = $starting_test; $test_num < @tests; $test_num++) {
    my ($a_args, $b_args) = @{$tests[$test_num]};
    print STDERR "test $test_num: @$b_args\n";

    chdir $a_dir or die;
    my $old_out = "$tmp/$test_num.old.out";
    unless ($opt_a) {
	system("time @a_cmd @constant_args @$a_args >$old_out") && die "@a_cmd failed";
    }
    foreach (@a_fixups) {
	system("$_ <$old_out >$old_out.fix") && die "$_ failed";
	$old_out = "$old_out.fix";
    }

    chdir $b_dir or die;
    my $new_out = "$tmp/$test_num.new.out";
    unless ($opt_b) {
	system("time @b_cmd @constant_args @$b_args >$new_out") && die "@b_cmd failed";
    }
    foreach (@b_fixups) {
	system("$_ <$new_out >$new_out.fix") && die "$_ failed";
	$new_out = "$new_out.fix";
    }

    my $diff = "$tmp/$test_num.diff";
    if (system("diff -u $old_out $new_out >$diff")) {
	print STDERR "diff found differences: \n";
	open(DIFF, $diff) or die;
	while (<DIFF>) {
	    if ($. > 1000) {
		print "...\n";
		last;
	    }
	    print;
	}
	exit 1;
    }
}
print STDERR "$num_failures errors\n";
exit($num_failures < 255 ? $num_failures : 255);
