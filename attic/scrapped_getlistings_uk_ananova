#!/usr/bin/perl -w
#
# getlistings_uk_ananova
#
# Get UK TV listings from the Ananova website, and output
# them in the format described by xmltv.dtd.
#
# Like all programs which parse websites, this is likely to break if
# the Ananova site layout changes.  The current layout
# is fairly clean and fairly easy to parse; the approach taken is to
# read it like a human would, looking at the appearance of bits of
# text (bold, italic) to decide what they represent.
#
# BUGS
#
# Not all the information in the website is extracted, for example we
# ignore the subtitles flag, aka '888'.  Lots of others too, for
# certain.
#
# USAGE: run it and capture stdout.  Any serious warning or error
# is probably due to the PA changing their website - see if there is
# an updated version of this program.
#
# The web pages are cached in web_cache.db and expire after 24 hours.
#
# -- Ed Avis, epa98@doc.ic.ac.uk, 2001-03-22
#

use strict;
use HTML::TokeParser;

# Date::Manip is used for parsing dates; all dates are stored
# internally in UT (aka GMT).
#
use Date::Manip 5.40; Date_Init('TZ=UT');
require 'uk_tz.pl';

use LWP::Simple;
use XML::Writer;
use Fcntl;
use Tie::RefHash;
use Log::TraceMessages qw(t d); Log::TraceMessages::check_argv();
use vars '$opt_cache'; use Getopt::Long; GetOptions('cache!');
die "usage: $0 [--nocache]" if @ARGV;

# Memoize some subroutines if possible (25x speedup)
eval { require Memoize };
if ($@) {
    warn "could not load Memoize module, things will run slowly";
}
else {
    foreach (qw/istime time12to24 parse_uk_date date_to_uk bst_dates
	        gettz ParseDate UnixDate DateCalc Date_Cmp
                ParseDateDelta/)
    {
	Memoize::memoize($_) or die "cannot memoize $_: $!";
    }

    if ($opt_cache) {
	print "caching\n";
	# Getting web pages is memoized, but they expire after 24 hours
	my $LIFETIME = 24 * 60 * 60; # in seconds
	Memoize::memoize('get', SCALAR_CACHE => ['TIE', 'Memoize::Expire',
						 LIFETIME => $LIFETIME,
						 TIE => [ 'DB_File',
							  'web_cache.db',
							  O_RDWR | O_CREAT,
							  0666 ] ]);
    }
}



########
# Configuration

# %CHANNELS maps the names used by the Ananova site to the DNS-style
# names used internally and in the output.
#

# Normal use
my %CHANNELS = (bbc1    => 'bbc1.bbc.co.uk',
		bbc2    => 'bbc2.bbc.co.uk',
		carlton => 'carlton.com',
		ch4     => 'channel4.com',
		ch5     => 'channel5.co.uk',
	       );
# Day 8 is the same as day 1, etc.  So num. days should be < 8.
my $NUMDAYS = 7;

# A list of channels available for me on Sky Digital - all the free
# ones, plus Sky One and some music channels.
#
my $SAT = 0;
if ($SAT) {
    %CHANNELS = (bbc1               => 'bbc1.bbc.co.uk',
		 bbc2               => 'bbc2.bbc.co.uk',
		 carlton            => 'carlton.com',
		 ch4                => 'channel4.com',
		 ch5                => 'channel5.co.uk',
		 radio1             => 'radio-1.bbc.co.uk',
		 radio2             => 'radio-2.bbc.co.uk',
		 radio3             => 'radio-3.bbc.co.uk',
		 radio4             => 'radio-4.bbc.co.uk',
		 radio5mw           => 'radio-5-mw.bbc.co.uk',
		 worldsvc           => 'world-svc.bbc.com',
		 classicfm          => 'classicfm.com',
		 talkradiouk        => 'talk-radio.co.uk',
		 virgin             => 'virginradio.co.uk',
		 bbcchoice          => 'bbc-choice.bbc.co.uk',
		 bbcknowledge       => 'bbc-knowledge.bbc.co.uk',
		 bbcnews24          => 'bbc-news-24.bbc.co.uk',
		 bbcparliament      => 'bbc-parliament.bbc.co.uk',
		 bloomberg          => 'bloomberg.com',
		 cnn                => 'europe.cnn.com',
		 musicchoiceblues   => 'blues.musicchoice.sky.com',
		 musicchoicecountry => 'country.musicchoice.sky.com',
		 musicchoicedance   => 'dance.musicchoice.sky.com',
		 musicchoiceeasy    => 'easy.musicchoice.sky.com',
		 musicchoicegold    => 'gold.musicchoice.sky.com',
		 musicchoicehits    => 'hits.musicchoice.sky.com',
		 musicchoicejazz    => 'jazz.musicchoice.sky.com',
		 musicchoicelove    => 'love.musicchoice.sky.com',
		 musicchoicerock    => 'rock.musicchoice.sky.com',
		 qvc                => 'qvc.co.uk',
		 sky_news           => 'sky-news.sky.com',
		 sky_channel        => 'sky-one.sky.com',
		 tcm                => 'tcm.turner.com',
		 tvasia             => 'tvasia.com' # maybe not right
		);
}    

# Quicker version for testing
%CHANNELS = (bbc1 => 'bbc1.bbc.co.uk'); $NUMDAYS = 1;

# What language the pages are in.  This has no real effect :-)
my $LANG = 'en';

# Regular expression to match a name
my $NAME_RE;
{
    my $name_comp_re = '[A-Z](?:[\'A-Za-z-]*|[A-Z]\.?)'; # One word of a name
    my $name_end_re  = '[A-Z][\'A-Za-z-]+'; # Surname
    
    $NAME_RE = "(?:(?:$name_comp_re)(?:\\s+$name_comp_re)*\\s+)?$name_end_re";
}

# Regexp to match a list of names: 'Tom, Dick, and Harry'
my $NAMES_RE = "$NAME_RE(?:\\s*,?\\s*(?:and)?\\s+$NAME_RE)*(?!\\s*(?:and|,|[0-9]))";
   
# Subroutine to extract the names from this list
sub list_names($) {
    die 'usage: list_names(English string listing names)'
      if @_ != 1;
    local $_ = shift;
    my @r;
    
    s/^($NAME_RE)\s*// or die "bad 'names' '$_'";
    unshift @r, $1;
    
    while (s/^,?\s*(?:and)?\s+($NAME_RE)\s*//) {
	unshift @r, $1;
    }
    die "unmatched bit of names $_" unless $_ eq '';
    
    return @r;
}



########
# End of configuration

# Prototype declarations
sub pages_for_channel($);
sub programmes_from_html($);
sub date_programmes($$);
sub extract_progs($);
sub boldit($);
sub splitlist($$);
sub istime($);
sub time12to24($);
sub get_date_from_page($);
sub write_programme($$);
sub special_4learning($);
sub special_presenter($);
sub special_actor($);
sub special_guest($);
sub special_radio4($);
sub special_split_title($);
sub special_film($);                                                     
sub add_clumpidx($$);
sub new_relation();
sub related($$$);
sub relate($$$);
sub unrelate($$$);
sub nuke_from_rel($$);
sub relatives($$);
sub fix_clumps($$$);
sub check_page_dates($);
sub parse_dofw($);

# Special-case mungers for various programme types.  Each of these
# should take a single programme and return: a reference to a list of
# programmes, if successful; undef, if the programme is to be left
# alone.  Most special-case handlers will not break up a programme
# into several others, so the returned list will have only one
# element.
#
# A handler may modify the programme passed in iff it returns a list
# of munged programmes.
#
my @special_handlers = (\&special_4learning,
			\&special_presenter,
			\&special_actor,
			\&special_radio4,
			\&special_split_title,
			\&special_film,
		       );

my $writer = new XML::Writer(DATA_MODE   => 1,
			     DATA_INDENT => 2 );
$writer->xmlDecl();
{ local $^W = 0; $writer->doctype('tv', undef, 'xmltv.dtd') }
$writer->startTag('tv');

# Get a big list of programmes for all channels
my @thelot;
foreach my $channel (sort keys %CHANNELS) {
    my $internal_name = $CHANNELS{$channel};

    my @pages = @{pages_for_channel($channel)};
    @pages = @{check_page_dates(\@pages)};

    foreach (@pages) {
	my @progs = @{programmes_from_html($_->{text})};
	$_->{channel} = $internal_name foreach @progs;

	# Programmes sharing a clump - when one is updated, the other
	# may need updating too.
	#
	my $rel = new_relation();
	add_clumpidx(\@progs, $rel);
	t 'related programmes: ' . d($rel);
	
	# Apply all special-case handlers.  We just haphazardly
	# run one after the other; when a programme has been run
	# through all of them in sequence without any changes, we
	# move it to @progs_done.
	#
	# The reason for using _lists_ is that some handlers turn
	# a single programme into several.
	#
	my @progs_done = ();
        PROG: while (@progs) {
	    my $prog = shift @progs;
	    t('running handlers for prog: ' . d($prog));
	    foreach (@special_handlers) {
		t('running handler: ' . d($_));
		my $out = $_->($prog);
		if (defined $out) {
		    t('gave new list of progs: ' . d($out));
		    fix_clumps($prog, $out, $rel);
		    push @progs, @$out;
		    next PROG;
		}
		t('gave undef');
	    }
	    t 'none of the handlers fired, finished with this prog';
	    push @progs_done, $prog;
	}

	t 'processed all of them for this page, writing';
	write_programme($writer, $_) foreach @progs_done;
    }
}

$writer->endTag('tv');
$writer->end();
exit();


# pages_for_channel()
#
# Parameters:
#   Name of a channel (bbc1, bbc2, carlton, ch4, ch5)
#
# Returns: 
#   Ref to list of HTML pages for that channel's listings, from
#   the Ananova site.  Each 'page' is a hashref having keys:
#     url   -  URL of the page
#     text  -  text contained at that URL
#
sub pages_for_channel($) {
#    local $Log::TraceMessages::On = 0;
    die 'usage: html_for_channel(channel name)' if @_ != 1;
    my $ch = shift;
    my @r;

    foreach my $day (1 .. $NUMDAYS) {
  	print STDERR "channel $ch, day $day\n";
 	my $url = "http://www.ananova.com/tv/tv_mainlisting.html?day=day$day&start=Start&c=$ch&h=1";
  	t 'getting url: ' . d($url);
	my $text = get($url);
	die "cannot get $url" if not defined $text;
	t 'got text: ' . d($text);
	push @r, { url => $url, text => $text };
    }

    return \@r;
}


# programmes_from_html()
#
# Top level function.  Turn HTML into a list of programmes with date,
# title, and description. 
#
# Parameters:
#   HTML string
#
# Returns:
#   Ref to list of programmes
#
sub programmes_from_html($) {
    die 'usage: programmes_from_html(html string)' if @_ != 1;
    my $html = shift;

    # Turn the HTML into a list of bold/italic/plain bits of text
    my $bits = boldit($html);

    # Split this into programmes - each programme starts with a time.
    # Also split at 'Ananova' to separate out the trailing cruft.
    #
    my $progs = splitlist(sub { istime($_[0]->{TEXT})
				  or $_[0]->{TEXT} =~ /Ananova/ },
			  $bits );
    
    # Remove the cruft, leaving just the programmes.
    my @progs = grep { @$_ and $_->[0]->{TEXT} !~ /Ananova/ } @$progs;
    
    # Turn each list of bits of text into a proper set of programme
    # details.
    #
    my @r;
    foreach (@progs) {
	my $e = extract_progs($_);
	push @r, @$e if $e;
    }
    
    if (not @r) {
	warn "no programmes found in page";
	return \@r;
    }

    # Convert the 12 hour times into proper date-times.
    my $date = get_date_from_page($html);
    if (not defined $date) {
	# Ananova sometimes does this - listings for a particular day
	# and channel are not given.  (Well, carlton/day1/ch5,
	# anyway.)  Are they just trying to annoy me?
	#
	warn "cannot find date in page, skipping whole page";
	return [];
    }

    date_programmes(\@r, $date);
    return \@r;
}


# date_programmes()
#
# Given a list of programme details (from extract_progs()) and the date
# of this listing, remove the silly 12 hour times and add proper time
# and date for each programme.  In UT.
#
# Parameters:
#   reference to list of programme details
#   date in Date::Manip format
#
# Modifies the list passed in, so that each programme no longer has
# {'time'} but has {'start'} instead.
#
sub date_programmes($$) {
#    local $Log::TraceMessages::On = 1;
    die 'usage: date_programmes(ref to list of programmes, date)'
      if @_ != 2;
    my ($progs, $base_date) = @_;
    my $base_day = UnixDate $base_date, '%Q';
    die 'bad base day, format should be YYYYMMDD'
      if $base_day !~ /^\d{8}$/;

    my $prev_date;
    my $day_later = ParseDateDelta('+1 day') or die;
    my $current_tz = 0; # not undef, because of Memoize complaining
  
    foreach (@$progs) {
	t('adding date to programme ' . d($_));
	my $t = time12to24($_->{'time'});
	
	# $t should be hours and minutes, add seconds
	$t =~ s/\b(\d\d):(\d\d)\b/$1:$2:00/ or die "bad hh:mm $t";

	if (defined gettz($t)) {
#	    local $Log::TraceMessages::On = 1;
	    t "found explicit timezone $t, using for future progs";
	    $current_tz = gettz($t);
	}

	t "doing 24h UK time $t with base day $base_day";
	my $prog_date = parse_uk_date("$base_day $t", $current_tz);
	if (not defined $prog_date) {
	    # It's not a valid UK time.  Two reasons for this: it
	    # really isn't, or we're just confused about what day it
	    # is and need to 'jump' forward a day.
	    #
	    t 'that date is bad, maybe need to jump a day?';
	    my $err;
	    my $new_base_day = UnixDate
	      DateCalc($base_day, $day_later, \$err),
	      '%Q';
	    die "error from DateCalc(): $err" if defined $err;
	    my $new_prog_date = parse_uk_date("$new_base_day $t", $current_tz);
	    die "bad base day + time '$t' (even tried next day)"
	      if (not defined $new_prog_date) or ($new_prog_date !~ /\S/);
	    t 'okay... assume we will jump a day (do it later)';
	}

	if ((not defined $prog_date)
	    or (defined $prev_date
		and (Date_Cmp($prev_date, $prog_date) > 0) ) )
        {
	    # Seem to have jumped backwards in time.  Must be the next
	    # day.
	    #
	    t 'time is lower than before';
	    my $prev_day = UnixDate $prev_date, '%Q';
	    t 'previous programme was at ' . d($prev_date);
	    my $threshold = ParseDate("$prev_day 12:00:00");
	    t 'threshold is ' . d($threshold);
	    if (Date_Cmp($prev_date, $threshold) < 0) {
		# I can't believe that one programme would last from
		# before 12:00 until after midnight on any day.  So
		# this seeming jump to the next day is bogus - it's
		# the same day but the time is a little bit earlier
		# for some reason.  (Probably UT/BST switching)
		#
		t 'previous programme started before threshold, ' .
		  'cannot be next day';
	    }
	    else {
		t 'must be next day';
		my $err;
		$base_day = UnixDate
		  DateCalc($base_day, $day_later, \$err),
		  '%Q';
		die "error from DateCalc(): $err" if defined $err;
		$prog_date = parse_uk_date("$base_day $t", $current_tz);
		die "bad base day + time '$t'"
		  if (not defined $prog_date) or ($prog_date !~ /\S/);
		t 'new base day: ' . d($base_day);
	    }
	}

	delete $_->{'time'};
	$_->{'start'} = $prog_date;
	t 'new start time: ' . d($_->{start});
	$prev_date = $prog_date;
    }
}

    
# extract_progs()
#
# Given a programme or clump of programmes as a ref to a list of bits
# of text, each with 'bold' and 'italic' flags, return a ref to a list
# where each element is a hashref of time, title, sub_title,
# and desc for one programme.  (But see add_clumpidx())
#
sub extract_progs($) {
    die 'usage: extract_progs(list of bits of text)' if @_ != 1;
    my $bits = shift;
    t 'extract_progs() looking at ' . d $bits;
    my @r;

    my $p = {}; # hashref of current programme being built up

    # Subroutine to sanity-check a programme before we add it to @r
    # Probably not scoped properly, but who cares
    #
    sub check_p($) {
	my $p = shift;
	t('check_p() checking programme ' . d($p));
	my ($tm, $tl) = (defined $p->{time}, defined $p->{title});
	if (not $tm and not $tl) {
	    warn "found strange junk";
	    return 0;
	}
	elsif (not $tm and $tl) {
	    warn "no time found for programme $p->{title}";
	    return 0;
	}
	elsif ($tm and not $tl) {
	    $p->{title} = '(unknown title)';
	    return 1;
	}
	elsif ($tm and $tl) {
	    return 1;
	}
	else { die }
    }

    foreach (@$bits) {
	my ($b, $i, $t) = @$_{'bold', 'italic', 'TEXT'};

	# Clean up some of the mess from the HTML
	$t =~ s/\xa3((?:\d|,)*)/($1 ne '') ? "$1 pounds" : ''/ge;
	$t =~ s/\Q&nbsp;\E/ /g;

	# Skip empty bits of text
	$t =~ s/^\s+//; $t =~ s/\s+$//; next if $t eq '';

	# XML::Simple turns '&' into '&amp;', but nsgmls -wxml doesn't
	# like this.  Kludge round the problem by getting rid of '&'
	# altogether.
	#
	$t =~ s/\s*\Q\&amp\;\s*\E/ and /g;
	$t =~ s/\s*\Q&\E\s*/ and /g;

	if ($b and not $i and istime($t)) {
#	    local $Log::TraceMessages::On = 1;
	    t 'found time: ' . d($t);
	    die "time already set to $p->{time} but $t found"
	      if defined $p->{time};
	    $p->{time} = $t;
	}
	elsif ($b and not $i and $t =~ /^\(.+\)$/) {
	    # (888) or similar, ignore
	    # But (Film) ends up as sub-title, fixed by specials
	}
	elsif ($b and not $i) {
#	    local $Log::TraceMessages::On = 1;
	    t 'found bold and not italic: ' . d($t);
	    while ($t =~ s/^( \S+:\s* | ) \( ( BST | UT | GMT ) \) \s*/$1/x) {
		my $tz = $2;
		t 'found timezone: ' . d($tz);
		if (not defined $p->{time}) {
		    warn "timezone $tz found in description, but no time";
		}
		elsif (defined gettz($p->{time})) {
		    warn("timezone $tz found in description, " .
			 "but time $p->{time} already has timezone");
		}
		else {
		    $p->{time} .= " $tz";
		    t 'added timezone to $p->{time}, now ' . d($p->{time});
		}
	    }

	    $t =~ s!/! / !g;
	    if (not defined $p->{title}) {
		$p->{title} = $t;
	    }
	    else {
		# A small programme tacked onto the end of another.
		# Finish the current %p and start a new one.
		#
		if (check_p($p)) {
		    push @r, $p;
#		    t('\@r now ' . d(\@r));
		}
		else {
		    # check_p() gives its own error
		    warn "ignoring programme"; 
#		    t('\@r remains ' . d(\@r));
		}

		# Start a new programme from now on - same time though
		$p = { title => $t, time => $p->{time} };
	    }
	}
	elsif ($i and not $b) {
	    warn "italic text $t found, but no title yet - ignoring", next
	      if not defined $p->{title};
	    
	    $t =~ s!/! / !g;
	    if ($t =~ /^Generic[\s.]/) {
		# Ignore.
	    }
	    elsif ($t =~ /^Director: (.+)\.$/) {
		warn "italic text $t found, but director already defined - ignoring", next
		  if defined $p->{credits}->{director};
		$p->{credits}->{director} = [ $1 ];
	    }
	    else {
		# Must be sub-title.
		warn "italic text $t found, but sub-title already defined - ignoring", next
		  if defined $p->{sub_title};
		$p->{sub_title} = $t;
	    }
	}
	elsif (not $b and not $i) {
	    next if $t eq 'VIDEO REPORTS'; # ugh
	    if (not defined $p->{desc}) { $p->{desc} = $t }
	    else                        { $p->{desc} .= "; $t" }
	}
	else { die }
    }
		
    if (check_p($p)) {
	push @r, $p;
    }
    else {
	# check_p() gives its own error
	warn "ignoring programme"; 
    }
    return \@r;
}


# boldit()
#
# Convert HTML to a list of bits of text.  Each bit has 'bold' and
# 'italic' flags.  Bits which are inside <a> tags are ignored.
#
# Parameters: string of HTML
#
# Returns: ref to list of chunks, where each chunk looks like:
#   { 'bold' => x, 'italic' => x, 'TEXT' => text }
#
sub boldit($) {
    die 'usage: boldit(html string)' if @_ != 1;
    my $html = shift;
    
    use HTML::TokeParser;
    my $p = new HTML::TokeParser(\$html) or die;

    # HTML::TokeParser is based on HTML::Parser, and has the same
    # tendency to break chunks of text into multiple tokens.  Turn
    # that off. 
    #
    $p->unbroken_text(1);

    my @r = ();
    my ($bold, $it) = (0, 0);
    while (my $t = $p->get_token()) {
	if    ($t->[0] eq 'S' and $t->[1] eq 'b') { $bold = 1 }
	elsif ($t->[0] eq 'S' and $t->[1] eq 'i') { $it   = 1 }
	elsif ($t->[0] eq 'S' and $t->[1] eq 'a') { $a    = 1 }
	elsif ($t->[0] eq 'E' and $t->[1] eq 'b') { $bold = 0 }
	elsif ($t->[0] eq 'E' and $t->[1] eq 'i') { $it   = 0 }
	elsif ($t->[0] eq 'E' and $t->[1] eq 'a') { $a    = 0 }
	elsif ($t->[0] eq 'T' and not $a) {
	    $t->[1] =~ s/^\s+//; $t->[1] =~ s/\s+$//;
	    next if $t->[1] eq '';
	    push @r, { bold => $bold, italic => $it,
		       TEXT => $t->[1] };
	}
    }

    return \@r;
}


# splitlist()
#
# Split a list at particular elements.
#
# Parameters:
#   subroutine that given an element, returns true or false
#   ref to list
#
# Returns:
#   ref to list of refs to sublists
#
# The first sublist starts at the first element of the input list, and
# continues up to but not including the first element that gave true;
# the second sublist starts at this point, and so on.
#
sub splitlist($$) {
    die 'usage: splitlist(sub, ref to list)' if @_ != 2;
    my ($p, $l) = @_;
    my @r = ();

    my @firstlist = ();
    while (@$l and not $p->($l->[0])) {
	push @firstlist, (shift @$l);
    }
    push @r, \@firstlist;
    
    while (@$l) {
	my @sublist;
	@sublist = ();
	push @sublist, (shift @$l);
	while (@$l and not $p->($l->[0])) {
	    push @sublist, (shift @$l);
	}
	push @r, \@sublist;
    }
    
    return \@r;
}


# istime()
#
sub istime($) {
    die 'usage: istime(possible time string)' if @_ != 1;
    local $_ = shift;
    die if not defined;

    my $tz = gettz($_);
    s/\Q$tz\E// if defined $tz;

    s/\s+//g;
    /^(\d\d?)([.:]?)(\d\d)(am|pm|)$/ or return 0;
    my ($hours, $sep, $mins, $ampm) = ($1, $2, $3, $4);
    return ($sep ne '' || $ampm ne '');
}


# time12to24()
#
# Convert a 12 hour time string to a 24 hour one, without anything too
# fancy.  In particular the timezone is passed through unchanged.
#
sub time12to24($) {
    die 'usage: time12to24(12 hour time string)' if @_ != 1;
    local $_ = shift;
    die if not defined;
    
    # Remove the timezone and stick it back on afterwards.
    my $tz = gettz($_);
    s/\Q$tz\E// if defined $tz;

    s/\s+//;
    my ($hours, $mins, $ampm) = /^(\d\d?)[.:]?(\d\d)(am|pm)$/
      or die "bad time $_";
    if ($ampm eq 'am') {
	if (1 <= $hours and $hours < 12) {
	    $hours = $hours;      # 5am = 05:00
	}
	elsif ($hours == 12) {
	    $hours = 0;           # 12am = 00:00
	}
	else { die "bad number of hours $hours" }
    }
    elsif ($ampm eq 'pm') {
	if ($hours == 12) {
	    $hours = 12;          # 12pm = 12:00
	}
	elsif (1 <= $hours and $hours < 12) {
	    $hours = 12 + $hours; # 5pm = 17:00
	}
	else { die "bad number of hours $hours" }
    }
    else { die }

    my $r = sprintf('%02d:%02d', $hours, $mins);
    $r .= " $tz" if defined $tz;
    return $r;
}


# get_date_from_page()
#
# Returns date (in Date::Manip format) from Ananova page, or undef if
# none found.
#
sub get_date_from_page($) {
    die 'usage: get_date_from_page(html string)' if @_ != 1;
    my $html = shift;

    my ($pd, $pd_day_later);
    my $p = HTML::TokeParser->new(\$html) or die;
    while (my $token = $p->get_tag('span')) {
	if ($token->[1]->{class} eq 'title') {
	    # The day is mentioned in something looking like: <span
	    # class="title"><small><small><br>Sun</small></small></span>. 
	    # Check for this sequence of tokens.
	    #
	    t 'found <span class="title">';
	    my $t = $p->get_token();
	    t 'next token: ' . d $t;
	    next if $t->[0] ne 'S' or $t->[1] ne 'small';
	    t 'okay...';

	    $t = $p->get_token();
	    t 'next token: ' . d $t;
	    next if $t->[0] ne 'S' or $t->[1] ne 'small';
	    t 'okay...';

	    $t = $p->get_token();
	    t 'next token: ' . d $t;
	    next if $t->[0] ne 'S' or $t->[1] ne 'br';
	    t 'okay...';

	    $t = $p->get_token();
	    t 'next token: ' . d $t;
	    next if $t->[0] ne 'T';
	    my $text = $t->[1];
	    t 'got text: ' . d $text;
	    next if $text =~ /^\s*$/;

	    # Just sanity check now.
	    t 'okay, try to use it as the date for this page';
	    my $new_pd = parse_dofw($text);
	    if (not defined $new_pd) {
		warn "text $text doesn't parse to a valid date";
	    }
	    elsif (not defined $pd) {
		t 'first date found in this page';
		t 'setting date for page to: ' . d $new_pd;
		$pd = $new_pd;
		$pd_day_later = DateCalc($pd, '+1 day');
	    }
	    elsif ($pd eq $new_pd) {
		t 'same date as before';
	    }
	    elsif ($pd_day_later eq $new_pd) {
		t 'one day later than old date, must be "wee hours"';
	    }
	    else {
		warn "date already set to $pd, day later is $pd_day_later, but text $text found, which is $new_pd";
	    }
	}
    }
    return $pd;
}


# write_programme()
#
# Write details for a single programme as XML.
#
# Parameters:
#   XML::Writer object
#   reference to hash of programme details (a 'programme')
#
sub write_programme($$) {
    die 'usage: write_programme(XML::Writer, programme)' if @_ != 2;
    my ($w, $p) = @_;
    die if not defined $w or not defined $p;
    t('write_programme(' . d($w) . ', ' . d($p) . ') ENTRY');
    
    my ($channel, $start, $title, $sub_title, $desc, $credits, $category)
      = @$p{qw(channel start title sub_title desc credits category)};
    foreach ($start, $channel, $title) {
	die if (not defined) or (not /\S/);
    }
    
    # The dates are converted to the appropriate timezone for output.
    die if defined $p->{end}; # end times are added by sort_listings now
    if (defined $p->{clumpidx}) {
	$w->startTag('programme', start    => join(' ', @{date_to_uk($start)}),
		                  clumpidx => $p->{clumpidx},
		                  channel  => $channel );
    }
    else {
	$w->startTag('programme', start   => join(' ', @{date_to_uk($start)}),
			          channel => $channel );
    }

    $w->dataElement('title', $title, lang => $LANG);
    $w->dataElement('sub-title', $sub_title, lang => $LANG)
      if defined $sub_title;

    if (defined $desc and $desc =~ /\S/) {
	$desc =~ s/^\s+//; $desc =~ s/\s+$//;
	$w->dataElement('desc', $desc, lang => $LANG);

	# I'd like to line-wrap this so that the generated XML is
	# pleasant to read.  I have a private version of XML::Writer
	# which supports a dataElement_block() method for nicely
	# formatted output, but for the time being we'll just use the
	# standard version.  One day I will tidy up what I wrote and
	# submit it to the XML::Writer maintainer.
	#
#	$w->dataElement_block('desc', $desc, lang => $LANG)
    }

    if (defined $credits) {
	$w->startTag('credits');
	foreach (qw[director actor writer adapter producer presenter
		    commentator] )
	{
	    next unless defined $credits->{$_};
	    my @people = @{$credits->{$_}};
	    if ($_ eq 'director' and @people > 1) {
		die "more than one director"; # not allowed by DTD
	    }

	    foreach my $person (@people) {
		die if not defined $person;
		$w->dataElement($_, $person);
	    }
	}
	$w->endTag('credits');
    }

    $w->dataElement('date', $p->{date})
      if defined $p->{date};
    $w->dataElement('category', $category, lang => $LANG)
      if defined $category;
    $w->dataElement('language', $LANG);
    $w->endTag('programme');
}


# special_4learning()
#
# Channel Four's '4Learning' is a collection of several programmes
# stuffed into one entry.  Times and titles are given as part of the
# description.  This attempts to decode the description and make
# individual programmes.
#
# Parameters: a 'programme' hash reference
# Returns: reference to list of sub-programmes, or undef if programme 
#          was not '4learning'
#
sub special_4learning($) {
    die "usage: special_4learning(hashref of programme details)"
      if @_ != 1;
    my $p = shift;
    return undef if $p->{title} ne '4Learning';

    local $_ = $p->{desc};
    my @words = split;
    my @r;

    my $day = ParseDate(UnixDate($p->{start}, '%Q'));
    die if not defined $day;
#    t("day is $day");

    # Can't use istime() in this case - it's too liberal.
    sub is_4learning_time($) {
	die 'usage: is_4learning_time(suspected time string)'
	  if @_ != 1;
	local $_ = shift;
	/^\d\d?\.\d\d$/;
    }

    while (@words) {
	my $time = shift @words;
	if (is_4learning_time($time)) {
	    if ($time =~ /^\d\.\d\d$/) {
		$time = "0$time"; # 4-digit, 24-hour
	    }
	    $time =~ tr/./:/;
#	    t("time of bit is $time");

	    my (@title_words, @desc_words);
	    my $start = Date_SetTime($day, $time);
	    if (not defined $start or $start !~ /\S/) {
		warn "skipping bogus 4learning time string $time";
		# Add it to the desc, so it doesn't get lost
		push @desc_words, $time;
		next;
	    }
		
#	    t("complete time and date is $start");
	    
	    my $curr_prog;
	    $curr_prog->{start} = $start;
	    $curr_prog->{channel} = $p->{channel};
	    my $done_title = 0;
	    while (@words) {
		my $word = shift @words;

		if (is_4learning_time($word)) {
		    # Finished this bit of 4learning.
		    unshift @words, $word;
		    last;
		}
		elsif (not $done_title) {
		    if ($word =~ s/[.?]$//) {
			# Finished the title, move on to description.
			$done_title = 1;
		    }
		    push @title_words, $word;
		}
		else {
		    push @desc_words, $word;
		}
	    }

	    # The title sometimes looks like 'History in Action: Women
	    # in the 20th Century'; this should be broken into main
	    # title and secondary title.  But not 'GNVQ: Is It For You
	    # 2'.  So arbitrarily we check that the main title has at
	    # least two words.
	    #
	    if (@title_words) {
		my (@main_title_words, @sub_title_words);
		while (@title_words) {
		    my $word = shift @title_words;
		    my $main_title_length = @main_title_words + 1;
		    if ($main_title_length >= 2 and $word =~ s/:$//) {
			push @main_title_words, $word;
			@sub_title_words = @title_words;
			last;
		    }
		    else {
			push @main_title_words, $word;
		    }
		}

		$curr_prog->{title} = join(' ', @main_title_words);
		$curr_prog->{sub_title} = join(' ', @sub_title_words)
		  if @sub_title_words;
	    }

	    $curr_prog->{desc} = join(' ', @desc_words)
	      if @desc_words;
	    push @r, $curr_prog;
	}
	else {
	    warn "expected time in 4learning description, got $time";
	    # Add it to the previous programme, so it doesn't get lost
	    if (@r) {
		$r[$#r]->{desc} .= " $time";
	    }
	}
    }

    return \@r;
}


# special_presenter()
#
# Try to sniff out presenter info from the start of the description
# and put it into the credits section instead.
#
# Parameters: one programme (hashref)
# Returns: [ modified programme ], or undef
#
# May modify the programme passed in, if return value is not undef.
# But that's okay for a special-case handler.
#
sub special_presenter($) {
    die 'usage: special_presenter(programme hashref)' if @_ != 1;
    my $p = shift;
#    local $Dbg::On = 1 if $p->{title} =~ /Network East/;
    
    for ($p->{desc}) {
	return undef if not defined;
#	t("testing desc: $_");

	if (s/\b([pP])resenteed\b/$1resented/g) {
	    # First of all, fix spelling mistakes!
	    return [ $p ];
	}

	if (s/^With ($NAME_RE)\.\s+// or
	    s/^($NAME_RE) introduces (\w)/uc $2/e )
	{
	    # Why unshift instead of push?  Because the presenter
	    # mentioned first is probably the most important, and
	    # we give credits in decreasing order of importance.
	    #
	    unshift @{$p->{credits}->{presenter}}, $1;
	    return [ $p ];
	}

	if (s<,?\s*[pP]resented by\s+()($NAMES_RE)\b\s*(.|,?\s+\w|\Z)>
	    <uc $3>e
	    or
	    s<(\.\s+|^\s*)($NAMES_RE)\s+presents?\b\s*(.|,?\s+\w|\Z)>
	    <$1.uc $3>e )
	{
#	    t("presenter0: '$2'");
	    unshift @{$p->{credits}->{presenter}}, list_names($2);
	    s/,\s*$//;
	    s/,\s*,/,/;
	    s/\s+\./\./;
	    return [ $p ];
	}

	if (s/(^|\.\s+)[pP]resenters?\s+($NAMES_RE)/$1/) {
	    unshift @{$p->{credits}->{presenter}}, list_names($2);
	    return [ $p ];
	}

	if (s/,?\s*[cC]o-?presenters?\s+($NAMES_RE)//) {
#	    t("found co-presenters '$1'");
	    unshift @{$p->{credits}->{presenter}}, list_names($1);
	    return [ $p ];
	}

	if (s/,?\s*[iI]ntroduced\s+by\s+($NAMES_RE)//) {
	    unshift @{$p->{credits}->{presenter}}, list_names($1);
	    return [ $p ];
	}

	if (s/^\s*With\s+($NAMES_RE)//) {
	    unshift @{$p->{credits}->{presenter}}, list_names($1);
	    return [ $p ];
	}

	if (s/^\s*($NAME_RE)\s+(?:explores|examines)\s*//) {
	    unshift @{$p->{credits}->{presenter}}, $1;
	    s/^(\w)/uc $1/e;
	    return [ $p ];
	}

	# Leave 'virtual presenter', 'aquatic presenter',
	# 'new presenter', 'guest presenter', etc. alone for now
	#
    }
    return undef;
}


# special_actor(): like special_presenter().
sub special_actor($) {
    die 'usage: special_actor(programme hashref)' if @_ != 1;
    my $p = shift;

    for ($p->{desc}) {
	return undef if not defined;
#	t("testing desc: $_");
	if (s/^($NAME_RE) stars in\s+(?:this\s+)(\w)?/uc $2/e or
	    s/($NAME_RE) (?:co-)?stars\.?\s*$// )
	{
	    unshift @{$p->{credits}->{actor}}, $1;
	    return [ $p ];
	}
	if (s/(?:^|,|\.)\s*[wW]ith\s*($NAMES_RE)//) {
	    # Okay, this might not be actors, but we'll assume it is.
	    unshift @{$p->{credits}->{actor}}, list_names($1);
	    return [ $p ];
	}
	if (s/,?\s*(?:also\s+)?starring\s+($NAMES_RE)\s*$//) {
	    unshift @{$p->{credits}->{actor}}, list_names($1);
	    return [ $p ];
	}
	if (s/^\s*($NAME_RE)\s+stars\s+as\s+//) {
	    unshift @{$p->{credits}->{actor}}, $1;
	    s/^(\w)/uc $1/e;
	    return [ $p ];
	}
    }
    return undef;
}
    

# special_guest(): more of the same.
sub special_guest($) {
    die 'usage: special_guest(programme hashref)' if @_ != 1;
    my $p = shift;

    for ($p->{desc}) {
	return undef if not defined;
#	t("testing desc: $_");
	if (s/,?\s*[wW]ith\s+guests\s+($NAMES_RE)//) {
	    unshift @{$p->{credits}->{guest}}, list_names($1);
	    return [ $p ];
	}
    }
    return undef;
}


# special_radio4()
#
# Split Radio 4 into FM and LW.
#
sub special_radio4($) {
    die 'usage: special_radio4(programme)' if @_ != 1;
    my $p = shift;
    return undef if $p->{channel} ne 'radio4';

    for ($p->{title}) {
	if (s/^\(FM\)\s+//) {
	    $p->{channel} = 'radio4-fm';
	    return [ $p ];
	}
	if (s/^\(LW\)\s+//) {
	    $p->{channel} = 'radio4-lw';
	    return [ $p ];
	}
	
	my %fm = ( %$p, channel => 'radio4-fm' );
	my %lw = ( %$p, channel => 'radio4-lw' );
	return [ \%fm, \%lw ];
    }
}


# special_split_title()
#
# In addition to the 'programme tacked onto the end of another'
# handled by add_clumpidx, you also sometimes see two programmes
# totally sharing an entry.  For example 'News; Shipping Forecast'.
#
sub special_split_title($) {
    die 'usage: special_split_title(programme)' if @_ != 1;
    my $p = shift;
    return undef if $p->{title} !~ tr/;//;
    
    # Split the title at ; and make N identical programmes one with
    # each title.  The programme details are given to only the last of
    # the programmes - in the listings data we're getting, normally
    # the insignificant programme comes first with the main feature
    # last, as in 'News; Radio 3 Lunchtime Concert'.
    #

    # List of elements which are meta-data and should be kept for all
    # the programmes we split into - the rest are given only to the
    # last programme.
    #
    my %meta = (start => 1, stop => 1, 'pdc-start' => 1,
		'vps-start' => 1, showview => 1, videoplus => 1,
		channel => 1);
    # but not clumpidx!

    my %p_meta;
    foreach (grep { $meta{$_} } keys %$p) {
	$p_meta{$_} = $p->{$_};
    }

    my @r;
    my @titles = split /\s*;+\s*/, $p->{title};
    for (my $i = 0; $i < @titles - 1; $i++) {
	push @r, { %p_meta,
		   title => $titles[$i],
		   clumpidx => ( "$i/" . scalar @titles ) };
    }
    push @r, { %$p,
	       title => $titles[$#titles],
	       clumpidx => ("$#titles/" . scalar @titles) };
    
    return \@r;
}


# special_film()
#
sub special_film($) {
    die 'usage: special_film(programme)' if @_ != 1;
    my $p = shift;
    if (not defined $p->{sub_title} or $p->{sub_title} ne '(Film)') {
	return undef;
    }
    
    warn "replacing category $p->{category} with 'film'"
      if defined $p->{category};
    $p->{category} = 'film';
    undef $p->{sub_title};

    if (defined $p->{desc} and $p->{desc} =~ s/^(\d{4})\s+//) {
	warn "found year $1 in description, replacing date $p->{date}"
	  if defined $p->{date};
	$p->{date} = $1;
    }

    return [ $p ];
}


# add_clumpidx()
#
# Sometimes two programmes on a channel are given the same
# start time in the listings.  This seems to happen when the
# first is a 'mothership' containing several smaller things,
# for example '11:00 The Core, 11:00 Core News'.
#
# We add a 'clumpidx' attribute to distinguish these
# programmes.  Eg 'The Core' has clumpidx '0/2' and 'Core
# News' has '1/2'.
#
# See also special_split_title() which handles a similar problem.
#
# Parameters:
#   a reference to a list of programmes for one channel, which will
#   be modified
#
#   a reference to a 'relation' scalar.  Programmes sharing a clump are
#   in this relation together.  This scalar will be modified.
#
sub add_clumpidx($$) {
    die "usage: add_clumpidx(ref to list of programmes, 'related' hashref)"
      if @_ != 2;
    my ($progs, $related) = @_;
    t('add_clumpidx() ENTRY');

    my $last_start;
    my %num_in_clump; # Maps start time to num. progs at that time
    foreach (@$progs) {
	t 'looking at programme: ' . d($_);
	my $start = $_->{start};
	t '$start=' . d($start);
	$_->{clumpidx} = $num_in_clump{$start}++;
	t 'clumpidx now ' . d($_->{clumpidx});

	if ($num_in_clump{$start} > 1) {
	    if (not defined $last_start or $last_start ne $start) {
		warn <<END
more than one programme at $start on same channel, \
but not consecutive in listings (this is $_->{title})
END
				 ;
	    }
	}
	$last_start = $start;
    }
    
    # Okay, we've got clumpidx of '0', '1' where needed, but even
    # better would be '0/2', '1/2'.  We look at how many programmes
    # are in each clump: if only one, remove the clumpidx entirely.
    # If more than one, put the full 'x/y' clumpidx and additionally
    # make a note to updated the %{$related} hash.
    #
    t "refine clumpidx's and build todo list";
    my %todo;
    foreach (@$progs) {
	t 'looking at programme: ' . d($_);
	my $start = $_->{start};
	my $num = $num_in_clump{$start};
	die if not defined $_->{clumpidx};
	if ($num == 1) {
	    # Ordinary, sane programme not sharing its slot.  This
	    # would have a clumpidx of '0/1', which isn't worth
	    # putting in the output.
	    #
	    t 'only programme in slot';
	    die if $_->{clumpidx} ne '0';
	    delete $_->{clumpidx};
	}
	elsif ($num > 1) {
	    t 'shares a slot';
	    $_->{clumpidx} .= "/$num";
	    t 'new clumpidx: ' . d($_->{clumpidx});
	    push @{$todo{$start}}, $_;
	    t "\$todo{$start} now " . d($todo{$start});
	}
	else { die }
    }

    # Update $related
    t 'updating $related from todo list';
    foreach (keys %todo) {
	t 'todo list for ' . d($_);
	my @l = @{$todo{$_}};
	t 'list of programmes: ' . d(\@l);
	foreach my $ai (0 .. $#l) {
	    foreach my $bi ($ai+1 .. $#l) {
		my $a = $l[$ai]; my $b = $l[$bi];
		t "$a and $b related";
		die if "$a" eq "$b";
		warn "$a, $b over-related" if related($related, $a, $b);
		relate($related, $a, $b);
	    }
	}
    }

    t 'add_clumpidx() EXIT';
}


# Routines to handle a symmmetric 'relation'.  This is used to keep
# track of which programmes are sharing a clump so that fix_clumps()
# can sort them out if needed.
#
sub new_relation() {
    die 'usage: new_relation()' if @_;
    my %h; tie %h, 'Tie::RefHash';
    return \%h;
}
sub related($$$) {
    die 'usage: related(relation, a, b)' if @_ != 3;
    my ($rel, $a, $b) = @_;
    my $list = $rel->{$a};
    return 0 if not defined $list;
    foreach (@$list) {
	return 1 if "$_" eq "$b";
    }
    return 0;
}
sub relate($$$) {
    die 'usage: related(relation, a, b)' if @_ != 3;
    my ($rel, $a, $b) = @_;
    unless (related($rel, $a, $b)) {
	push @{$rel->{$a}}, $b;
	push @{$rel->{$b}}, $a;
    }
}
sub unrelate($$$) {
    die 'usage: related(relation, a, b)' if @_ != 3;
    my ($rel, $a, $b) = @_;
    die unless related($rel, $a, $b) and related($rel, $b, $a);
    @{$rel->{$a}} = grep { "$_" ne "$b" } @{$rel->{$a}};
    @{$rel->{$b}} = grep { "$_" ne "$a" } @{$rel->{$b}};
}    
sub nuke_from_rel($$) {
    die 'usage: nuke_from_rel(relation, a)' if @_ != 2;
    my ($rel, $a) = @_;
    die unless ref($rel) eq 'HASH';
    foreach (@{relatives($rel, $a)}) {
	die unless related($rel, $a, $_);
	unrelate($rel, $a, $_);
    }

    # Tidy up by removing from hash
    die if defined $rel->{$a} and @{$rel->{$a}};
    delete $rel->{$a};
}
sub relatives($$) {
    die 'usage: relatives(relation, a)' if @_ != 2;
    my ($rel, $a) = @_;
    die unless ref($rel) eq 'HASH';
    if ($rel->{$a}) {
	return [ @{$rel->{$a}} ]; # make a copy
    }
    else {
	return [];
    }
}


# fix_clumps()
#
# When a programme sharing a clump has been modified by one of the
# 'special handler' kludges, patch things up so that other things in
# the clump are consistent.
#
# This is to handle one particular problem - a compound '4Learning'
# programme followed (without giving a new time) by 'Driven'.  Ugh.
# But it should do something sensible most of the time, or moan that
# it cannot.  You can just ignore this whole subroutine.
#
sub fix_clumps($$$) {
    die 'usage: fix_clumps(old programme, listref of replacements, clump relation)' if @_ != 3;
    my ($orig, $new, $rel) = @_;

    sub by_start { Date_Cmp($a->{start}, $b->{start}) }
    sub by_clumpidx {
	$a->{clumpidx} =~ m!^(\d+)/(\d+)$! or die;
	my ($ac, $n) = ($1, $2);
	$b->{clumpidx} =~ m!^(\d+)/$n$! or die;
	my $bc = $1;
	die "$a->{clumpidx} and $b->{clumpidx} do not sort"
	  if $ac == $bc;
	$ac <=> $bc;
    }
    sub by_date {
	by_start($a, $b)
	  || by_clumpidx($a, $b)
	    || die "programmes do not sort";
    }

    my @relatives = sort by_date @{relatives($rel, $orig)};
    my @new = sort by_date @$new;

    t 'how many programmes has $prog been split into?';
    if (@new == 0) {
	t 'deleted programme entirely!';
	if (@relatives) {
	    warn 'programme sharing a clump was deleted, '
	      . "this isn't handled";
	    
	    nuke_from_rel($rel, $orig);
	}
    }
    elsif (@new == 1) {
	t 'still exactly one programme';
	if (@relatives and "$new[0]" ne "$orig") {
	    t "programme sharing a clump was replaced, this isn't handled";
	    nuke_from_rel($rel, $orig);
	}
	else {
	    # Was _altered_ rather than replaced.  Keep in relation.
	}
    }
    elsif (@new >= 2) {
	t 'split into multiple programmes';
	nuke_from_rel($rel, $orig);
	
	if (@relatives) {
	    # Find where the original programme slotted into the clump
	    # and insert the new programmes there.
	    #
	    my @old_all = sort by_date ($orig, @relatives);
	    
	    my @new_all = ();
	    foreach (@old_all) {
		if ($_ == $orig) {
		    # Slot in the new programmes.
		    push @new_all, sort by_date @new;
		}
		else {
		    push @new_all, $_;
		}
	    }

	    # Now regenerate the clumpidx's.
	    while (@new_all) {
		my $first = shift @new_all;
		my @clump = ($first);
		my $start = $first->{start};
		while (@new_all) {
		    my $next = shift @new_all;
		    if ($next->{start} eq $start) {
			push @clump, $next;
		    }
		    else {
			unshift @new_all, $next;
			last;
		    }
		}
		my $clump_size = scalar @clump;
		for (my $i = 0; $i < $clump_size; $i++) {
		    my $c = $clump[$i];
		    if ($clump_size == 1) {
			delete $c->{clumpidx};
		    }
		    else {
			$c->{clumpidx} = "$i/$clump_size";
		    }
		}

		foreach my $a (@clump) {
		    foreach my $b (@clump) {
			next if $a == $b;
			relate($rel, $a, $b);
		    }
		}
	    }
	}
    }
}


# check_page_dates()
#
# Sometimes the site leaves out pages for a particular day, or gets
# them in the wrong order.  Attempt to work around this, and if that's
# not possible at least warn the user.
#
# Parameters: ref to list of HTML pages for a single channel.  Each
# page is a hashref with 'url' and 'text' - see pages_for_channel().
#
# Returns: ref to list of surviving pages, after removing duplicates
#
sub check_page_dates($) {
    die 'usage: check_page_dates(ref to list of HTML pages)'
      if @_ != 1;
    my @pages = @{shift()};
    my @r;
    my $last_date;
    my $day_later = ParseDateDelta('+1 day') or die;
    my (%seen, %missing);
    foreach (@pages) {
	my $date = get_date_from_page($_->{text});
	if (not defined $date) {
	    warn 'cannot find date in page, skipping page';
	    next;
	}
	my $date_p = UnixDate $date, '%Q';

	if (defined $last_date) {
	    my $err;
	    my $expected_date = DateCalc($last_date, $day_later, \$err);
	    my $expected_date_p = UnixDate $expected_date, '%Q';

	    die "error from DateCalc(): $err" if defined $err;
	    if (Date_Cmp($expected_date, $date) != 0) {
		warn "page $_->{url}, expected to be $expected_date_p,"
		  . "is $date_p";
		$missing{$expected_date}++;
	    }
	    if ($seen{$date}++) {
		warn "found page for $date_p, but already done - skipping";
		next;
	    }
	}
	
	push @r, $_;
	$last_date = $date;
    }

    foreach (keys %missing) {
	unless ($seen{$_}) {
	    my $p = UnixDate $_, '%Q';
	    warn "page for $p on this channel seems to be missing";
	}
    }

    return \@r;
}


# parse_dofw()
#
# Wrapper for Date::Manip's ParseDate(), which doesn't handle
# days-of-week the way I want.
#
sub parse_dofw($) {
    my $d = shift;
    my $today = ParseDate('today midnight');
    my $dp = ParseDate($d);
    if ($dp eq $today) {
	return $dp;
    }
    else {
	return ParseDate("next $d");
    }
}

