# splitlist()
#
# Split a list at particular elements.
#
# Parameters:
#   subroutine that given an element, returns true or false
#   ref to list
#
# Returns:
#   ref to list of refs to sublists
#
# The first sublist starts at the first element of the input list, and
# continues up to but not including the first element that gave true;
# the second sublist starts at this point, and so on.
#
sub splitlist($$) {
    die 'usage: splitlist(sub, ref to list)' if @_ != 2;
    my ($p, $l) = @_;
    my @r = ();

    my @firstlist = ();
    while (@$l and not $p->($l->[0])) {
	push @firstlist, (shift @$l);
    }
    push @r, \@firstlist;

    while (@$l) {
	my @sublist;
	@sublist = ();
	push @sublist, (shift @$l);
	while (@$l and not $p->($l->[0])) {
	    push @sublist, (shift @$l);
	}
	push @r, \@sublist;
    }

    return \@r;
}


# istime()
#
sub istime($) {
    die 'usage: istime(possible time string)' if @_ != 1;
    local $_ = shift;
    die if not defined;

    my $tz = gettz($_);
    s/\Q$tz\E// if defined $tz;

    s/\s+//g;
    /^(\d\d?)([.:]?)(\d\d)(am|pm|)$/ or return 0;
    my ($hours, $sep, $mins, $ampm) = ($1, $2, $3, $4);
    return ($sep ne '' || $ampm ne '');
}


# parse_dofw()
#
# Wrapper for Date::Manip's ParseDate(), which doesn't handle
# days-of-week the way I want.
#
sub parse_dofw($) {
    my $d = shift;
    my $today = ParseDate('today midnight');
    my $dp = ParseDate($d);
    if ($dp eq $today) {
	return $dp;
    }
    else {
	return ParseDate("next $d");
    }
}
