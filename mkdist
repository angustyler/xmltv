#!/usr/bin/perl -w
#
# $Id: mkdist,v 1.30 2003/02/10 16:52:34 jveldhuis Exp $
#
# This script is meant to be run in an empty directory, although
# it doesn't require it.
#
# This script checks out the latest head revision (by checking it
# out from scratch), checks version information in files,
# ignores files/dirs we don't want to release, tags the source
# files in cvs, generates a ChangeLog and generates the
# .tar.gz and .tar.bz2 files for release.
#
# It DOES NOT: post the files to sf, or email announcements, or
# update www pages, although it reminds you to do so :)
#
# -- jerry@matilda.com
#

use strict;
#use diagnostics;
use Getopt::Long;

#$SIG{__WARN__} = sub { die $_[0] };

my $debug;

# Temporary directory used for checking out a copy and building
# tarballs.  This is not meant to be race-condition-proof, so don't
# run mkdist as root :-).
#
my $TMP_CHECKOUT_DIR = "/tmp/mkdist$$";
if ( -d $TMP_CHECKOUT_DIR ) {
   print STDERR "$TMP_CHECKOUT_DIR already exists, aborting\n";
   exit 1;
}
mkdir($TMP_CHECKOUT_DIR, 0755) || die "cannot mkdir $TMP_CHECKOUT_DIR: $!";

sub Usage()
{
    print "mkdist --version <id> [options]\n";
    print "where options are:\n";
    print "    --version <id>   - creating version <id> (eg 0.1.2)\n";
    print "    --sfuser <login> - sourceforge login with cvs access\n";
    print "                       defaults to first xmltv login in ~/.cvspass\n";
    print "    --help           - this usage message\n";
    print "    --debug          - print debug messages as we go\n";
    print "    --login          - perform cvs login to refresh/verify cvs access\n";
    print "    --step           - step by step confirmation of commands\n";
}

use vars qw/$opt_help $opt_debug $opt_sfuser $opt_login $opt_version $opt_step/;

if ( ! GetOptions('help', 'debug', 'sfuser=s', 'login', 'version=s', 'step') ) {
    Usage();
    exit(1);
}

if ( defined($opt_help) ) {
    Usage();
    exit(0);
}

$debug=1 if ( defined($opt_debug) );

# Mimic Perl's system() in allowing either a single argument
# or a list of parameters (which means don't use the shell).
#
sub do_system(@)
{
    if ($opt_step) {
	print "@_ [yN]? ";
	my $reply = <STDIN>;
	return if $reply !~ /^[yY]/;
    }

    print "@_\n";
    my $rc=system(@_);
    if ( $rc != 0 ) {
	die "command failed: $rc";
    }
}

if ( !defined($opt_version) ) {
   print STDERR "missing required argument --version, use --help for details\n";
   exit(1);
}
if ( !defined($opt_sfuser) ) {
   if ( open(FD, "< $ENV{HOME}/.cvspass") ) {
	while (<FD>) {
	   if ( m/^:pserver:([^\@]+)\@cvs.xmltv.sourceforge.net:/ ) {
	      $opt_sfuser=$1;
	      print "assuming --sfuser $1 from first xmltv entry in ~/.cvspass\n";
	      last;
	   }
        }
	close(FD);
        if ( !defined($opt_sfuser) ) {
	   print STDERR "failed to locate any appropriate entry in ~/.cvspass\n";
	}
   }
   else {
 	print STDERR "failed to locate any appropriate entry in ~/.cvspass\n";
   }
   if ( !defined($opt_sfuser) ) {
      print STDERR "missing required argument --sfuser, use --help for details\n";
      exit(1);
   }
}

print "Did you update the README and README.win32 files with release information?\n";
print "hit return to continue with mkdist, or ^C to stop here.";
my $junk=<>; # read return

print "opt_version=\"$opt_version\"\n" if ( $debug );

#if ( !($opt_version=~m/^\d+\.\d+$/o) && !($opt_version=~m/^\d+\.\d+\.\d+$/o) ) {
#    print STDERR "invalid version id, specify something of the form \"[0-9].[0-9]\" or \"[0-9].[0-9].[0-9]\"\n";;
#    exit(1);
#}

my $cvs_tag="V$opt_version";
$cvs_tag=~s/\./_/og;

print "version tag to use is: $cvs_tag\n" if ( $opt_debug );

# always use ssh for cvs access
$ENV{CVS_RSH}="ssh";

if ( defined($opt_login) ) {
    # use pserver to login
    $ENV{CVSROOT}=":pserver:$opt_sfuser\@cvs.xmltv.sourceforge.net:/cvsroot/xmltv";
    do_system("cvs login");
}

print "\nChecking out current head revision in $TMP_CHECKOUT_DIR/xmltv ..\n";

do_system("cd $TMP_CHECKOUT_DIR && CVS_RSH=ssh CVSROOT=\":ext:$opt_sfuser\@cvs.xmltv.sourceforge.net:/cvsroot/xmltv\" cvs -q co xmltv");

# Filename, and a regexp to capture the version in $1.
my %check_ver = ('README'           => q{^XMLTV\s+([^, ]+)},
		 'doc/README.win32' => q{^XMLTV\s+([^, ]+)},
		 'Makefile.PL'      => q{^\$VERSION\s*=\s*'(\S+)';},
		 'lib/XMLTV.pm.in'  => q{^\$VERSION\s*=\s*'(\S+)';},
		);
foreach my $f (keys %check_ver) {
    my $re = $check_ver{$f};
    $f = "$TMP_CHECKOUT_DIR/xmltv/$f";
    open(FD, $f) || die "cannot open $f: $!";
    my $got;
    while (<FD>) {
	chomp;
	if (/$re/) {
	    $got = $1; die if not defined $got;
	    if ($got ne $opt_version) {
		# I think it's better not to do anything clever, but
		# just let the user update the file.  -- epa
		die "$f:$.:found version $got, not $opt_version\n";
	    }
	    else { last }
	}
    }
    if (not defined $got) {
	die "could not find version number in $f\n";
    }
    close FD or die "cannot close $f: $!";
    print "Version number in $f is correct.\n";
}

print "\nremoving old tag $cvs_tag just in case\n";
do_system("cd $TMP_CHECKOUT_DIR/xmltv && cvs -q tag -d \"$cvs_tag\"");

my @toremove=grep { -e "$TMP_CHECKOUT_DIR/$_"
		      || (warn("$_ missing, but no matter\n"), 0) }
  map { "xmltv/$_" }
  qw(attic
     leon
     cgi
     todo
     MANIFEST.SKIP
     mkdist
     ChangeLog.old);

my $cmd="cd $TMP_CHECKOUT_DIR && tar cf save.tar ";
for my $f (@toremove) { $cmd.="$f "; }

$cmd.="`find xmltv -name CVS -type d`";

print "\ntemporarily removing files/dirs not for release..\n";
do_system($cmd);

# take easy route :)
do_system('rm', '-rf', map { "$TMP_CHECKOUT_DIR/$_" } @toremove);

print "\ngenerating ChangeLog..\n";
do_system("cd $TMP_CHECKOUT_DIR/xmltv && cvs2cl.pl --utc");

print "\ntagging release with $cvs_tag..\n";
do_system("cd $TMP_CHECKOUT_DIR/xmltv && cvs -q tag \"$cvs_tag\"");

print "\nremoving CVS dirs..\n";
do_system("cd $TMP_CHECKOUT_DIR && find xmltv -name CVS -type d -prune -exec rm -rf {} \\;");

chdir($TMP_CHECKOUT_DIR) || die "cannot chdir to $TMP_CHECKOUT_DIR: $!";
print "\nrenaming xmltv directory to xmltv-$opt_version..\n";
rename("xmltv", "xmltv-$opt_version");

print "\n";
do_system("tar cf - ./xmltv-$opt_version | gzip --best > xmltv-$opt_version.tar.gz");
do_system("tar cf - ./xmltv-$opt_version | bzip2 --compress --stdout > xmltv-$opt_version.tar.bz2");
print "\n";

print "\nrestoring files that won't be released..\n";
rename("xmltv-$opt_version", "xmltv");
unlink("xmltv/ChangeLog");
do_system("tar xpf save.tar");
unlink("save.tar");

print <<END
**** Files left in $TMP_CHECKOUT_DIR

To upload to Sourceforge:
  - ftp upload.sourceforge.net
  - log in as anonymous
  - cd incoming
  - binary
  - put xmltv-$opt_version.tar.bz2

Then to register this file as part of the release:
  - hit 'Admin' on xmltv project page on sf.
    <login may be required>
  - click on 'Edit/Release Files'
  - click 'Add Release' to package "xmltv" 
  - type in '$opt_version' in "New Release Name:", then click 'Create This
    Release' button.
    < brings up "Step 1: Edit Existing Release" page>

  Step 1
  ------
  - change status to "Hidden" (for now)
    In the release page, paste the README in as 'release notes', apart
    from the 'changes in this release' section of the README, which
    goes in the 'changelog' box, 
    NOTE: check the 'Preserve my pre-formatted text. ' box
    then click 'Submit/Refresh'
    <page refreshes>

  Step 2
  ------
  - choose the file(s) you uploaded, then click
    'Add Files and/or Refresh View' button
    <page refreshes>

  Step 3
  ------
  - set the file types (for example xmltv-$opt_version.tar.bz2 would have
    platform 'Any' and type 'Source bz2').
  - hit 'update' button

  - Toggle 'Status' in Step 1 to 'Active' and hit 'Submit/Refresh' button
    at the bottom of Step 1.
    < how hit 'Summary' button at top of page, you should see release
      show up >

Now update the XMLTV web page (Ed has to do this ATM).

Send a release announcement to xmltv-announce\@lists.sourceforge.net,
and update the Freshmeat entry <http://freshmeat.net/projects/xmltv/?topic_id=868>.
END
  ;
