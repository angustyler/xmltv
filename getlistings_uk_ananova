#!/usr/bin/perl -w
# 
# getlistings_uk_ananova
# 
# Get UK TV listings from the Ananova website, and output
# them in the format described by xmltv.dtd.
# 
# Like all programs which parse websites, this is likely to break if
# the Ananova site layout changes.  The current layout
# is fairly clean and fairly easy to parse; the approach taken is to
# read it like a human would, looking at the appearance of bits of
# text (bold, italic) to decide what they represent.
# 
# BUGS
# 
# One problem with British TV listings is the way that news reports
# and other short items are added to the end of longer programmes,
# without being given their own time.  For example you might have
# 'Urban Gothic; 5 News Update' in a single time slot.  In this case
# we discard the short item and print a warning to standard error.
# But this scheme breaks down when the second item is the main
# attraction, for example 'Children's BBC; Fixi and Foxi' where
# 'Children's BBC' is just a two-minute introduction.
# 
# A proper answer to this would probably involve extending the
# listings format so you have times which are 'just before' or 'just
# after' a certain time, for example 5 News Update would begin at
# 'just before' 21:00 and end at 21:00.
# 
# Not all the information in the website is extracted, for example we
# ignore the subtitles flag, aka '888'.
# 
# USAGE: run it and capture stdout.  Warnings about 'ignoring
# programme X tacked onto Y' are caused by the problem described
# above.  Any more serious warning or error is probably due to the PA
# changing their website - see if there is an updated version of this
# program.
# 
# The web pages are cached in web_cache.db and expire after 24 hours.
# 
# -- Ed Avis, epa98@doc.ic.ac.uk, 2000-10-05
# 

use strict;
use HTML::TokeParser;

# Date::Manip is used for parsing dates; all dates are stored
# internally in UT (aka GMT).
# 
use Date::Manip; Date_Init('TZ=UT');
require 'uk_tz.pl';

use LWP::Simple;
use XML::Writer;
use Fcntl;

# I have a module I use for trace messages; you can get it at
# <http://www.doc.ic.ac.uk/~epa98/lib/perl5/site_perl/Dbg.pm>.  That's
# what all the t('hello') type statements are.  But you can probably
# just leave them commented out.
# 
#use Dbg; $Dbg::On = 0;

# Memoize some subroutines if possible (25x speedup)
eval { require Memoize };
if ($@) {
    warn "could not load Memoize module, things will run slowly";
}
else {
    foreach (qw/istime time12to24 parse_uk_date date_to_uk bst_dates
	        gettz ParseDate UnixDate DateCalc Date_Cmp
                ParseDateDelta/)
    {
	Memoize::memoize($_) or die "cannot memoize $_: $!";
    }

    # Getting web pages is memoized, but they expire after 24 hours
    my $LIFETIME = 24 * 60 * 60; # in seconds
    Memoize::memoize('get', SCALAR_CACHE => ['TIE', 'Memoize::Expire',
					     LIFETIME => $LIFETIME,
					     TIE => [ 'DB_File',
						      'web_cache.db',
						      O_RDWR | O_CREAT,
						      0666 ] ]);
}



########
# Configuration

# %CHANNELS maps the names used by the Ananova site to the DNS-style
# names used internally and in the output.
# 

# Normal use
my %CHANNELS = (bbc1    => 'bbc1.bbc.co.uk',
		bbc2    => 'bbc2.bbc.co.uk',
		carlton => 'carlton.com',
		ch4     => 'channel4.com',
		ch5     => 'channel5.co.uk',
	       );
# Day 8 is the same as day 1, etc.  So num. days should be < 8.
my $NUMDAYS = 7;

# A list of channels available for me on Sky Digital - all the free
# ones, plus Sky One.  FIXME: make up DNS-style names for all of
# these. 
# 
#                 bbc1 bbc2 ch4 ch5 radio1 radio2 radio3 radio4
#		  radio5mw worldsvc atlantic252 classicfm talkradiouk
#                 virgin bbcchoice bbcknowledge bbcnews24
#		  bbcparliament bloomberg cnn musicchoiceblues
#		  musicchoiceclassical musicchoicecountry
#		  musicchoicedance musicchoiceeasy musicchoicegold
#		  musicchoicehits musicchoicejazz musicchoicelove
#		  musicchoicerock qvc sky_news sky_channel tcm
#		  tvasia

# What language the pages are in.  This has no real effect :-)
my $LANG = 'en';

# Regular expression to match a name
my $NAME_RE;
{
    my $name_comp_re = '[A-Z](?:[\'A-Za-z-]*|[A-Z]\.?)'; # One word of a name
    my $name_end_re  = '[A-Z][\'A-Za-z-]+'; # Surname
    
    $NAME_RE = "(?:(?:$name_comp_re)(?:\\s+$name_comp_re)*\\s+)?$name_end_re";
}



########
# End of configuration

# Special-case mungers for various programme types.  Each of these
# should take a single programme and return: a reference to a list of
# programmes, if successful; undef, if the programme is to be left
# alone.  Most special-case handlers will not break up a programme
# into several others, so the returned list will have only one
# element.
# 
# A handler may modify the programme passed in iff it returns a list
# of munged programmes.
# 
my @special_handlers = (\&special_4learning,
			\&special_presenter,
			\&special_actor,
			\&special_radio4,
			\&special_film,
		       );

my $writer = new XML::Writer(DATA_MODE   => 1,
			     DATA_INDENT => 2 );
$writer->xmlDecl();
{ local $^W = 0; $writer->doctype('tv', undef, 'xmltv.dtd') }
$writer->startTag('tv');

# Get a big list of programmes for all channels
my @thelot;
foreach my $channel (sort keys %CHANNELS) {
    my $internal_name = $CHANNELS{$channel};

    foreach (@{pages_for_channel($channel)}) {
	foreach (@{programmes_from_html($_)}) {
	    $_->{channel} = $internal_name;

	    # Apply all special-case handlers.  We just haphazardly
	    # run one after the other; when a programme has been run
	    # through all of them in sequence without any changes, we
	    # move it to @progs_done.
	    # 
	    # The reason for using _lists_ is that some handlers turn
	    # a single programme into several.
	    # 
	    my @progs = ($_);
	    my @progs_done = ();
	    PROG: while (@progs) {
		my $prog = shift @progs;
#		t('running handlers for prog: ' . d($prog));
		foreach (@special_handlers) {
#		    t('running handler: ' . d($_));
		    my $out = $_->($prog);
		    if (defined $out) {
#			t('gave new list of progs: ' . d($out));
			push @progs, @$out;
			next PROG;
		    }
#		    t('gave undef');
		}
		push @progs_done, $prog;
	    }

	    write_programme($writer, $_) foreach @progs_done;
	}
    }
}

$writer->endTag('tv');
$writer->end();
exit();


# pages_for_channel()
# 
# Parameters:
#   Name of a channel (bbc1, bbc2, carlton, ch4, ch5)
# 
# Returns: 
#   Ref to list of HTML pages for that channel's listings, from
#   the Ananova site 
# 
sub pages_for_channel($) {
    die 'usage: html_for_channel(channel name)' if @_ != 1;
    my $ch = shift;
    my @r;

    my $BASE = 'http://www.ananova.com/tv/listings/carlton';
    foreach my $day (1 .. $NUMDAYS) {
	print STDERR "channel $ch, day $day\n";
	my $url = "$BASE/day$day/$ch.html";
	my $page = get($url);
	die "cannot get $url" if not defined $page;
	push @r, $page;
    }

    return \@r;
}


# programmes_from_html()
# 
# Top level function.  Turn HTML into a list of programmes with date,
# title, and description. 
# 
# Parameters:
#   HTML string
# 
# Returns:
#   Ref to list of programmes
# 
sub programmes_from_html($) {
    die 'usage: programmes_from_html(html string)' if @_ != 1;
    my $html = shift;

    # Turn the HTML into a list of bold/italic/plain bits of text
    my $bits = boldit($html);

    # Split this into programmes - each programme starts with a time.
    # Also split at 'Ananova' to separate out the trailing cruft.
    # 
    my $progs = splitlist(sub { istime($_[0]->{TEXT})
				  or $_[0]->{TEXT} =~ /Ananova/ },
			  $bits );
    
    # Remove the cruft, leaving just the programmes.
    my @progs = grep { @$_ and $_->[0]->{TEXT} !~ /Ananova/ } @$progs;
    
    # Turn each list of bits of text into a proper set of programme
    # details.
    # 
    my @r;
    foreach (@progs) {
	my $e = extract_progs($_);
	push @r, @$e if $e;
    }
    
    if (not @r) {
	warn "no programmes found in page";
	return \@r;
    }

    # Convert the 12 hour times into proper date-times.
    my $day = get_date_from_page($html);
    if (not defined $day) {
	# Ananova sometimes does this - listings for a particular day
	# and channel are not given.  (Well, carlton/day1/ch5,
	# anyway.)  Are they just trying to annoy me?
	# 
	warn "cannot find date in page, skipping whole page";
	return [];
    }

    date_programmes(\@r, $day);
    return \@r;
}


# date_programmes()
# 
# Given a list of programme details (from extract_progs()) and the date
# of this listing, remove the silly 12 hour times and add proper time
# and date for each programme.  In UT.
# 
# Parameters:
#   reference to list of programme details
#   date in format YYYYMMDD
# 
# Modifies the list passed in, so that each programme no longer has
# {'time'} but has {'start'} instead.
# 
sub date_programmes($$) {
    die 'usage: date_programmes(ref to list of programmes, date)'
      if @_ != 2;
    my ($progs, $base_day) = @_;
    die 'bad base day, format should be YYYYMMDD'
      if $base_day !~ /^\d{8}$/;
    
    my $prev_date;
    my $day_later = ParseDateDelta('+1 day') or die;
  
    foreach (@$progs) {
#	t('adding date to programme ' . d($_));
	my $t = time12to24($_->{'time'});
	
	# $t should be hours and minutes, add seconds
	$t =~ s/\b(\d\d):(\d\d)\b/$1:$2:00/ or die "bad hh:mm $t";

	my $prog_date = parse_uk_date("$base_day $t");
	die "bad base day + time '$t'"
	  if not defined $prog_date or $prog_date eq '';

	if (defined $prev_date
	    and (Date_Cmp($prev_date, $prog_date) > 0))
        {
	    # Seem to have jumped backwards in time.  Must be the next
	    # day.
	    # 
	    my $err;
	    $base_day = UnixDate DateCalc($base_day, $day_later, \$err), '%Q';
	    die "error from DateCalc(): $err" if defined $err;
	    $prog_date = parse_uk_date("$base_day $t");
	    die "bad base day + time '$t'"
	      if not defined $prog_date or $prog_date eq '';
	}
    
	delete $_->{'time'};
	$_->{'start'} = $prog_date;
	$prev_date = $prog_date;
    }
}

    
# extract_progs()
# 
# Given a programme or clump of programmes as a ref to a list of bits
# of text, each with 'bold' and 'italic' flags, return a ref to a list
# where each element is a hashref of time, title, sub_title,
# and desc for one programme.
# 
# Normally the bits passed in will be one programme with its own start
# time.  However it often happens that two programmes share a
# timeslot, for example 'News' and 'Weather'.  In this case the
# listref returned will have two elements, with the same start time.
# But there will be an extra key 'clumpidx' which distinguishes the
# two; the first programme has clumpidx 0/N, the second 1/N and so on,
# where there are N programmes in the clump.
# 
sub extract_progs($) {
    die 'usage: extract_progs(list of bits of text)' if @_ != 1;
    my $bits = shift;
    my @r;

    my $p = {}; # hashref of current programme being built up

    # Subroutine to sanity-check a programme before we add it to @r
    # Probably not scoped properly, but who cares
    # 
    sub check_p($) {
	my $p = shift;
#	t('check_p() checking programme ' . d($p));
	my ($tm, $tl) = (defined $p->{time}, defined $p->{title});
	if (not $tm and not $tl) {
	    warn "found strange junk";
	    return 0;
	}
	elsif (not $tm and $tl) {
	    warn "no time found for programme $p->{title}";
	    return 0;
	}
	elsif ($tm and not $tl) {
	    $p->{title} = '(unknown title)';
	    return 1;
	}
	elsif ($tm and $tl) {
	    return 1;
	}
	else { die }
    }

    foreach (@$bits) {
	my ($b, $i, $t) = @$_{'bold', 'italic', 'TEXT'};

	# Clean up some of the mess from the HTML
	$t =~ s/\xa3((?:\d|,)*)/($1 ne '') ? "$1 pounds" : ''/ge;
	$t =~ s/\Q&nbsp;\E/ /g;

	# Skip empty bits of text
	$t =~ s/^\s+//; $t =~ s/\s+$//; next if $t eq '';

	# XML::Simple turns '&' into '&amp;', but nsgmls -wxml doesn't
	# like this.  Kludge round the problem by getting rid of '&'
	# altogether.
	# 
	$t =~ s/\s*\Q\&amp\;\s*\E/ and /g;
	$t =~ s/\s*\Q&\E\s*/ and /g;

	if ($b and not $i and istime($t)) {
	    die "time already set to $p->{time} but $t found"
	      if defined $p->{time};
	    $p->{time} = $t;
	}
	elsif ($b and not $i and $t =~ /^\(.+\)$/) {
	    # (888) or similar, ignore
	    # But (Film) ends up as sub-title, fixed by specials
	}
	elsif ($b and not $i) {
	    $t =~ s!/! / !g;
	    if (not defined $p->{title}) {
		$p->{title} = $t;
	    }
	    else {
		# A small programme tacked onto the end of another.
		# Finish the current %p and start a new one.
		# 
		if (check_p($p)) {
		    push @r, $p;
#		    t('\@r now ' . d(\@r));
		}
		else {
		    # check_p() gives its own error
		    warn "ignoring programme"; 
#		    t('\@r remains ' . d(\@r));
		}

		# Start a new programme from now on - same time though
		$p = { title => $t, time => $p->{time} };
	    }
	}
	elsif ($i and not $b) {
	    warn "italic text $t found, but no title yet - ignoring", next
	      if not defined $p->{title};
	    
	    $t =~ s!/! / !g;
	    if ($t =~ /^Generic[\s.]/) {
		# Ignore.
	    }
	    elsif ($t =~ /^Director: (.+)\.$/) {
		warn "italic text $t found, but director already defined - ignoring", next
		  if defined $p->{credits}->{director};
		$p->{credits}->{director} = [ $1 ];
	    }
	    else {
		# Must be sub-title.
		warn "italic text $t found, but sub-title already defined - ignoring", next
		  if defined $p->{sub_title};
		$p->{sub_title} = $t;
	    }
	}
	elsif (not $b and not $i) {
	    next if $t eq 'VIDEO REPORTS'; # ugh
	    if (not defined $p->{desc}) { $p->{desc} = $t }
	    else                        { $p->{desc} .= "; $t" }
	}
	else { die }
    }

    if (check_p($p)) {
	push @r, $p;
#	t('\@r now ' . d(\@r));
    }
    else {
	# check_p() gives its own error
	warn "ignoring programme"; 
#	t('\@r remains ' . d(\@r));
    }

    my $num_in_clump = @r;
    if ($num_in_clump > 1) {
	foreach (0 .. $#r) {
	    $r[$_]->{clumpidx} = "$_/$num_in_clump";
	}
    }

    return \@r;
}


# boldit()
# 
# Convert HTML to a list of bits of text.  Each bit has 'bold' and
# 'italic' flags.  Bits which are inside <a> tags are ignored.
# 
# Parameters: string of HTML
# 
# Returns: ref to list of chunks, where each chunk looks like:
#   { 'bold' => x, 'italic' => x, 'TEXT' => text }
# 
sub boldit($) {
    die 'usage: boldit(html string)' if @_ != 1;
    my $html = shift;
    
    use HTML::TokeParser;
    my $p = new HTML::TokeParser(\$html) or die;

    # HTML::TokeParser is based on HTML::Parser, and has the same
    # tendency to break chunks of text into multiple tokens.  Turn
    # that off. 
    # 
    $p->unbroken_text(1);

    my @r = ();
    my ($bold, $it) = (0, 0);
    while (my $t = $p->get_token()) {
	if    ($t->[0] eq 'S' and $t->[1] eq 'b') { $bold = 1 }
	elsif ($t->[0] eq 'S' and $t->[1] eq 'i') { $it   = 1 }
	elsif ($t->[0] eq 'S' and $t->[1] eq 'a') { $a    = 1 }
	elsif ($t->[0] eq 'E' and $t->[1] eq 'b') { $bold = 0 }
	elsif ($t->[0] eq 'E' and $t->[1] eq 'i') { $it   = 0 }
	elsif ($t->[0] eq 'E' and $t->[1] eq 'a') { $a    = 0 }
	elsif ($t->[0] eq 'T' and not $a) {
	    $t->[1] =~ s/^\s+//; $t->[1] =~ s/\s+$//;
	    next if $t->[1] eq '';
	    push @r, { bold => $bold, italic => $it,
		       TEXT => $t->[1] };
	}
    }

    return \@r;
}


# splitlist()
# 
# Split a list at particular elements.
# 
# Parameters:
#   subroutine that given an element, returns true or false
#   ref to list
# 
# Returns:
#   ref to list of refs to sublists
# 
# The first sublist starts at the first element of the input list, and
# continues up to but not including the first element that gave true;
# the second sublist starts at this point, and so on.
# 
sub splitlist($$) {
    die 'usage: splitlist(sub, ref to list)' if @_ != 2;
    my ($p, $l) = @_;
    my @r = ();

    my @firstlist = ();
    while (@$l and not $p->($l->[0])) {
	push @firstlist, (shift @$l);
    }
    push @r, \@firstlist;
    
    while (@$l) {
	my @sublist;
	@sublist = ();
	push @sublist, (shift @$l);
	while (@$l and not $p->($l->[0])) {
	    push @sublist, (shift @$l);
	}
	push @r, \@sublist;
    }
    
    return \@r;
}


# istime()
# 
sub istime($) {
    die 'usage: istime(possible time string)' if @_ != 1;
    local $_ = shift;
    die if not defined;

    my $tz = gettz($_);
    s/\Q$tz\E// if defined $tz;

    s/\s+//g;
    return /^(\d\d?)[.:]?(\d\d)(am|pm)?$/;
}


# time12to24()
# 
# Convert a 12 hour time to 24 hour.
# 
sub time12to24($) {
    die 'usage: time12to24(12 hour time string)' if @_ != 1;
    local $_ = shift;
    die if not defined;
    
    # Remove the timezone and stick it back on afterwards.
    my $tz = gettz($_);
    s/\Q$tz\E// if defined $tz;

    s/\s+//;
    my ($hours, $mins, $ampm) = /^(\d\d?)[.:]?(\d\d)(am|pm)$/
      or die "bad time $_";
    if ($ampm eq 'am') {
	if (1 <= $hours and $hours < 12) {
	    $hours = $hours;      # 5am = 05:00
	}
	elsif ($hours == 12) {
	    $hours = 0;           # 12am = 00:00
	}
	else { die "bad number of hours $hours" }
    }
    elsif ($ampm eq 'pm') {
	if ($hours == 12) {
	    $hours = 12;          # 12pm = 12:00
	}
	elsif (1 <= $hours and $hours < 12) {
	    $hours = 12 + $hours; # 5pm = 17:00
	}
	else { die "bad number of hours $hours" }
    }
    else { die }

    my $r = sprintf('%02d:%02d', $hours, $mins);
    $r .= " $tz" if defined $tz;
    return $r;
}


# get_date_from_page()
# 
# Returns date in 'YYYYMMDD' format from Ananova page, or undef if
# none found.
# 
sub get_date_from_page($) {
    die 'usage: get_date_from_page(html string)' if @_ != 1;
    my $html = shift;

    my $date;
    my $p = HTML::TokeParser->new(\$html) or die;
    while (my $token = $p->get_tag('span')) {
	if ($token->[1]->{class} eq 'story-headline') {
	    my $text = $p->get_trimmed_text("/span");
	    next if $text =~ /^\s*$/;
	    die "date already set to $date, but headline $text found"
	      if defined $date;
	    my $pd = ParseDate($text)
	      or die "bad date string '$text'\n";
	    $date = UnixDate($pd, '%Q');
	}
    }
    return $date;
}


# write_programme()
# 
# Write details for a single programme as XML.
# 
# Parameters:
#   XML::Writer object
#   reference to hash of programme details (a 'programme')
# 
sub write_programme($$) {
    die 'usage: write_programme(XML::Writer, programme)' if @_ != 2;
    my ($w, $p) = @_;
    
    my ($channel, $start, $title, $sub_title, $desc, $credits, $category)
      = @$p{qw(channel start title sub_title desc credits category)};
    die if not defined $start or not defined $channel;
    
    # The dates are converted to the appropriate timezone for output.
    die if defined $p->{end}; # end times are added by sort_listings now
    if (defined $p->{clumpidx}) {
	$w->startTag('programme', start    => join(' ', @{date_to_uk($start)}),
		                  clumpidx => $p->{clumpidx},
		                  channel  => $channel );
    }
    else {
	$w->startTag('programme', start   => join(' ', @{date_to_uk($start)}),
			          channel => $channel );
    }

    $w->dataElement('title', $title, lang => $LANG);
    $w->dataElement('sub-title', $sub_title, lang => $LANG)
      if defined $sub_title;

    if (defined $desc) {
	$desc =~ s/^\s+//; $desc =~ s/\s+$//;
	$w->dataElement('desc', $desc, lang => $LANG);

	# I'd like to line-wrap this so that the generated XML is
	# pleasant to read.  I have a private version of XML::Writer
	# which supports a dataElement_block() method for nicely
	# formatted output, but for the time being we'll just use the
	# standard version.  One day I will tidy up what I wrote and
	# submit it to the XML::Writer maintainer.
	# 
#	$w->dataElement_block('desc', $desc, lang => $LANG)
    }

    if (defined $credits) {
	$w->startTag('credits');
	foreach (qw[director actor writer adapter producer presenter
		    commentator] )
	{
	    next unless defined $credits->{$_};
	    my @people = @{$credits->{$_}};
	    if ($_ eq 'director' and @people > 1) {
		die "more than one director"; # not allowed by DTD
	    }

	    foreach my $person (@people) {
		$w->dataElement($_, $person);
	    }
	}
	$w->endTag('credits');
    }

    $w->dataElement('date', $p->{date})
      if defined $p->{date};
    $w->dataElement('category', $category, lang => $LANG)
      if defined $category;
    $w->dataElement('language', $LANG);
    $w->endTag('programme');
}


# special_4learning()
# 
# Channel Four's '4Learning' is a collection of several programmes
# stuffed into one entry.  Times and titles are given as part of the
# description.  This attempts to decode the description and make
# individual programmes.
# 
# Parameters: a 'programme' hash reference
# Returns: reference to list of sub-programmes, or undef if programme 
#          was not '4learning'
# 
sub special_4learning($) {
    die "usage: special_4learning(hashref of programme details)"
      if @_ != 1;
    my $p = shift;
    return undef if $p->{title} ne '4Learning';

    local $_ = $p->{desc};
    my @words = split;
    my @r;

    my $day = ParseDate(UnixDate($p->{start}, '%Q'));
    die if not defined $day;
#    t("day is $day");

    while (@words) {
	my $time = shift @words;
	if (istime($time)) {
	    if ($time =~ /^\d\.\d\d$/) {
		$time = "0$time"; # 4-digit, 24-hour
	    }
	    $time =~ tr/./:/;
#	    t("time of bit is $time");
	    my $start = Date_SetTime($day, $time);
	    die if not defined $start;
#	    t("complete time and date is $start");
	    
	    my $curr_prog;
	    $curr_prog->{start} = $start;
	    $curr_prog->{channel} = $p->{channel};
	    my (@title_words, @desc_words);
	    my $done_title = 0;
	    while (@words) {
		my $word = shift @words;

		if (istime($word)) {
		    # Finished this bit of 4learning.
		    unshift @words, $word;
		    last;
		}
		elsif (not $done_title) {
		    if ($word =~ s/[.?]$//) {
			# Finished the title, move on to description.
			$done_title = 1;
		    }
		    push @title_words, $word;
		}
		else {
		    push @desc_words, $word;
		}
	    }

	    # The title sometimes looks like 'History in Action: Women
	    # in the 20th Century'; this should be broken into main
	    # title and secondary title.  But not 'GNVQ: Is It For You
	    # 2'.  So arbitrarily we check that the main title has at
	    # least two words.
	    # 
	    if (@title_words) {
		my (@main_title_words, @sub_title_words);
		while (@title_words) {
		    my $word = shift @title_words;
		    my $main_title_length = @main_title_words + 1;
		    if ($main_title_length >= 2 and $word =~ s/:$//) {
			push @main_title_words, $word;
			@sub_title_words = @title_words;
			last;
		    }
		    else {
			push @main_title_words, $word;
		    }
		}

		$curr_prog->{title} = join(' ', @main_title_words);
		$curr_prog->{sub_title} = join(' ', @sub_title_words)
		  if @sub_title_words;
	    }

	    $curr_prog->{desc} = join(' ', @desc_words)
	      if @desc_words;
	    push @r, $curr_prog;
	}
	else {
	    warn "expected time in 4learning description, got $time";
	}
    }

    return \@r;
}


# special_presenter()
# 
# Try to sniff out presenter info from the start of the description
# and put it into the credits section instead.
# 
# Parameters: one programme (hashref)
# Returns: [ modified programme ], or undef
# 
# May modify the programme passed in, if return value is not undef.
# But that's okay for a special-case handler.
# 
sub special_presenter($) {
    die 'usage: special_presenter(programme hashref)' if @_ != 1;
    my $p = shift;
#    local $Dbg::On = 1 if $p->{title} =~ /Network East/;
    
    # Regexp to match a list of names: 'Tom, Dick, and Harry'
    my $names_re = "$NAME_RE(?:\\s*,?\\s*(?:and)?\\s+$NAME_RE)*";
    
    # Subroutine to extract the names from this list
    sub list_names($) {
	die 'usage: list_names(English string listing names)'
	  if @_ != 1;
	local $_ = shift;
	my @r;
	
	s/^($NAME_RE)\s*// or die "bad 'presenters' '$_'";
	unshift @r, $1;
	
	while (s/^,?\s*(?:and)?\s+($NAME_RE)\s*//) {
	    unshift @r, $1;
	}
	die "unmatched bit of presenters $_" unless $_ eq '';
	
	return @r;
    }

    for ($p->{desc}) {
	return undef if not defined;
#	t("testing desc: $_");

	if (s/\b([pP])resenteed\b/$1resented/g) {
	    # First of all, fix spelling mistakes!
	    return [ $p ];
	}

	if (s/^With ($NAME_RE)\.\s+// or
	    s/^($NAME_RE) introduces (\w)/uc $2/e )
	{
	    # Why unshift instead of push?  Because the presenter
	    # mentioned first is probably the most important, and
	    # we give credits in decreasing order of importance.
	    # 
	    unshift @{$p->{credits}->{presenter}}, $1;
	    return [ $p ];
	}

	if (s<\b[pP]resented by\s+()($names_re)\b\s*(.|,?\s+\w|\Z)>
	    <$1.uc $3>e
	    or
	    s<(\.\s+|^\s*)($names_re)\s+presents?\b\s*(.|,?\s+\w|\Z)>
	    <$1.uc $3>e )
	{
#	    t("presenter0: '$2'");
	    unshift @{$p->{credits}->{presenter}}, list_names($2);
	    s/,\s*$//;
	    s/,\s*,/,/;
	    s/\s+\./\./;
	    return [ $p ];
	}

	if (s/(^|\.\s+)[pP]resenters?\s+($names_re)/$1 $2/) {
	    unshift @{$p->{credits}->{presenter}}, list_names($2);
	    return [ $p ];
	}

	if (s/\b[cC]o-?presenters?\s+($names_re)/$1/) {
#	    t("found co-presenters '$1'");
	    unshift @{$p->{credits}->{presenter}}, list_names($1);
	    return [ $p ];
	}

	# Leave 'virtual presenter', 'aquatic presenter',
	# 'new presenter', 'guest presenter', etc. alone for now
	# 
    }
    return undef;
}


# special_actor(): like special_presenter().
sub special_actor($) {
    die 'usage: special_presenter(programme hashref)' if @_ != 1;
    my $p = shift;

    for ($p->{desc}) {
	return undef if not defined;
#	t("testing desc: $_");
	if (s/^($NAME_RE) stars in\s+(?:this\s+)(\w)?/uc $2/e or
	    s/($NAME_RE) (?:co-)?stars\.?\s*$// )
	{
	    unshift @{$p->{credits}->{actor}}, $1;
	    return [ $p ];
	}
    }
    return undef;
}
    

# special_radio4()
# 
# Split Radio 4 into FM and LW.
# 
sub special_radio4($) {
    die 'usage: special_radio4(programme)' if @_ != 1;
    my $p = shift;
    return undef if $p->{channel} ne 'radio4';

    for ($p->{title}) {
	if (s/^\(FM\)\s+//) {
	    $p->{channel} = 'radio4-fm';
	    return [ $p ];
	}
	if (s/^\(LW\)\s+//) {
	    $p->{channel} = 'radio4-lw';
	    return [ $p ];
	}
	
	my %fm = ( %$p, channel => 'radio4-fm' );
	my %lw = ( %$p, channel => 'radio4-lw' );
	return [ \%fm, \%lw ];
    }
}


# special_film()
# 
sub special_film($) {
    die 'usage: special_film(programme)' if @_ != 1;
    my $p = shift;
    if (not defined $p->{sub_title} or $p->{sub_title} ne '(Film)') {
	return undef;
    }
    
    warn "replacing category $p->{category} with 'film'"
      if defined $p->{category};
    $p->{category} = 'film';
    undef $p->{sub_title};

    if ($p->{desc} =~ s/^(\d{4})\s+//) {
	warn "found year $1 in description, replacing date $p->{date}"
	  if defined $p->{date};
	$p->{date} = $1;
    }

    return [ $p ];
}
