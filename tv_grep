#!/usr/bin/perl -w
#
# tv_grep: filter out all programmes matching a regexp.  The channels
# are left unchanged.
#
# This is the first version, many features yet to implement!
#
use strict;
use XMLTV;
use Data::Dumper;
use Date::Manip;
use Log::TraceMessages qw(t d); Log::TraceMessages::check_argv();

sub usage( ;$ );
sub all_text( $$ );
sub abbrev( $$ );
sub on_after( $ );
sub whole_programme_regexp( $ );

#my $now = ParseDate('now'); die if not defined $now;

# Tests to apply.  We store them as a disjunction of conjunctions, for
# example (a && b && c) || (d && e) || (f && g).
#
# We keep tests separately for programmes and channels: but really the
# channel tests are just extras and not important.  When we add a
# programme test referring to channels, we add a channel test to go
# with it so that the list of channels in the output is trimmed.  But
# remember that the tests primarily are there to filter programmes.
#
my (@prog_conjs, @curr_prog_conj);
my (@chan_conjs, @curr_chan_conj);

# Hash mapping regexp -> channel id -> true/undef (see later)
my %ch_name;
my @ch_regexps; # regexps to populate %ch_name with

# Prepare an OptionAbbrev object with all the long options we expect
# to find.
#
my $oa = new OptionAbbrev(qw(--ignore-case --help --output
			     --channel-id --channel-name
			     --on-after --eval
			     --and --or));
my %key_type = %{XMLTV::list_programme_keys()};
$oa->add(map { "--$_" } keys %key_type);

my ($ignore_case, $output, $regexp, $ended_options, $filename);
while (@ARGV) {
    my $arg = shift @ARGV;

    unless ($ended_options) {
	if ($arg eq '--') {
	    $ended_options = 1;
	    next;
	}
	my @long_opts = $oa->match($arg);
	my $lo;
	if (@long_opts >= 2) {
	    die "option $arg ambiguous: could be any of @long_opts\n";
	}
	elsif (@long_opts == 1) {
	    $lo = $long_opts[0];
	    die unless $lo =~ /^--/;
	}
	elsif (@long_opts == 0) {
	    die "unknown long option $arg\n" if $arg =~ /^--/;
	    # Otherwise okay.
	}
	else { die }

	if (defined $lo and $lo eq '--help') {
	    usage(1);
	}

	if (defined $lo and $lo eq '--output') {
	    if (defined $output) {
		die "option --output can be given only once\n";
	    }
	    $output = shift @ARGV;
	    if (not defined $output) {
		die "option --output requires an argument, a filename\n";
	    }
	    next;
	}

	if ($arg eq '-i' or (defined $lo and $lo eq '--ignore-case')) {
	    $ignore_case = 1; # no warning if given twice
	    next;
	}

	# Logical operators --and and --or.
	if ($arg eq '-and' or (defined $lo and $lo eq '--and')) {
	    next;
	}
	elsif ($arg eq '-o' or $arg eq '-or'
	       or (defined $lo and $lo eq '--or')) {
	    # Finished with this conjunction, start a new one.  The
	    # final test is a disjunction of all conjunctions.
	    #
	    # Won't be this easy if we ever implement ( and ).
	    #
	    if (not @curr_prog_conj) {
		warn "nothing to the left of $arg, should use as EXPR1 $arg EXPR2\n";
		usage();
	    }
	    push @prog_conjs, [ @curr_prog_conj ]; # make a copy
	    @curr_prog_conj = ();

	    # And the same for the channel predicates (if any).
	    push @chan_conjs, [ @curr_chan_conj ];
	    @curr_chan_conj = ();

	    next;
	}

	# See if it's a predicate.
	if ($arg eq '-e' or (defined $lo and $lo eq '--eval')) {
	    my $code = shift @ARGV;
	    die "-e requires an argument, a snippet of Perl code"
	      if not defined $code;
	    my $pred = eval "sub { $code }";
	    if ($@) {
		die "-e $code: $@\n";
	    }
	    if (not defined $pred) {
		# Shouldn't happen, I think.
		die "-e $code failed for some reason";
	    }
	    push @curr_prog_conj, $pred;
	    next;
	}

	if (defined $lo and $lo eq '--on-after') {
	    my $date = shift @ARGV;
	    die "--on-after requires an argument, a date and time"
	      if not defined $date;
	    my $pd = ParseDate($date);
	    die "--on-after $date: invalid date\n"
	      if not defined $pd;
	    push @curr_prog_conj, sub { on_after($pd) };
	    next;
	}

	if (defined $lo and $lo eq '--channel-id') {
	    my $id = shift @ARGV;
	    die "--channel-id requires an argument, an XMLTV internal channel id\n"
	      if not defined $id;
	    push @curr_prog_conj, sub { $_->{channel} eq $id };
	    push @curr_chan_conj, sub { $_->{id} eq $id };
	    next;
	}

	if (defined $lo and $lo eq '--channel-name') {
	    my $regexp = shift @ARGV;
	    die "--channel name requires an argument, a Perl regular expression\n"
	      if not defined $regexp;

	    # The matchers check against a global hash mapping
	    # channel-name regexps to channel ids to true/undef.  We
	    # must remember to create this hash later when we've read
	    # in the channels.
	    #
	    push @curr_prog_conj, sub { $ch_name{$regexp}->{$_->{channel}} };
	    push @curr_chan_conj, sub { $ch_name{$regexp}->{$_->{id}} };
	    push @ch_regexps, $regexp;
	    next;
	}

	if (defined $lo) {
	    # Must be one of the autogenerated ones like --title.
	    $lo =~ /^--(.+)/ or die "matched long option $lo, no --";
	    my $key = $1;
	    my $kt = $key_type{$key};
	    die if not defined $kt;
	    if ($kt eq 'other') {
		die "cannot regexp match against $key, too complex\n";
	    }
	    elsif ($kt eq 'boolean') {
		push @curr_prog_conj, sub { defined $_->{$key} };
		next;
	    }

	    # Otherwise a regexp is required.
	    my $regexp = shift @ARGV;
	    die "$lo requires an argument, a Perl regular expression\n"
	      if not defined $regexp;

	    if ($kt eq 'scalar') {
		push @curr_prog_conj, sub {
		    for ($_->{$key}) {
			return 0 if not defined;
			return $ignore_case ? /$regexp/oi : /$regexp/o;
		    }
		};
		next;
	    }
	    elsif ($kt eq 'with_lang') {
		push @curr_prog_conj, sub {
		    for ($_->{$key}) {
			return 0 if not defined;
			for ($_->[0]) {
			    return $ignore_case ? /$regexp/oi : /$regexp/o;
			}
		    }
		};
		next;
	    }
	    elsif ($kt eq 'many') {
		push @curr_prog_conj, sub {
		    for ($_->{$key}) {
			return 0 if not defined;
			foreach (@$_) {
			    return 1 if ($ignore_case ? /$regexp/oi : /$regexp/o);
			}
			return 0;
		    }
		};
		next;
	    }
	    elsif ($kt eq 'many_with_lang') {
		push @curr_prog_conj, sub {
		    for ($_->{$key}) {
			return 0 if not defined;
			foreach (map { $_->[0] } @$_) {
			    return 1 if ($ignore_case ? /$regexp/oi : /$regexp/o);
			}
			return 0;
		    }
		};
		next;
	    }
	    else { die "bad key type $kt" }
	}
    }

    # It wasn't an option, see if it's a regexp or filename.
    if (not $ended_options and $arg =~ /^-/) {
	die "bad option $arg\n";
    }

    # A regular expression is allowed only in the simple case where we
    # haven't got any of the fancy boolean tests.
    #
    if (not defined $regexp
	and not @prog_conjs and not @curr_prog_conj) {
	$regexp = $arg;
	next;
    }
    elsif (not defined $filename) {
	$filename = $arg;
	next;
    }
    else {
	warn "bad argument $arg (cannot grep multiple files)\n";
	usage();
    }
}
push @prog_conjs, \@curr_prog_conj if @curr_prog_conj;
push @chan_conjs, \@curr_chan_conj if @curr_chan_conj;
if (not @prog_conjs and not defined $regexp) {
    warn "neither boolean tests nor regexp given\n";
    usage();
}
elsif (not @prog_conjs and defined $regexp) {
    t "no predicates, but regexp $regexp";
    @prog_conjs = ([ sub { whole_programme_regexp($regexp) } ]);
}
elsif (@prog_conjs and not defined $regexp) {
    t 'predicates given, not simple regexp';
}
elsif (@prog_conjs and defined $regexp) {
    warn "bad argument $regexp\n";
    usage();
}
# No test for @chan_conjs since there is no test which weeds out
# channels but does not weed out programmes.  (How could there be?)
#

$filename = '-' if not defined $filename;
my ($encoding, $credits, $ch, $progs) = @{XMLTV::read_data($filename)};

# Prepare the channel name lookup.
my %seen_ch_id;
foreach my $ch_id (keys %$ch) {
    $seen_ch_id{$ch_id}++ && die "duplicate channel id $ch_id\n";
    my $ch = $ch->{$ch_id}; die if not defined $ch;
    my %seen_re;
    foreach my $re (@ch_regexps) {
	next if $seen_re{$re}++;
	my $matched = 0;
	foreach (map { $_->[0] } @{$ch->{'display-name'}}) {
	    if ($ignore_case ? /$re/i : /$re/) {
		$matched = 1;
		last;
	    }
	}
	if ($matched) {
	    $ch_name{$re}->{$ch_id}++ && die;
	}
    }
}

# Filter channels.  This has an effect only for the --channel-id and
# --channel-name predicates; we do not drop channels simply because no
# programmes remained on them after filtering.
#
my %new_ch;
if (@chan_conjs) {
  CH: foreach my $ch_id (keys %$ch) {
	local $_ = $ch->{$ch_id};
      CONJ: foreach my $conj (@chan_conjs) {
	    foreach my $test (@$conj) {
		# Every test in the conjunction must succeed.
		next CONJ if not $test->();
	    }
	    # They all succeeded, the channel should be kept.
	    $new_ch{$ch_id} = $_;
	    next CH;
	}
	# All the conjunctions failed, won't write.
    }
}
else {
    # No tests specifically affecting channels, keep the full listing.
    %new_ch = %$ch;
}

# Filter programmes.
my @new_progs;
PROG: foreach (@$progs) {
    t 'filtering prog: ' . d $_;
    CONJ: foreach my $conj (@prog_conjs) {
	  t 'testing against all of conjunction: ' . d $conj;
	  foreach my $test (@$conj) {
	      t 'testing condition: ' . d $test;
	      if ($test->()) {
		  t 'passed, onto next condition in conj (if any)';
	      }
	      else {
		  t 'failed, so failed this conj';
		  next CONJ;
	      }
	  }
	  t 'passed all tests in conj, finished with prog';
	  push @new_progs, $_;
	  next PROG;
      }
    t 'failed at least one test in all conjs, not keeping';
}

# All done, write the new programmes and channels.
t 'finished grepping, writing';
my %w_args = ();
if (defined $output) {
    my $fh = new IO::File ">$output";
    die "cannot write to $output\n" if not $fh;
    %w_args = (OUTPUT => $fh);
}
XMLTV::write_data([$encoding, $credits, \%new_ch, \@new_progs], %w_args);
exit();


# Parameter: if true, write 'help message' rather than 'usage
# message', ie write to stdout and exit successfully.
#
sub usage( ;$ ) {
    my $is_help = shift; $is_help = 0 if not defined $is_help;
    my $msg = <<END
usage: $0 [--help] [--output FILE] [--ignore-case|-i] [EXPR | REGEXP] [file]
where EXPR may consist of
(programme content matches)
END
  ;

    foreach (sort keys %key_type) {
	my $kt = $key_type{$_};
	if ($kt eq 'boolean') {
	    $msg .= "    --$_\n";
	}
	elsif ($kt eq 'scalar' or $kt eq 'with_lang'
	       or $kt eq 'many' or $kt eq 'many_with_lang') {
	    $msg .= "    --$_ REGEXP\n";
	}
	elsif ($kt eq 'other') {
	    # Cannot query on this (though maybe could be added with
	    # Data::Dumper).
	    #
	}
	else { die }
    }

    $msg .= <<END
(channel matches)
    --channel-name REGEXP
    --channel-id CHANNEL_ID
(special tests)
    --on-after DATE
    --eval PERL_CODE
(logical operators)
    EXPR1 [--and|-and] EXPR2
    EXPR1 [--or|-or|-o] EXPR2
--and is implicit and may be omitted.
END
  ;

    if ($is_help) {
	print $msg;
	exit(0);
    }
    else {
	print STDERR $msg;
	exit(1);
    }
}

# all_text()
#
# Get all pieces of text for a particular programme attribute.
#
# Parameters:
#   programme hashref
#   attribute name, eg 'title', 'desc'
#
# Returns: list of text strings for that attribute
#
# I wrote Lingua::Preferred::acceptable_lang() especially for this
# routine but then realized that when grepping you probably don't care
# about viewing only those strings applicable to the current language.
#
sub all_text( $$ ) {
    my ($p, $key) = @_;
    return () if not $p->{$key};
    return map { $_->[0] } @{$p->{$key}};
}

####
# Boolean tests.  These work on the programme $_ and return true or
# false.  Their behaviour should be affected, if appropriate, by the
# global $ignore_case.
#
my %warned_no_stop;
sub on_after( $ ) {
    my $cutoff = shift;
    my $stop = $_->{stop};

    if (not defined $stop) {
	# We use the start time instead, that will lose some shows
	# crossing the boundary but is mostly accurate.
	#
	my $start = $_->{start};
	my $pd = ParseDate($start);
	if (not defined $pd) {
	    warn "bad start time $start\n";
	    return 1;
	}

	my $result = (Date_Cmp($cutoff, $pd) < 0);
	if (not $result) {
	    # This programme was dropped, but maybe it wouldn't have
	    # been if it had a stop time.
	    #
	    # We should warn about this: but have an allowance of one
	    # programme per channel without stop time, because you
	    # can reasonably expect that from sorted listings.
	    #
	    unless ($warned_no_stop{$_->{channel}}++) {
		warn "not all programmes have stop times, "
		  . "cannot accurately filter those on after a certain time\n"
		    . "(maybe filter through tv_sort to add stop times)\n";
	    }
	}
	return $result;
    }
    else {
	my $pd = ParseDate($stop);
	if (not defined $pd) {
	    warn "bad stop time $stop\n";
	    return 1;
	}
	return (Date_Cmp($cutoff, $pd) < 0);
    }
}


sub whole_programme_regexp( $ ) {
    my $re = shift;
    # Stringify the whole darn thing and match against that.
    local $_ = Dumper($_);
#    t 'testing stringified whole programme: ' . d $_;
    return $ignore_case ? /$re/i : /$re/;
}


# Class for long option abbreviation.  You tell it all the options
# you're going to use, and then it will tell you whether a (possibly
# abbreviated) argument matches an option unambiguously, ambiguously
# could match several options, or matches none.
#
# Having to roll my own Getopt::Long is getting annoying.  I wonder
# how much of this code could be shared?
#
package OptionAbbrev;
use Log::TraceMessages qw(t d);

# Constructor.  Give a list of long options and/or add() them later.
sub new {
    my $proto = shift;
    my $class = (ref $proto) || $proto;

    # The representation of an object is a list of long options known
    # about.
    #
    my $self = [];
    bless $self, $class;
    $self->add(@_);
    return $self;
}

sub add {
    my $self = shift;
    foreach (@_) {
	die 'long options start with --' unless /^--/;
	foreach my $already (@$self) {
	    die "option $_ already added" if $_ eq $already;
	}
	push @$self, $_;
    }
    return $self;
}

# match() returns a list of possible long options matched.  So if the
# list has no elements, no match; one element is the unambiguous
# match; two or more elements mean ambiguity.
#
sub match {
    my ($self, $arg) = @_;
    t "matching arg $arg against list: " . d $self;
    return () unless $arg =~ /^--\w/;
    t 'begins with --, continue';
    foreach (@$self) {
	t "testing for exact match: '$arg' against '$_'";
	return ($_) if $arg eq $_;
    }
    t 'no exact match, try initial substring';
    my @r;
    foreach (@$self) {
	t "testing if $arg is initial substring of $_";
	push @r, $_ if index($_, $arg) == 0;
    }
    t 'returning list of matches: ' . d \@r;
    return @r;
}
