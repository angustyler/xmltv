#!/usr/bin/perl -w
#
# tv_grep: filter out all programmes matching a regexp.  The channels
# are left unchanged.
#
# This is the first version, many features yet to implement!
#
use strict;
use XMLTV;
use Data::Dumper;
use Getopt::Long;

sub usage();

# Kludge to allow a mixture of short and long options.  Will break if
# one day things like '-i' are acceptable as arguments to other
# options.
#
my %long =
  (
   '-i' => '--ignore-case',
   '-e' => '--e'
  );
foreach (@ARGV) {
    last if $_ eq '--';
    if (defined $long{$_}) { $_ = $long{$_} }
}
my $ignore_case = 0;
my @code;
GetOptions('ignore-case' => \$ignore_case, 'e=s' => \@code);

# Perl seems to handle multiple -e options by concatenating them into
# a single string, so we'll do the same.
#
my $have_code = 0;
if (@code) {
    $have_code = 1;
    my $code = join(' ', @code);
    eval "sub code { $code }";
    die "error evaluating code $code: $@" if $@;
}

my $pattern;
if (not $have_code) {
    # Pattern required.
    usage() unless 1 <= @ARGV and @ARGV < 3;
    $pattern = shift;
}
else {
    usage() unless 1 <= @ARGV and @ARGV < 2;
}

my $filename = @ARGV ? $ARGV[0] : '-';
my ($encoding, $credits, $ch, $progs) = @{XMLTV::read_data($filename)};

# Todo: lazy writing of programmes
my @out;
foreach (@$progs) {
    if ($have_code) {
	push @out, $_ if code();
    }
    else {
	my $tmp = Dumper($_);
	if ($ignore_case) {
	    push @out, $_ if /$pattern/io;
	}
	else {
	    push @out, $_ if /$pattern/o;
	}
    }
}
XMLTV::write_data([$encoding, $credits, $ch, \@out]);

sub usage() {
    print STDERR "usage: $0 [--ignore-case|-i] [-e perl_code] pattern [filename]\n";
    exit(1);
}
