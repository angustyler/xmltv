#!/usr/bin/perl -w
#
# tv_grep: filter out all programmes matching a regexp.  The channels
# are left unchanged.
#
# This is the first version, many features yet to implement!
#
use strict;
use XMLTV;
use Data::Dumper;
use Date::Manip;
use Log::TraceMessages qw(t d); Log::TraceMessages::check_argv();

sub usage();
sub all_text( $$ );
sub abbrev( $$ );
sub on_after( $ );
sub match_regexp( $ );

#my $now = ParseDate('now'); die if not defined $now;

# Tests to apply.  We store them as a disjunction of conjunctions, for
# example (a && b && c) || (d && e) || (f && g).
#
my @conjunctions;
my @curr_conjunction;

my $oa = new OptionAbbrev(qw(--ignore-case --and --or --eval --on-after));

my ($ignore_case, $regexp, $ended_options, $filename);
while (@ARGV) {
    my $arg = shift @ARGV;

    unless ($ended_options) {
	if ($arg eq '--') {
	    $ended_options = 1;
	    next;
	}
	my @long_opts = $oa->match($arg);
	my $lo;
	if (@long_opts >= 2) {
	    die "option $arg ambiguous: could be any of @long_opts\n";
	}
	elsif (@long_opts == 1) {
	    $lo = $long_opts[0];
	}
	elsif (@long_opts == 0) {
	    die "unknown long option $arg" if $arg =~ /^--/;
	    # Otherwise okay.
	}
	else { die }

	if ($arg eq '-i' or (defined $lo and $lo eq '--ignore-case')) {
	    $ignore_case = 1; # no warning if given twice
	    next;
	}

	# Logical operators --and and --or.
	if ($arg eq '-and' or (defined $lo and $lo eq '--and')) {
	    next;
	}
	elsif ($arg eq '-o' or $arg eq '-or'
	       or (defined $lo and $lo eq '--or')) {
	    # Finished with this conjunction, start a new one.  The
	    # final test is a disjunction of all conjunctions.
	    #
	    # Won't be this easy if we ever implement ( and ).
	    #
	    if (not @curr_conjunction) {
		warn "nothing to the left of $arg, should use as EXPR1 $arg EXPR2\n";
		usage();
	    }
	    push @conjunctions, [ @curr_conjunction ]; # make a copy
	    @curr_conjunction = ();
	    next;
	}

	# See if it's a predicate.
	my $pred; # subroutine to test a programme and return boolean
	if ($arg eq '-e' or (defined $lo and $lo eq '--eval')) {
	    my $code = shift @ARGV;
	    die "-e requires an argument, a snippet of Perl code"
	      if not defined $code;
	    $pred = eval "sub { $code }";
	    if ($@) {
		die "-e $code: $@\n";
	    }
	    if (not defined $pred) {
		# Shouldn't happen, I think.
		die "-e $code failed for some reason";
	    }
	}
	elsif (defined $lo and $lo eq '--on-after') {
	    my $date = shift @ARGV;
	    die "--on-after requires an argument, a date and time"
	      if not defined $date;
	    my $pd = ParseDate($date);
	    die "--on-after $date: invalid date\n"
	      if not defined $pd;
	    $pred = sub { on_after($pd) };
	}
	if (defined $pred) {
	    push @curr_conjunction, $pred;
	    next;
	}
    }

    # It wasn't an option, see if it's a regexp or filename.
    if (not $ended_options and $arg =~ /^-/) {
	die "bad option $arg\n";
    }

    # A regular expression is allowed only in the simple case where we
    # haven't got any of the fancy boolean tests.
    #
    if (not defined $regexp
	and not @conjunctions and not @curr_conjunction) {
	$regexp = $arg;
	next;
    }
    elsif (not defined $filename) {
	$filename = $arg;
	next;
    }
    else {
	warn "bad argument $arg (cannot grep multiple files)\n";
	usage();
    }
}
push @conjunctions, \@curr_conjunction if @curr_conjunction;
if (not @conjunctions and not defined $regexp) {
    warn "neither boolean tests nor regexp given\n";
    usage();
}
elsif (not @conjunctions and defined $regexp) {
    @conjunctions = ([ sub { match_regexp($regexp) } ]);
}
elsif (@conjunctions and not defined $regexp) {
    # Okay.
}
elsif (@conjunctions and defined $regexp) {
    warn "bad argument $regexp\n";
    usage();
}

$filename = '-' if not defined $filename;
my ($encoding, $credits, $ch, $progs) = @{XMLTV::read_data($filename)};

my @out;
PROG: foreach (@$progs) {
    CONJ: foreach my $conj (@conjunctions) {
	  foreach my $test (@$conj) {
	      # Every test in the conjunction must succeed.
	      next CONJ if not $test->();
	  }
	  # They all succeeded, write the programme.
	  push @out, $_;
	  next PROG;
      }
      # All the conjunctions failed, won't write.
}
XMLTV::write_data([$encoding, $credits, $ch, \@out]);

sub usage() {
    print STDERR <<END
usage: $0 [--ignore-case|-i] [expression|regexp] [file]
where expression may consist of
    --eval PERL_CODE
    --on-after DATE
    EXPR1 [--and|-and] EXPR2
    EXPR1 [--or|-or|-o] EXPR2
--and is implicit and may be omitted.
END
  ;
    exit(1);
}

# all_text()
#
# Get all pieces of text for a particular programme attribute.
#
# Parameters:
#   programme hashref
#   attribute name, eg 'title', 'desc'
#
# Returns: list of text strings for that attribute
#
# I wrote Lingua::Preferred::acceptable_lang() especially for this
# routine but then realized that when grepping you probably don't care
# about viewing only those strings applicable to the current language.
#
sub all_text( $$ ) {
    my ($p, $key) = @_;
    return () if not $p->{$key};
    return map { $_->[0] } @{$p->{$key}};
}

####
# Boolean tests.  These work on the programme $_ and return true or
# false.  Their behaviour should be affected, if appropriate, by the
# global $ignore_case.
#
my %warned_no_stop;
sub on_after( $ ) {
    my $cutoff = shift;
    my $stop = $_->{stop};

    if (not defined $stop) {
	# We use the start time instead, that will lose some shows
	# crossing the boundary but is mostly accurate.
	#
	my $start = $_->{start};
	my $pd = ParseDate($start);
	if (not defined $pd) {
	    warn "bad start time $start\n";
	    return 1;
	}

	my $result = (Date_Cmp($cutoff, $pd) < 0);
	if (not $result) {
	    # This programme was dropped, but maybe it wouldn't have
	    # been if it had a stop time.
	    #
	    # We should warn about this: but have an allowance of one
	    # programme per channel without stop time, because you
	    # can reasonably expect that from sorted listings.
	    #
	    unless ($warned_no_stop{$_->{channel}}++) {
		warn "not all programmes have stop times, "
		  . "cannot accurately filter those on after a certain time\n"
		    . "(maybe filter through sort_listings to add stop times)\n";
	    }
	}
	return $result;
    }
    else {
	my $pd = ParseDate($stop);
	if (not defined $pd) {
	    warn "bad stop time $stop\n";
	    return 1;
	}
	return (Date_Cmp($cutoff, $pd) < 0);
    }
}


sub match_regexp( $ ) {
    my $regexp = shift;
    # Stringify the whole darn thing and match against that.
    my $tmp = Dumper($_);
    return $ignore_case ? /$regexp/i : /$regexp/;
}


# Class for long option abbreviation.  You tell it all the options
# you're going to use, and then it will tell you whether a (possibly
# abbreviated) argument matches an option unambiguously, ambiguously
# could match several options, or matches none.
#
# Having to roll my own Getopt::Long is getting annoying.  I wonder
# how much of this code could be shared?
#
package OptionAbbrev;
use Log::TraceMessages qw(t d);

# Constructor.  Give a list of long options and/or add() them later.
sub new {
    my $proto = shift;
    my $class = (ref $proto) || $proto;

    # The representation of an object is a list of long options known
    # about.
    #
    my $self = [];
    bless $self, $class;
    $self->add(@_);
    return $self;
}

sub add {
    my $self = shift;
    foreach (@_) {
	die 'long options start with --' unless /^--/;
	foreach my $already (@$self) {
	    die "option $_ already added" if $_ eq $already;
	}
	push @$self, $_;
    }
    return $self;
}

# match() returns a list of possible long options matched.  So if the
# list has no elements, no match; one element is the unambiguous
# match; two or more elements mean ambiguity.
#
sub match {
    my ($self, $arg) = @_;
    t "matching arg $arg against list: " . d $self;
    return 0 unless $arg =~ /^--/;
    t 'begins with --, continue';
    foreach (@$self) {
	t "testing for exact match against $_";
	return ($_) if $arg eq $self;
    }
    t 'no exact match, try initial substring';
    my @r;
    foreach (@$self) {
	t "testing if $arg is initial substring of $_";
	push @r, $_ if index($_, $arg) == 0;
    }
    t 'returning list of matches: ' . d \@r;
    return @r;
}
