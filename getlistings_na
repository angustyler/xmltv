#!/usr/bin/perl -w
#
# $Id: getlistings_na,v 1.10 2001/11/12 22:46:05 jveldhuis Exp $
#
# This script scrapes www.zap2it.com tv listings, producing
# xmltv.dtd and channels.dtd compliant output. Zap2it supports
# both Canadian and US listings.
#
# ----------------------------------------------------------------------------
# "THE BEER-WARE LICENSE" (Revision 42):
# <jerry@matilda.com> wrote this file.  As long as you retain this notice you
# can do whatever you want with this stuff. If we meet some day, and you think
# this stuff is worth it, you can buy me a beer in return.   
# ----------------------------------------------------------------------------
# always wanted to use this licence, thanks Poul-Henning Kamp.
#
# Feel free to contact me with comments, contributions,
# and the like. jerry@matilda.com 
#
# Known Bugs
#  - accepts but ignores --startHour and --endHour parameters
#  - not all program qualifiers have been defined, so sometimes
#    program descriptions include qualifiers that are unidentified
#    These should be reported to the author
#  - hard to debug when problems occur
#  - some error messages come to stdout instead of stderr
#  - scraping error should include failed html (especially when they
#    successfuly scrape half of it then start missing.)
#  - channels should be dealt with in sorted order by channel #
#    not stationid order.
#
#
# See release notes and/or cvs logs entries for module history
#

my $VersionMajor="1";
my $VersionMinor="0";

my $VersionID="getlistings_na V$VersionMajor\.$VersionMinor";

#
# define name of getlistings_na config file
#
my $ConfigFile_g=".config_na";

use strict;

package myConfig;

sub new
{
    my($type) = shift;
    my $self={ @_ };            # remaining args become attributes
    
    bless($self, $type);
    return($self);
}

sub setValue($$$)
{
    my ($self, $key, $value)=@_;
    $self->{$key}=$value;
    if ( $key ne "option_postalcode" &&
	 $key ne "option_zipcode" &&
	 $key ne "option_provider" &&
	 $key ne "option_provider_desc" ) {
	die "attempt to set invalid key $key to $value";
    }
}

sub unsetValue($$$)
{
    my ($self, $key, $value)=@_;
    delete($self->{$key}) if ( defined($self->{$key}));
}

sub save($$)
{
    my ($self, $file)=@_;

    open(FD, "> $file") || return(-1);
    print FD "# config file: getlistings_na $VersionMajor.$VersionMinor\n";
    print FD "#\n";
    print FD "# this file is generated by running getlistings_na --configure\n";
    print FD "# the only change you should make is prefixing 'channel:' lines\n";
    print FD "# with a '#' to signal that they should be ignored during the\n";
    print FD "# grab step\n";
    print FD "#\n";
    if ( defined($self->{option_postalcode})) {
	print FD "postal code: $self->{option_postalcode}\n";
    }
    if ( defined($self->{option_zipcode}) ) {
	print FD "zip code: $self->{option_zipcode}\n";
    }
    print FD "provider: $self->{option_provider} \# ".
	$self->{option_provider_desc}."\n";
    
    foreach my $station (sort keys (%{$self->{channels}})) {
	if ( $self->{channels}->{$station}->{in} ) {
	    print FD "channel: $station # ".$self->{channels}->{$station}->{description}."\n";
	}
	else {
	    print FD "#channel: $station # ".$self->{channels}->{$station}->{description}."\n";
	}
    }
    close(FD);
    return(0);
}

sub load($$)
{
    my ($self, $file)=@_;

    open(FD, "< $file") || return(-1);
    while (<FD>) {
	s/\n$//o;
	if ( $. == 1 ) {
	    if ( m/^\#\s+config\s+file:\s*getlistings_na (\d+)\.(\d+)/o ) {
		# assumes version number is still 1.1
		if ( $1 != $VersionMajor || $2 != $VersionMinor ) {
		    print STDERR "$0: $file:$.: $1\.$2 is an unsupported version number\n";
		    close(FD);
		    return(-1);
		}
	    }
	    else {
		print STDERR "$0: $file:$.: unsupported version header\n";
		close(FD);
		return(-1);
	    }
	}
	elsif ( m/^#/o ) {
	    next;
	}
	elsif ( m/^postal code:\s*([^\s]+)$/o ) {
	    $self->setValue("option_postalcode", $1);
	}
	elsif ( m/^zip code:\s*([^\s]+)$/o ) {
	    $self->setValue("option_zipcode", $1);
	}
	elsif ( m/^provider:\s*([^\s]+)\s+\#\s+(.*)$/o ) {
	    $self->setValue("option_provider", $1);
	    $self->setValue("option_provider_desc", $2);
	}
	elsif ( m/^\#channel:\s*([^\s]+)\s+\#\s+(.*)$/o ) {
	    $self->{channels}->{$1}->{in}=0;
	    $self->{channels}->{$1}->{description}=$2;
	}
	elsif ( m/^channel:\s*([^\s]+)\s+\#\s+(.*)$/o ) {
	    $self->{channels}->{$1}->{in}=1;
	    $self->{channels}->{$1}->{description}=$2;
	}
	elsif ( m/^\s*$/o ) {
	    # ignore empty lines
	}
	else {
	    print STDERR "$0: $file:$.: invalid\n";
	    close(FD);
	    return(-1);
	}
	   
    }
    close(FD);
    if ( defined($self->{option_postalcode}) && defined($self->{option_zipcode})) {
	print STDERR "$0: $file: corrupt, only one of postal or zip can be defined\n";
	return(-1);
    }
    return(0);
}

1;

package main;

use Fcntl qw(:DEFAULT);
use XML::Writer;
use IO;
use Getopt::Long;
use ZapListings;
use Date::Manip;

#
# How this grabber works:

# Step 1 - Configure
#  
#   The configure step is meant to be run interactively.
#   You can use 'getlistings_na --configure --help' to see
#   how to run non-interactively, providing information on
#   the command line.

#   run 'getlistings_na --configure'
#
#   Follow the prompts to provide the necessary information.
#
#   When finished, configure will create a file $ConfigFile_g
#   which contains the postal/zip code, the provider id
#   and a line for each channel that provider supplies.
#   This file is what you specify with the --config command
#   line option to "Step 2 Grabbing Data". See Step 2 for details
#   of how this file is interpreted.
#

sub ConfigureUsage
{
    print "usage $0 --configure [options]\n";
    print "where options are:\n";
    print "   --help\n";
    print "     print configure help\n";
    print "\n";
    print "   --debug\n";
    print "     turn on debugging\n";
    print "\n";
    print "   --postalcode XXXXXX\n";
    print "     specify postal code, don't use with --zipcode\n";
    print "\n";
    print "   --zipcode YYYYYY\n";
    print "     specify zip code, don't use with --postalcode\n";
    print "\n";
    print "   --provider ZZZZZZZ\n";
    print "     specify provider id\n";
    print "\n";
    print "   --config <file>\n";
    print "     write results of configure to <file> instead of ./$ConfigFile_g\n";
    print "\n";
    print "If any neccessary options are given, interactive mode is enabled\n";
    print "Result of running configure is a xml formated configuration file\n";
    print "$ConfigFile_g in current directory (use --config to override location).\n";
}

# Step 2 - Grab
#   
#   The grab step uses the information collected during
#   configuration to get tv listings.
#  
#
#

sub Usage
{
    print "usage $0 [--help|--configure [configure-options] |[grab-options]]\n";
    print "command line options are:\n";
    print "   --help\n";
    print "     print this help\n";
    print "     use --configure --help for configure help or\n";
    print "     use --grab --help for grab help\n";
    print "\n";
    print "   --configure\n";
    print "     run configuration step, see --configure --help for more info\n";
    print "\n";
    print "grab-options are:\n";
    print "   --debug\n";
    print "     turn on debugging\n";
    print "\n";
    print "   --config <file>\n";
    print "     specify file that contains config information, default in ./$ConfigFile_g\n";
    print "     (created by using --configure)\n";
    print "\n";
    print "   --programs <file>\n";
    print "       specify programs.xml file in xml format\n";
    print "       <file> may contain Date::Manip::Unix substitutions\n";
    print "       for instance, use --programs \"prog-%d%m%Y.xml\" to separate output by day.\n";
    print "       if no --programs is specified stdout is used\n";
    print "\n";
    print "   --channels <file>\n";
    print "       specify channels.xml <file>\n";
    print "       <file> follows the similar rules to -programs (not sure why)\n";
    print "       default is 'channels.xml', empty string means don't write channels file  \n";
    print "\n";
    print "   --startHour x\n";
    print "       specify starting hour (24 hour clock, default 0)\n";
    print "\n";
    print "   --endHour y\n";
    print "       specify ending hour (default 24)\n";
    print "\n";
    print "   --days n\n";
   print "       specify number of days to include in output (default 1)\n";
}


# First lets check to see if someone asked for help.
# this is easier to do here than later.
my $configure=0;
if ( @ARGV ) {
    foreach my $arg (@ARGV) {
	$configure=1 if ( $arg=~m/^--configure/o );
    }
}

sub ask($)
{
    print "$_[0]";
    my $result=<>;
    chop($result) if ( defined($result) );
    return($result);
}

sub askyesorno($$)
{
    my ($def, $question)=@_;
    while ( 1 ) {
	my $res=ask("$question [$def] ");
	if ( !defined($res) || $res eq "" ) {
	    return($def);
	}
	$res=~tr/[A-Z]/[a-z]/;
	if ( $res eq "yes" ) {
	    return("yes");
	}
	elsif ( $res eq "no" ) {
	    return("no");
	}
	else {
	    print STDERR "invalid response, please use yes or no\n";
	    print STDERR "\n";
	}
    }
}

if ( $configure ) {
    use vars qw/$opt_configure $opt_help $opt_postalcode $opt_zipcode $opt_provider $opt_config $opt_debug/;

    $opt_debug=0;

    if ( ! GetOptions('configure', 'help', 'postalcode=s', 'zipcode=s', 'provider=s', 'config=s', 'debug') ) {
	ConfigureUsage();
	exit(1);
    }

    if ( defined($opt_help) ) {
	ConfigureUsage();
	exit(0);
    }

    my $config=new myConfig();
    
    my $configfile=$ConfigFile_g;
    if ( defined($opt_config) ) {
	if ( ! -f $opt_config ) {
	    print STDERR "$0: specified config file '$opt_config' does not exist, run --configure\n";
	    exit(1);
	}
	$configfile=$opt_config;
    }

    if ( -f $configfile && $config->load($configfile) != 0 ) {
	print STDERR "$0: Failed to read $configfile\n";
	exit(1);
    }

    if ( defined($opt_postalcode) && defined($opt_zipcode) ) {
	print STDERR "$0: only one of --postalcode and --zipcode is allowed\n";
	exit(1);
    }

    # command line arguments
    if ( defined($opt_postalcode) ) {
	$config->setValue("option_postalcode", $opt_postalcode);
	$config->unsetValue("option_zipcode");
    }

    if ( defined($opt_zipcode) ) {
	$config->setValue("option_zipcode", $opt_zipcode);
	$config->unsetValue("option_postalcode");
    }
    
    if ( defined($opt_provider) ) {
	$config->setValue("option_provider", $opt_provider);
	$config->setValue("option_provider_desc", ""); # unknown so reset to ''
    }

    # sanity check
    if ( defined($config->{option_postalcode}) && defined($config->{option_zipcode})) {
	print STDERR "$0: only one of postal or zip code can be defined\n";
	exit(1);
    }

    #
    # Go interactive to collect what we don't have
    #

    # if we have no postal code or zip code, the prompt for it
    if ( !defined($config->{option_postalcode}) && !defined($config->{option_zipcode})) {
	my $res=ask('what is your postal/zip code ?');
	if ( defined($res) && length($res) ) {
	   # $res=~tr/[a-z]/[A-Z]/;
	    if ( $res=~m/^[a-zA-Z]/o ) {
		$config->setValue("option_postalcode", $res);
	    }
	    else {
		$config->setValue("option_zipcode", $res);
	    }
	}
	else {
	    print STDERR "$0: failed to get postal/zip code\n";
	    exit(1);
	}
    }
    
    # get list of providers and give them the choice
    if ( !$config->{option_provider} ) {

	my $code;
	$code=$config->{option_postalcode} if ( defined($config->{option_postalcode}) );
	$code=$config->{option_zipcode} if ( defined($config->{option_zipcode}) );

	print STDERR "\ngetting list of providers for postal/zip code $code, be patient..\n";
	my $providers=ZapListings::getProviders($config->{option_postalcode},
						$config->{option_zipcode},
						$opt_debug);
	if ( !defined($providers) ) {
	    #print STDERR "$0: failed to get list of providers for postal/zip code $code\n";
	    #print STDERR "   visit zap2it.com and try the postal/zip code for more information\n";
	    exit(1);
	}

	while ( !$config->{option_provider} ) {
	    print "\n";
	    print "Id   \tService Provider\n";
	    print "-----\t---------------------------\n";
	    foreach my $key (sort keys (%{$providers}) ) {
		print "$providers->{$key}\t$key\n";
	    }
	    print "\n";
	    my $res=ask("Choose a service provider by id (use '0' to cancel):");
	    if ( defined($res) ) {
		if ( $res eq '0' ) {
		    print "operation cancelled by user\n";
		    exit(0);
		}

		foreach my $key (keys (%{$providers}) ) {
		    if ( $res eq $providers->{$key} ) {
			$config->{option_provider}=$providers->{$key};
			$config->{option_provider_desc}=$key;
		    }
		}
	    }
	}
    }

    # if we're in the configure step, lets refresh the list of channels
    # being careful to warn about additions and deletions
    
    if ( defined($config->{channels}) ) {
	print STDERR "\nchecking for changes to channel list, be patient..\n";
    }
    else {
	print STDERR "\ngetting channel list, be patient..\n";
    }

    my $channels=ZapListings::getChannelList($config->{option_postalcode},
					     $config->{option_zipcode},
					     $config->{option_provider},
					     $opt_debug);
    
    if ( !defined($channels) ) {
	#print STDERR "$0: failed to get list of channels for postal/zip code $config->{option_postalzipcode}\n";
	#print STDERR "   visit zap2it.com and try the postal/zip code for more information\n";
	exit(1);
    }

    my $newChannels;
    foreach my $station (keys %{$channels}) {
	my $letters=pop(@{$channels->{$station}});
	my $number=pop(@{$channels->{$station}});

	# default is channel is in listing
	$newChannels->{$station}="";
	$newChannels->{$station}.="$number " if ( defined($number) );
	$newChannels->{$station}.="$letters" if ( defined($letters) );
    }

    my $channelsUpdated=0;

    # notify user about update channel ids and new channels
    foreach my $station (keys %{$newChannels}) {
	if ( defined($config->{channels}) ) {
	    if ( $config->{channels}->{$station} ) {
		$config->{channels}->{$station}->{found}=1;

		# update description
		if ( $config->{channels}->{$station}->{description} ne 
		     $newChannels->{$station} ) {
		    print STDERR "Updated channel id: $station from \"".
			$config->{channels}->{$station}->{description}."\" to \"".
			$newChannels->{$station}."\"\n";
		    $config->{channels}->{$station}->{description}=$newChannels->{$station};
		    $channelsUpdated++;
		}
	    }
	    else {
		my $res=askyesorno('yes', "add channel $station \# ".$newChannels->{$station}." ?");
		$res=~tr/[A-Z]/[a-z]/;
		if ( $res eq 'yes' ) {
		    #print STDERR "Adding new channel id: $station \#".$newChannels->{$station}."\n";
		    $config->{channels}->{$station}->{found}=1;
		    $config->{channels}->{$station}->{in}=1;
		    $config->{channels}->{$station}->{description}=$newChannels->{$station};
		    $channelsUpdated++;
		}
	    }
	}
	else {
	    my $res=askyesorno('yes', "add channel $station \# ".$newChannels->{$station}." ?");
	    $res=~tr/[A-Z]/[a-z]/;
	    if ( $res eq 'yes' ) {
		#print STDERR "Adding new channel id: $station \#".$newChannels->{$station}."\n";
		$config->{channels}->{$station}->{found}=1;
		$config->{channels}->{$station}->{in}=1;
		$config->{channels}->{$station}->{description}=$newChannels->{$station};
		$channelsUpdated++;
	    }
	}
    }

    # warn about channel declarations we didn't find
    foreach my $station (sort keys (%{$config->{channels}})) {
	if ( defined($config->{channels}->{$station}->{found}) ) {
	    delete($config->{channels}->{$station}->{found});
	}
	else {
	    my $res=askyesorno('yes', "drop no-longer available channel $station \# ".$config->{channels}->{$station}->{description}." ?");
	    $res=~tr/[A-Z]/[a-z]/;
	    if ( $res eq 'yes' ) {
		#print STDERR "warning: didn't find channel id: $station \#".
		#    $config->{channels}->{$station}->{description}."\n";
		delete($config->{channels}->{$station});
		$channelsUpdated++;
	    }
	}
    }

    if ( $channelsUpdated == 0 ) {
	if ( defined($config->{channels}) ) {
	    print STDERR "\nchannel line-up hasn't changed\n";
	}
	else {
	    print STDERR "\nno channels added\n";
	}
    } 

    # write out config file
    print STDERR "\nupdating $configfile..\n";
    if ( $config->save($configfile) != 0 ) {
	print STDERR "$0: $configfile save failed\n";
	exit(1);

    }

    print STDERR "\nconfiguration step complete, let the games begin !\n";
    exit(0);
}

# in grabber mode - yeah !

use vars qw/$opt_help $opt_config $opt_debug $opt_programs $opt_channels $opt_startHour $opt_endHour $opt_days/;

$opt_debug=0;

if ( ! GetOptions('help', 'config=s', 'debug', 'programs=s', 'channels=s', 'startHour=i', 'endHour=i', 'days=i') ) {
    Usage();
    exit(1);
}

if ( defined($opt_help) ) {
    Usage();
    exit(0);
}

# setup defaults
$opt_programs="" if ( !defined($opt_programs) );
$opt_channels="channels.xml" if ( !defined($opt_channels) );
$opt_startHour=0 if ( !defined($opt_startHour) );
$opt_endHour=24 if ( !defined($opt_endHour) );
$opt_days=1 if ( !defined($opt_days) );

if ( $opt_startHour < 0 || $opt_startHour > 23 ) {
    print STDERR "specified startHour must be between 0 and 23\n";
    Usage();
    exit(1);
}
if ( $opt_endHour < 1 || $opt_endHour > 24 ) {
    print STDERR "specified endHour must be between 1 and 24\n";
    Usage();
    exit(1);
}
if ( $opt_endHour < $opt_startHour ) {
    print STDERR "specified endHour must be greater than startHour\n";
    Usage();
    exit(1);
}

if ( $opt_days < 0 || $opt_days > 14 ) {
    print STDERR "specified days must be between 1 and 14\n";
    Usage();
    exit(1);
}

STDOUT->autoflush(1);

my @FilesWeOpened_g;

my $failed=grab();

if ( $failed ) {
    print STDERR "cleaning up after failure..\n";
    if ( @FilesWeOpened_g ) {
	for my $file (@FilesWeOpened_g) {
	    if ( -f $file ) {
		#print STDERR "   removing $file\n";
		unlink($file);
	    }
	}
    }
    exit(1);
}
exit(0);

sub writeProgramXMLHeader($)
{
    my $writer=shift;

    $writer->xmlDecl("ISO-8859-1", "1.0");
    $writer->doctype('tv', undef, 'xmltv.dtd');
    $writer->startTag('tv',
		      date                  =>Date::Manip::UnixDate("now","%T on %b %e, %Y"),
		      'source-info-url'     =>"http://www.zap2it.com",
		      'source-info-name'    =>"Zap2It",
		      'source-data-url'     =>"http://tvlistings2.zap2it.com/textall.asp",
		      'generator-info-name' =>"$VersionID",
		      'generator-info-url'  =>'http://www.sourceforge.net/projects/xmltv');
}

sub writeProgramXMLFooter($)
{
    my $writer=shift;
    $writer->endTag('tv');
}

sub writeChannelXMLHeader($)
{
    my $writer=shift;

    $writer->xmlDecl("ISO-8859-1", "1.0");
    $writer->doctype('channels', undef, 'channels.dtd');
}

sub writeChannelXMLFooter($)
{
    my $writer=shift;
    $writer->endTag('channels');
}

sub grab
{
    my $startTime=time();
    # initalize global XML::Writer if we're writting programs to stdout
    # or if all programs are to being output'd to a single file.
    # The later allows us to use --programs tv.xml with more than one
    # days listings.
    my $Pwriter_g;
    my $Cwriter_g;

    # Poutput_g is only used if we are writting all Programs to the same file.
    my $Poutput_g;
    my $Coutput_g;

    my $config=new myConfig();
    
    my $configfile=$ConfigFile_g;
    if ( defined($opt_config) ) {
	if ( ! -f $opt_config ) {
	    print STDERR "$0: specified config file '$opt_config' does not exist, run --configure\n";
	    return(1);
	}
	$configfile=$opt_config;
    }
    else {
	if ( ! -f $configfile ) {
	    print STDERR "$0: config file '$configfile' does not exist, run --configure\n";
	    return(1);
	}
    }

    if ( $config->load($configfile) != 0 ) {
	print STDERR "$0: Failed to read $configfile\n";
	return(1);
    }
    
    my $stats;

    $stats->{num_channels}=0;
    $stats->{num_programs}=0;
    $stats->{num_days}=0;

    if ( !length($opt_channels) ) {
    }
    elsif ( UnixDate("now","$opt_channels") eq $opt_channels ) {
	print STDERR "writing Channels to $opt_channels\n";
	$Coutput_g = new IO::File("> $opt_channels") || die "$opt_channels: $!";
	push(@FilesWeOpened_g, $opt_channels);
	$Cwriter_g = new XML::Writer(OUTPUT=>$Coutput_g,
				     DATA_MODE => 1, DATA_INDENT => 2 );
	writeChannelXMLHeader($Cwriter_g);
	$stats->{num_channels}=writeOutChannels($config, $Cwriter_g);
    }

    if ( !length($opt_programs) ) {
	print STDERR "writing Programs to stdout\n";
	$Pwriter_g = new XML::Writer(DATA_MODE => 1, DATA_INDENT => 2 );
	writeProgramXMLHeader($Pwriter_g);
    }
    elsif ( UnixDate("now","$opt_programs") eq $opt_programs ) {
	print STDERR "writing Programs to $opt_programs\n";
	$Poutput_g = new IO::File("> $opt_programs") || die "$opt_programs: $!";
	push(@FilesWeOpened_g, $opt_programs);
	$Pwriter_g = new XML::Writer(OUTPUT=>$Poutput_g,
				     DATA_MODE => 1, DATA_INDENT => 2 );
	writeProgramXMLHeader($Pwriter_g);
    }

    my $failedCount=0;
    my ($y,$m,$d,$h,$mn,$s)=Date::Manip::Date_Split(ParseDateString("now"));
    my $startNDay=Date_DayOfYear($m,$d,$y);
    my $tz=Date_TimeZone();

    #
    # So that the output a day at a time, this allows for separate files per day
    #
    my $year=$y;
    for (my $nday=0; $nday<$opt_days ; $nday++) {
	my $Pwriter;
	my $Poutput;

	$stats->{num_days}++;;

	my $dateStr=createDateString(0, $startNDay+$nday, $year, 0, $tz);

	if ( !defined($Cwriter_g) ) {
	    my $filename=UnixDate($dateStr, "$opt_programs");
	    if ( $opt_programs eq $filename ) {
		die "This case should have been caught before here";
	    }
	    
	    print STDERR "writing Channels to $filename\n";
	    my $Coutput = new IO::File("> $filename") || die "$filename: $!";
	    push(@FilesWeOpened_g, $filename);
	    my $Cwriter = new XML::Writer(OUTPUT=>$Coutput,
				       DATA_MODE => 1, DATA_INDENT => 2 );
	    writeChannelXMLHeader($Cwriter);
	    $stats->{num_channels}=writeOutChannels($config, $Cwriter);
	    writeChannelXMLFooter($Cwriter);
	    $Cwriter->end();
	    $Coutput->close() if ( defined($Coutput) );
	}
	
	if ( defined($Pwriter_g) ) {
	    $Pwriter=$Pwriter_g;
	}
	else {
	    my $filename=UnixDate($dateStr, "$opt_programs");
	    if ( $opt_programs eq $filename ) {
		die "This case should have been caught before here";
	    }
	    
	    print STDERR "writing Programs to $filename\n";
	    $Poutput = new IO::File("> $filename") || die "$filename: $!";
	    push(@FilesWeOpened_g, $filename);
	    $Pwriter = new XML::Writer(OUTPUT=>$Poutput, DATA_MODE => 1, DATA_INDENT => 2 );
	    
	    writeXMLProgramHeader($Pwriter);
	}
	
	my $lg=new ZapListings::Scraper('PostalCode'=> $config->{option_postalcode},
					'ZipCode'   =>$config->{option_zipcode},
					'ProviderID'=>$config->{option_provider},
					'Debug'     =>$opt_debug);

	foreach my $station (keys %{$config->{channels}}) {
	    
	    next if ( !$config->{channels}->{$station}->{in} );
	    
	    my ($year,$month,$day,$hr,$min,$sec)=Date::Manip::Date_NthDayOfYear($y, $startNDay+$nday);
	    
	    if ( $lg->readSchedule($station, 
				   $config->{channels}->{$station}->{description},
				   $opt_startHour, $opt_endHour, $day, $month, $year) == -1 ) {
		warn("readSchedule failed for $day/$month/$year for station $station");
		$failedCount++;
	    }
	    else {
		# set time zone for date conversions
		#Date::Manip::Date_SetConfigVariable('TZ', $lg->{TimeZone});
		#Date::Manip::Date_Init();
		
		$stats->{num_programs}+=writeOutPrograms($lg, $startNDay+$nday, $year, $tz, $Pwriter, $station);
	    }
	}
	
	if ( !defined($Pwriter_g) || $Pwriter != $Pwriter_g ) {
	    writeProgramXMLFooter($Pwriter);
	    $Pwriter->end();
	    $Poutput->close();
	}
    }

    if ( defined($Cwriter_g) ) {
	writeChannelXMLFooter($Cwriter_g);
	$Cwriter_g->end();
	$Coutput_g->close() if ( defined($Coutput_g) );
    }

    if ( defined($Pwriter_g) ) {
	writeProgramXMLFooter($Pwriter_g);
	$Pwriter_g->end();
	$Poutput_g->close() if ( defined($Poutput_g) );
    }

    my $endTime=time();
    printf(STDERR "Grabbed %d programs on %d channels over %d day(s) in %d seconds\n",
	   $stats->{num_programs},
	   $stats->{num_channels},
	   $stats->{num_days},
	   $endTime-$startTime);

    printf(STDERR "  not too bad, that's %.2f programs/sec and %.2f seconds/www page\n",
	   $stats->{num_programs}/($endTime-$startTime),
	   ($endTime-$startTime)/($stats->{num_days}*$stats->{num_channels}));
	    
    return($failedCount);
}

# create a conversion string
sub createDateString($$$$$)
{
    my ($minuteOfDay, $dayOfYear, $year, $additionalMin, $time_zone)=@_;
    
    if ( $additionalMin != 0 ) {
	$minuteOfDay+=$additionalMin;

	# deal with case where additional minutes pushes us over end of day
	if ( $minuteOfDay > 24*60 ) {
	    $minuteOfDay-=24*60;
	    $dayOfYear++;

	    # check and deal with case where this pushes us past end of year
	    my $isleap=Date_LeapYear($year);
	    if ($dayOfYear >= ($isleap ? 367 : 366)) {
		$year++;
		$dayOfYear-=($isleap ? 367 : 366);
	    }
	}
    }

    # calculate year,month and day from nth day of year info
    my ($pYEAR,$pMONTH,$pDAY,$pHR,$pMIN,$pSEC)=Date::Manip::Date_NthDayOfYear($year, $dayOfYear);

    # set HR and MIN to what they should really be
    $pHR=int($minuteOfDay/60);
    $pMIN=$minuteOfDay-($pHR*60);

    return(sprintf("%4d%02d%02d%02d%02d00 %s", $pYEAR, $pMONTH, $pDAY, $pHR, $pMIN, $time_zone));
}

sub writeOutPrograms($$$$$$)
{
    my ($lg, $dayOfYear, $year, $mytz, $writer, $channel)=@_;
    my $IncludePartialPrograms=0;

    my @programs=$lg->getPrograms();

    for my $prog (@programs) {

	$prog->{start}=createDateString(($prog->{start_hour}*60+$prog->{start_min}), $dayOfYear, $year, 0, $mytz);
	delete($prog->{start_hour});
	delete($prog->{start_min});
	if ( $prog->{end_hour} >= 24 ) {
	    $prog->{end}=createDateString((($prog->{end_hour}-24)*60+$prog->{end_min}), $dayOfYear+1, $year, 0, $mytz);
	}
	else {
	    $prog->{end}=createDateString(($prog->{end_hour}*60+$prog->{end_min}), $dayOfYear, $year, 0, $mytz);
	}
	delete($prog->{end_hour});
	delete($prog->{end_min});

	my $title=$prog->{title};
	    
	#print STDERR "storing $title..\n";

	if ( defined($prog->{contFromPreviousListing}) ) {
	    if ( !$IncludePartialPrograms ) {
		#print STDERR "warning: not including program $prog->{title} which starts previous to listing\n";
		next;
	    }
	    $title="(<-cont) $title";
	}
	if ( defined($prog->{contToNextListing}) ) {
	    if ( !$IncludePartialPrograms ) {
		#print STDERR "warning: not including program $prog->{title} which ends past listing boundaries\n";
		next;
	    }
	    $title="$title (cont->)";
	}
	
	$writer->startTag('programme', start=> $prog->{start}, 
			  stop => $prog->{end}, channel=> "$channel");
	$writer->dataElement('title', $title);
	$writer->dataElement('sub-title', $prog->{subtitle}) if ( defined($prog->{subtitle}) );
	$writer->dataElement('desc', $prog->{desc}) if ( defined($prog->{desc}) );
		
	if ( defined($prog->{director}) || defined($prog->{actors}) ) {
	    $writer->startTag('credits');
	    $writer->dataElement('director', $prog->{director}) if ( defined($prog->{director}) );
	    if ( defined($prog->{actors}) ) {
		foreach my $actor (@{$prog->{actors}}) {
		    $writer->dataElement('actor', $actor);
		}
	    }
	    $writer->endTag('credits');
	}
	$writer->dataElement('date', $prog->{year}) if ( defined($prog->{year}) );
	
	if ( defined($prog->{category}) ) {
	    foreach my $cat(@{$prog->{category}}) {
		$writer->dataElement('category', $cat);
	    }
	}
	# hunt for things in the "qualifiers bucket" where alot of things fall.
	if ( defined($prog->{qualifiers}) ) {
	    if ( defined($prog->{qualifiers}->{PaidProgram}) ) {
		# FIXME I don't that payment counts as a
		# 'category'.  Though there should probably be
		# some way to include it.  -- epa98@doc.ic.ac.uk
		# 
		$writer->dataElement('category', "advertisement");
	    }
	    if ( defined($prog->{qualifiers}->{Language}) ) {
		if ( defined($prog->{qualifiers}->{Dubbed}) ) {
		    $writer->dataElement('orig-language', $prog->{qualifiers}->{Language});
		}
		else {
		    $writer->dataElement('language', $prog->{qualifiers}->{Language});
		}
	    }
	    
	    if ( defined($prog->{qualifiers}->{Taped}) ) {
		# nowhere to put this
	    }
	    if ( defined($prog->{qualifiers}->{InProgress}) ) {
		# nowhere to put this
	    }
	    if ( defined($prog->{qualifiers}->{PartInfo}) ) {
		# nowhere to put this
		# comes in the form of "Part 1 of 2"
	    }
	    if ( defined($prog->{qualifiers}->{Live}) ) {
		# nowhere to put this
	    }
	    if ( defined($prog->{qualifiers}->{Animated}) ) {
		# nowhere to put this 
	    }
	    if ( defined($prog->{qualifiers}->{HDTV}) ) {
		# nowhere to put this 
	    }
	    if ( defined($prog->{qualifiers}->{BlackAndWhite}) ) {
		$writer->startTag('video');
		$writer->dataElement('colour', 'no');
		$writer->endTag('video');
	    }
	    if ( defined($prog->{qualifiers}->{InStereo}) ) {
		$writer->startTag('audio');
		$writer->dataElement('stereo', '');
		$writer->endTag('audio');
	    }
	    if ( defined($prog->{qualifiers}->{PreviouslyShown}) ) {
		$writer->dataElement('previously-shown');
	    }
	    if ( defined($prog->{qualifiers}->{PremiereShowing}) ) {
		$writer->dataElement('premiere',$prog->{qualifiers}->{PremiereShowing});
	    }
	    if ( defined($prog->{qualifiers}->{LastShowing}) ) {
		$writer->dataElement('last-chance',$prog->{qualifiers}->{LastShowing});
	    }
	    
	    if ( defined($prog->{qualifiers}->{Subtitles}) ) {
		$writer->dataElement('subtitles', '', 'type' => "onscreen");
	    }
	    elsif ( defined($prog->{qualifiers}->{ClosedCaptioned}) ) {
		$writer->dataElement('subtitles', '', 'type' => "teletext");
	    }
	}
	if ( defined($prog->{ratings_VCHIP}) ) {
	    if ( defined($prog->{ratings_VCHIP_Expanded}) ) {
		$writer->dataElement('rating', "$prog->{ratings_VCHIP} $prog->{ratings_VCHIP_Expanded}", system =>'VCHIP');
	    }
	    else {
		$writer->dataElement('rating', "$prog->{ratings_VCHIP}", 'system' =>'VCHIP');
	    }
	}
	$writer->dataElement('rating', "$prog->{ratings_MPAA}", 'system' =>'MPAA') if ( defined($prog->{ratings_MPAA}) );

	if ( defined($prog->{ratings_Warnings}) ) {
	    my %hash;
	    foreach my $k ( sort @{$prog->{ratings_Warnings}}) {
		$hash{$k}=1;
	    }
	    foreach my $k ( keys %hash ) {
		$writer->dataElement('rating', "$k", 'system' =>'General Warning');
	    }
	}
	if ( defined($prog->{stars_rating}) ) {
	    # nowhere to put this yet.
	    # comes in the form of a rating out fraction out of 4
	}
	$writer->endTag('programme');
    }
    return(scalar(@programs));
}

# write the channels in xml format
sub writeOutChannels($$)
{
    my ($config, $writer)=@_;

    if ( 1 ) {
	$writer->startTag('channels');
    }
    else {
	# I've request this change the channels.xml, we'll wait for a decision
	# before nenabling it :)
	$writer->startTag('channels',
			  date=>UnixDate("now","%T on %b %e, %Y"),
			  'source-info-url'     =>"http://www.zap2it.com",
			  'source-info-name'    =>"Zap2It",
			  'source-data-url'     =>"http://tvlistings2.zap2it.com/textall.asp",
			  'generator-info-name' =>"$VersionID",
			  'generator-info-url'  =>'http://www.sourceforge.net/projects/xmltv');
    }

    foreach my $station (keys %{$config->{channels}}) {
	
	next if ( !$config->{channels}->{$station}->{in} );

	$writer->startTag('channel', id=> $station);

	$writer->dataElement('display-name', "Channel $config->{channels}->{$station}->{description}");

	# not supported as of yet
	#$writer->dataElement('url', $channel->{url}) if ( defined($channel->{url}) );
	$writer->endTag('channel');
    }

    return(scalar(keys %{$config->{channels}}));;
}

1;
