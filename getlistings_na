#!/usr/bin/perl -w

#
# ----------------------------------------------------------------------------
# "THE BEER-WARE LICENSE" (Revision 42):
# <jerry@matilda.com> wrote this file.  As long as you retain this notice you
# can do whatever you want with this stuff. If we meet some day, and you think
# this stuff is worth it, you can buy me a beer in return.   
# ----------------------------------------------------------------------------
# always wanted to use this licence, thanks Poul-Henning Kamp.
#
# Feel free to contact me with comments, contributions,
# and the like. jerry@matilda.com 
#

use strict;

#
# This script scrapes www.clicktv.com, while trying to remain
# compatible with www.tvguide.ca which shares the same user
# Profiles, but produces the schedule listings in a slightly
# different format.
# 
# Clicktv supports both Canadian and US listings.
#
my $VersionID="getlistings_na V0.1";

# Note: I decided not to cache any program listings html pages like
#       other xmltv scripts since I'm reading multiple listings and
#       resolving programs that span listings, so if one is out of date
#       the script may fail.
#
# To use this script you must:
#  1. visit www.clicktv.com (or tvguide.ca) and setup a membership. 
#     a) In "Login Settings", its important to:
#        - set your postal code / zip correctly
#        - set your 'Observes Daylight Saving' setting appropriately
#     b) In "Line-up Settings", choose your service.
#     c) In "Line-up Arrangement", choose to channels you
#        want to include in the channel "display" list.
#     d) In "Layout Grid" set
#        - channels deep to "All"
#        - hours wide to "6 hours" (script should work with any setting
#          but this minimizes the # of www page requests)
#        - "tick" the details you wish included in the output.
#          (only tested with all ticked)
#          Note: a future version might include a way to control what
#          details are ignored when writting output.
#
#  2. click on "Listing" button 
#     a) verify the text above the date/time selections near the top
#        of the page reads your location, date/time and timezone
#        is correct.
#     b) copy/paste everything in the url following "profileID=" into
#        the $ServiceID variable below. Note: be sure not to
#        include 'gDate=' or 'Hour=' settings that may appear at
#        the end of the url. For instance my test ServiceID is:
#        'profileID=%247A%247A%248F%2471%248D%248A&WSN=WSERVER20&UserID=%2479%2474%248C%2474%2490%2487'

my $ServiceID="profileID=%247A%247A%248F%2471%248D%248A&WSN=WSERVER20&UserID=%2479%2474%248C%2474%2490%2487";

#
#     c) If your not interested in the entire days schedule, you
#        can either specify a range on the cmd line (useing -start and -end)
#        or you can modify the '$StartHour' and '$EndHour' values below.
#        see "Output Hours" section for details.

#
# Output Days
# -----------
# Set the number of days of listings to output. ClickTV like most
# sources only support up to 14 days in advance.
#
# The number of days included may be set at run-time via the command line.
#
my $Days=1;

#
# Output Hours
# ------------
# These settings are used to help refine the hours included in output.
# They are really the range of programming your interested in. A schedule
# request only requires a starting hour, and the number of
# hours in the resulting schedule are determined by YOUR preferences 
# setting at the www site. So the 'start' hour is really hour used in that
# first request. The 'end' hour is the hour that must appear (or at least the 
# start of the 'end' hour) in the schedule for the schedule retrieval to
# consider itself finished.
#
# Unless you enable 'include partial listings', the default settings (include
# being off) means the the output will include all programs that start at
# or after the 'start' hour and end prior to or at 'end' hour.
#
# A 24 hour clock is used to define the 'start' and 'end' hours.
# The 'start' hour must be between 0 (== 12am) and 23 (11pm), and
# 'end' hour may be any value greater than 'start' hour and < 30. 'End' hours
# greater than 24 allow you to ensure programs that start at 12pm, or even
# 1am (that same night) are included in the output.
#
# Other filtering techniques should be used to more finely tune theN
# output as needed.
#
# Warning: using a 'start' value <6 and a 'end' value that is > 24 may
# result in programs appearing more than once if running for more than one
# day.
#
# 'start' and 'end' hours may be set at run-time via the command line.
#
my $StartHour=15;
my $EndHour=26;

#
# Partial Programs
# ----------------
# If you want programs that end after, but start prior to the 'start'
# (defined above) and programs that start prior but don't end until after
# 'end' hour (defined above) set '$IncludePartialPrograms' to non-zero.
# Since xmltv format doesn't support partial program listings (or at least
# programs that don't have a start time), the program title is prepended
# with "(<- cont)" or appended with "(cont ->)" as appropriate.
#
# Using this feature isn't recommended since this violates the xmltv
# specificatoin and results in programs with modified titles, and unreliable
# start and end dates.
#
my $IncludePartialPrograms=0;

# Program Details
# ------------------
# ClickTV only categorizes programs in the schedule grid by colour
# coding the entires into 5 categories. Currently: Movies, Sports, Kids Show,
# Music, Specials and Sci-Fi. The fact that these didn't seem useful to
# me and the html decode would have been hell, I decided to instead add
# an option to get the details for every program containing a url link.
# The detail page includes a much more diverse group of categories
# and subcategories.
#
# WARNING: an extra html page for each program can be VERY expensive
# both in time and bandwidth. Before permanently enabling, run once
# with and once without to determine if its right for you.
#
# Since the extra page is so expensive, an option of creating a details
# cache helps by caching a minimal version of the details (post parsing)
# keyed on the program title. Using the cache based on the program title
# gets you what you asked for, fast and possibly wrong answers, since there
# are certainly cases where the program title is the same for two completly
# different programs. If you want the right answers pay the price and disable
# the cache.
# 
# to disable the cache, set ExpandedDetailsCacheName to undef or an empty
# string.
my $ExpandedDetails=0;
my $ExpandedDetailsCacheName="progDetails.db";

# Output Format(s)
# ----------------
# Currently the only support output format XMLTV.
# Future version may include html, or csv files...
#
# Specify --channels=channels.xml which saves an XMLTV
# xml description of the channels found.

my $Format="xmltv";
my $programsFile="programs-%d%m%Y.xml";
my $channelsFile="channels.xml";

#
# Unidentified Detail Qualifiers
# ------------------------------
# program details and qualifiers can optionally be stored to a
# "unidentified qualifiers" database so you don't see the same
# parse warning for these more than once. 
#
# If you want, you can use --dumpQualifiers and submit these for
# possible additions the list of qualifiers that are understood.
#
my $undefQualifiersDB="unknownQualifiers.db";

use ClickListings;
use Getopt::Long;

sub Usage
{
    print STDERR "usage: $0 [options]\n";
    print STDERR "where options is:\n";
    print STDERR "   --programs <file>    specify programs.xml file in xml format\n";
    print STDERR "       <file> may contain Date::Manip::Unix substitutions\n";
    print STDERR "       for instance, use --programs \"prog-%d%m%Y.xml\" to separate output by day.\n";
    print STDERR "   --channels <file>    specify channels.xml <file>\n";
    print STDERR "       <file> follows the same rules as -programs (not sure why)\n";
    print STDERR "   --startHour x        specify starting hour (see script comments)\n";
    print STDERR "   --endHour y          specify ending hour (see script comments)\n";
    print STDERR "   --days n             specify number of days to include in output\n";
    print STDERR "   --trackQualifiers <path2db> specify the DB_File database to\n";
    print STDERR "                        store unidentified program qualifiers in\n";
    print STDERR "\n";
    print STDERR "   --dumpQualifiers     dump unidentified qualifiers found.\n";
}

use vars qw/ $opt_programs $opt_channels $opt_startHour $opt_endHour $opt_days $opt_trackQualifiers $opt_dumpQualifiers/;

if ( ! GetOptions('programs=s', 'channels=s', 'startHour=i', 'endHour=i', 'days=i', 'trackQualifiers=s',
		  'dumpQualifiers') ) {
    Usage();
    exit(1);
}
$opt_programs=$programsFile if ( !defined($opt_programs) );
$opt_channels=$channelsFile if ( !defined($opt_channels) );
$opt_startHour=$StartHour if ( !defined($opt_startHour) );
$opt_endHour=$EndHour if ( !defined($opt_endHour) );
$opt_days=$Days if ( !defined($opt_days) );
$opt_trackQualifiers=$undefQualifiersDB if ( !defined($opt_trackQualifiers) );

if ( defined($opt_dumpQualifiers) ) {
    use DB_File;

    my %hash;
    tie (%hash, "DB_File", $opt_trackQualifiers, O_RDWR, 0444) || die "$opt_trackQualifiers: $!";
    
    print "List of identified qualifiers that are not understood:\n";
    foreach my $key (keys %hash) {
	print "\t$key\n";
    }
    untie %hash;
    exit(0);
}

if ( $opt_startHour < 0 || $opt_startHour > 23 ) {
    print STDERR "specified startHour must be between 0 and 23\n";
    Usage();
    exit(1);
}
if ( $opt_endHour < 1 || $opt_endHour > 30 ) {
    print STDERR "specified endHour must be between 1 and 30\n";
    Usage();
    exit(1);
}
if ( $opt_endHour < $opt_startHour ) {
    print STDERR "specified endHour must be greater than startHour\n";
    Usage();
    exit(1);
}

if ( $opt_days < 0 || $opt_days > 14 ) {
    print STDERR "specified days must be between 1 and 14\n";
    Usage();
    exit(1);
}

STDOUT->autoflush(1);

# tvguidelive.clicktv.com would probably also work here, but I havn't
# tried for a couple of versions.
#my $SourceHost="tvguidelive.clicktv.com";
my $SourceHost="www.clicktv.com";

my $startNDay;

my ($y,$m,$d,$h,$mn,$s)=&Date::Manip::Date_Split(&Date::Manip::ParseDateString("now"));
$startNDay=&Date::Manip::Date_DayOfYear($m,$d,$y);

if ( 0 ) {
    # used for testing... 
    ($y,$m,$d,$h,$mn,$s)=&Date::Manip::Date_Split(&Date::Manip::ParseDateString("June 17, 2001"));
    $startNDay=&Date::Manip::Date_DayOfYear($m,$d,$y);
    #$startDate=&Date::Manip::Date_SecsSince1970($m,$d,$y,0,0,1);
}

use Fcntl qw(:DEFAULT);
use DB_File;

# tie undefQualifiers to db file
my %undefQualifiers;

if ( defined($opt_trackQualifiers) && length($opt_trackQualifiers) ) { 
    tie (%undefQualifiers, "DB_File", $opt_trackQualifiers, O_RDWR|O_CREAT) || die "$opt_trackQualifiers: $!";
}

# special case if you want all the listings for multiple days
# if so, we grab and resolve "spanning" programs in the listings by
# requesting multiple days in one call
if ( $opt_startHour == 0 && $opt_endHour == 24 ) {
    my $lg=new ClickListings('ServiceID' => $ServiceID,
			     'URLBase' => "http://$SourceHost/listings.asp",
			     'DetailURLBase' => "http://$SourceHost/detail.asp",
			     'undefQualifiers' => \%undefQualifiers);

    # build an array of the dates we should collect
    my @dates;
    for (my $nday=0; $nday<$opt_days ; $nday++) {
	push(@dates, [$opt_startHour, $opt_endHour, $startNDay+$nday, $y]);
    }
    $lg->readSchedule(@dates);
    $lg->expandDetails($ExpandedDetailsCacheName) if ( $ExpandedDetails );

    # set time zone for date conversions
  Date::Manip::Date_SetConfigVariable('TZ', $lg->{TimeZone});
  Date::Manip::Date_Init();

    writeOutChannels($lg);
    writeOutPrograms($lg);
}

# otherwise we'll don't need to resolve programs that span days, so
# we instead loop over the days, and produce output for each
else {
    # build an array of the dates we should collect
    for (my $nday=0; $nday<$opt_days ; $nday++) {
	my $lg=new ClickListings('ServiceID' => $ServiceID,
				 'URLBase' => "http://$SourceHost/listings.asp",
				 'DetailURLBase' => "http://$SourceHost/detail.asp",
				 'undefQualifiers' => \%undefQualifiers);
	
	$lg->readSchedule([$opt_startHour, $opt_endHour, $startNDay+$nday, $y]);
	$lg->expandDetails($ExpandedDetailsCacheName) if ( $ExpandedDetails );

	# set time zone for date conversions
      Date::Manip::Date_SetConfigVariable('TZ', $lg->{TimeZone});
      Date::Manip::Date_Init();
	
	writeOutChannels($lg);
	writeOutPrograms($lg);
    }
}
if ( defined($opt_trackQualifiers) && length($opt_trackQualifiers) ) { 
    untie(%undefQualifiers);
}
exit(0);

use XML::Writer;
use IO;

# write the channels in xml format
sub writeOutChannels
{
    my ($lg)=@_;

    my $filename=&Date::Manip::UnixDate($lg->getProgramStartTime(),"$opt_channels");

    print "writing Channels to $filename\n";
    my $output = new IO::File("> $filename") || die "$filename: $!";

    my $writer = new XML::Writer(OUTPUT=>$output, DATA_MODE => 1, DATA_INDENT => 2 );
    $writer->xmlDecl("ISO-8859-1", "1.0");
    $writer->doctype('channels', undef, 'channels.dtd');

    if ( 1 ) {
	$writer->startTag('channels');
    }
    else {
	# I've request this change the channels.xml, we'll wait for a decision
	# before nenabling it :)
	$writer->startTag('channels',
			  date=>&Date::Manip::UnixDate("now","%T on %b %e, %Y"),
			  source=>"$SourceHost",
			  author=>"$VersionID");
    }
    my @Channels=$lg->getChannelList();
    for (my $chindex=0 ; $chindex< scalar(@Channels) ; $chindex++) {
	my $channel=$Channels[$chindex];
	my $chId;
	if ( defined($channel->{localStation}) ) {
	    $chId="$channel->{number} $channel->{localStation}";
	}
	else {
	    $chId="$channel->{number}"; 
	}
	$writer->startTag('channel', id=> $chId);
	$channel->{xml_id}=$chId;
	if ( defined($channel->{affiliate}) ) {
	    $writer->dataElement('display-name', "Channel $chId ($channel->{affiliate})");
	}
	else {
	    $writer->dataElement('display-name', "Channel $chId");
	}
	# not supported as of yet
	#$writer->dataElement('url', $channel->{url}) if ( defined($channel->{url}) );
	$writer->endTag('channel');
    }
    $writer->endTag('channels');
    $writer->end();
    $output->close();
}

sub writeOutPrograms
{
    my ($lg)=@_;

    my $filename=&Date::Manip::UnixDate($lg->getProgramStartTime(),"$opt_programs");

    print "writing Programs to $filename\n";
    my $output = new IO::File("> $filename") || die "$filename: $!";

    my $writer = new XML::Writer(OUTPUT=>$output, DATA_MODE => 1, DATA_INDENT => 2 );

    $writer->xmlDecl("ISO-8859-1", "1.0");
    $writer->doctype('tv', undef, 'xmltv.dtd');
    $writer->startTag('tv',
		      date=>&Date::Manip::UnixDate("now","%T on %b %e, %Y"),
		      source=>"$SourceHost",
		      author=>"$VersionID");

    my @Channels=$lg->getChannelList();
    for (my $chindex=0 ; $chindex< scalar(@Channels) ; $chindex++) {
	my @progs=$lg->getProgramsOnChannel($chindex);
	
	foreach my $p (@progs) {
	    my $prog=$p->{program};
	    my $title=$prog->{title};
	    
	    #print STDERR "storing $title..\n";

	    if ( defined($p->{contFromPreviousListing}) ) {
		if ( !$IncludePartialPrograms ) {
		    #print STDERR "warning: not including program $prog->{title} which starts previous to listing\n";
		    next;
		}
		$title="(<-cont) $title";
	    }
	    if ( defined($p->{contToNextListing}) ) {
		if ( !$IncludePartialPrograms ) {
		    #print STDERR "warning: not including program $prog->{title} which ends past listing boundaries\n";
		    next;
		}
		$title="$title (cont->)";
	    }
	    
	    $writer->startTag('programme', start=> $p->{start}, stop => $p->{end}, channel=> "$p->{channel}->{xml_id}");
	    $writer->dataElement('title', $title);
	    $writer->dataElement('sub-title', $prog->{subtitle}) if ( defined($prog->{subtitle}) );
	    $writer->dataElement('desc', $prog->{desc}) if ( defined($prog->{desc}) );
		
	    if ( defined($prog->{director}) || defined($prog->{actors}) ) {
		$writer->startTag('credits');
		$writer->dataElement('director', $prog->{director}) if ( defined($prog->{director}) );
		if ( defined($prog->{actors}) ) {
		    foreach my $actor (@{$prog->{actors}}) {
			$writer->dataElement('actor', $actor);
		    }
		}
		$writer->endTag('credits');
	    }
	    $writer->dataElement('date', $prog->{year}) if ( defined($prog->{year}) );
	    
	    if ( defined($prog->{category}) ) {
		foreach my $cat(@{$prog->{category}}) {
		    $writer->dataElement('category', $cat);
		}
	    }
	    # hunt for things in the "qualifiers bucket" where alot of things fall.
	    if ( defined($prog->{qualifiers}) ) {
		if ( defined($prog->{qualifiers}->{PaidProgram}) ) {
		    $writer->dataElement('category', "PaidProgram");
		}
		if ( defined($prog->{qualifiers}->{Language}) ) {
		    if ( defined($prog->{qualifiers}->{Dubbed}) ) {
			$writer->dataElement('orig-language', $prog->{qualifiers}->{Language});
		    }
		    else {
			$writer->dataElement('language', $prog->{qualifiers}->{Language});
		    }
		}
		
		if ( defined($prog->{qualifiers}->{PremiereShowing}) ) {
		    $writer->dataElement('premiere',$prog->{qualifiers}->{PremiereShowing});
		}
		if ( defined($prog->{qualifiers}->{LastShowing}) ) {
		    $writer->dataElement('last-chance',$prog->{qualifiers}->{LastShowing});
		}

		if ( defined($prog->{qualifiers}->{Subtitles}) ) {
		    $writer->dataElement('subtitles', '', 'type' => "onscreen");
		}
		elsif ( defined($prog->{qualifiers}->{ClosedCaptioned}) ) {
		    $writer->dataElement('subtitles', '', 'type' => "teletext");
		}
		
		if ( defined($prog->{qualifiers}->{Taped}) ) {
		    # nowhere to put this
		}
		if ( defined($prog->{qualifiers}->{InProgress}) ) {
		    # nowhere to put this
		}
		if ( defined($prog->{qualifiers}->{PartInfo}) ) {
		    # nowhere to put this
		    # comes in the form of "Part 1 of 2"
		}
		if ( defined($prog->{qualifiers}->{Live}) ) {
		    # nowhere to put this
		}
		if ( defined($prog->{qualifiers}->{Animated}) ) {
		    # nowhere to put this 
		}
		if ( defined($prog->{qualifiers}->{HDTV}) ) {
		    # nowhere to put this 
		}
		if ( defined($prog->{qualifiers}->{InStereo}) ) {
		    $writer->startTag('audio');
		    $writer->dataElement('stereo', '');
		    $writer->endTag('audio');
		}
		if ( defined($prog->{qualifiers}->{BlackAndWhite}) ) {
		    $writer->startTag('video');
		    $writer->dataElement('colour', 'no');
		    $writer->endTag('video');
		}
	    }
	    if ( defined($prog->{ratings_VCHIP}) ) {
		if ( defined($prog->{ratings_VCHIP_Expanded}) ) {
		    $writer->dataElement('rating', "$prog->{ratings_VCHIP} $prog->{ratings_VCHIP_Expanded}", system =>'VCHIP');
		}
		else {
		    $writer->dataElement('rating', "$prog->{ratings_VCHIP}", 'system' =>'VCHIP');
		}
	    }
	    $writer->dataElement('rating', "$prog->{ratings_MPAA}", 'system' =>'MPAA') if ( defined($prog->{ratings_MPAA}) );

	    if ( defined($prog->{ratings_Warnings}) ) {
		my %hash;
		foreach my $k ( sort @{$prog->{ratings_Warnings}}) {
		    $hash{$k}=1;
		}
		foreach my $k ( keys %hash ) {
		    $writer->dataElement('rating', "$k", 'system' =>'General Warning');
		}
	    }
	    if ( defined($prog->{stars_rating}) ) {
		# nowhere to put this yet.
		# comes in the form of a rating out fraction out of 4
	    }
	    $writer->endTag('programme');
	}
    }
    $writer->endTag('tv');
    $writer->end();
    $output->close();
}




