#!/usr/bin/perl -w
# 
# getlistings_pa
# 
# Get UK TV listings from the Press Association's website, and output
# them in the format described by xmltv.dtd.
# 
# Like all programs which parse websites, this is likely to break if
# the Press Assocation change their site layout.  The current layout
# is fairly clean and fairly easy to parse; the approach taken is to
# read it like a human would, looking at the appearance of bits of
# text (bold, italic) to decide what they represent.
# 
# BUGS
# 
# One problem with British TV listings is the way that news reports
# and other short items are added to the end of longer programmes,
# without being given their own time.  For example you might have
# 'Urban Gothic; 5 News Update' in a single time slot.  In this case
# we discard the short item and print a warning to standard error.
# But this scheme breaks down when the second item is the main
# attraction, for example 'Children's BBC; Fixi and Foxi' where
# 'Children's BBC' is just a two-minute introduction.
# 
# A proper answer to this would probably involve extending the
# listings format so you have times which are 'just before' or 'just
# after' a certain time, for example 5 News Update would begin at
# 'just before' 21:00 and end at 21:00.
# 
# Not all the information in the website is extracted, for example we
# ignore the subtitles flag, aka '888'.
# 
# USAGE: run it and capture stdout.  Warnings about 'ignoring
# programme X tacked onto Y' are caused by the problem described
# above.  Any more serious warning or error is probably due to the PA
# changing their website - see if there is an updated version of this
# program.
# 
# We keep a local cache of the web pages in lots of hidden files,
# which expire after 24 hours.  Hope you don't mind too much.
# 
# -- Ed Avis, epa98@doc.ic.ac.uk, 2000-06-30
# 

use strict;
use HTML::TokeParser;
use Date::Manip;
use LWP::Simple;
use Term::ReadKey;
use XML::Writer;
use Text::Wrap;


########
# Configuration

# Normal use
# Day 8 is the same as day 1, etc.  So num. days should be < 8.
# 
my @CHANNELS = qw[bbc1 bbc2 carlton ch4 ch5];
my $NUMDAYS = 7;

# Quicker version for testing
#my @CHANNELS = qw[bbc1];
#my $NUMDAYS = 1;

# What language the pages are in.  This has no real effect :-)
my $LANG = 'en';

########
# End of configuration


my $writer = new XML::Writer(DATA_MODE   => 1,
			     DATA_INDENT => 2 );
$writer->xmlDecl();
{ local $^W = 0; $writer->doctype('tv', undef, 'xmltv.dtd') }
$writer->startTag('tv');

# Get a big list of programmes for all channels
my @thelot;
foreach my $channel (@CHANNELS) {
    my @programmes;
    my $pages = pages_for_channel($channel);
    foreach (@$pages) {
	push @programmes, @{programmes_from_html($_)};
    }

    foreach (@programmes) {
 	$_->{channel} = $channel;
    }

    # Each programme ends when the next one begins
    foreach my $i (0 .. $#programmes-1) {
 	$programmes[$i]->{end} = $programmes[$i+1]->{date};
    }

    push @thelot, @programmes;
}

# Should really use merge sort here, but there isn't a CPAN module for
# it :-(
# 
print STDERR "sorting\n";
@thelot = sort programme_cmp @thelot;

write_programme($writer, $_) foreach @thelot;
$writer->endTag('tv');
$writer->end();
exit();


# programme_cmp()
# 
# Order two programmes by start time, or end time, or channel.
# 
sub programme_cmp() {
    (Date_Cmp($a->{date}, $b->{date}))
      ||
    (Date_Cmp($a->{end}, $b->{end}))
      ||
    ($a->{channel} cmp $b->{channel})
      || # Useful for catching duplicates
    die 'programmes ' . d($a) . ' and ' . d($b) . ' do not sort';
}


# pages_for_channel()
# 
# Parameters:
#   Name of a channel (bbc1, bbc2, carlton, ch4, ch5)
# 
# Returns: 
#   Ref to list of HTML pages for that channel's listings, from
#   the Press Association site 
# 
sub pages_for_channel($) {
    die 'usage: html_for_channel(channel name)' if @_ != 1;
    my $ch = shift;
    my @r;

    my $BASE = 'http://www.ananova.com/tv/listings/carlton';
    foreach my $day (1 .. $NUMDAYS) {
	print STDERR "channel $ch, day $day\n";
	my $url = "$BASE/day$day/$ch.html";
	my $page = get_cache($url);
	die "cannot get $url" if not defined $page;
	push @r, $page;
    }

    return \@r;
}


# get_cache()
# 
# Wrapper for LWP::Simple that keeps a local cache.
# 
# Usage: get_cache(url)
# 
sub get_cache($) {
    die 'usage: get_cache(url)' if @_ != 1;
    my $url = shift;
    my $cache;
    my $MAX_AGE = 1; # max age in days of cache files

    ($cache = ".$url") =~ s/([^a-zA-Z_0-9.])/'-' . ord($1) . '-'/eg;

    local *F;
    if (-e $cache and -M $cache < $MAX_AGE) {
	open(F, $cache) or die "cannot open $cache: $!";
	local $/ = undef;
	my $cont = <F>;
	close F;
	return $cont;
    }
    else {
	my $cont = get($url);
	die "cannot get URL $url" if not defined $cont;
	open(F, ">$cache")
	  or die "cannot open $cache for writing: $!";
	print F $cont or die "cannot write to $cache: $!";
	close F;
	return $cont;
    }
}


# programmes_from_html()
# 
# Top level function.  Turn HTML into a list of programmes with date,
# title, and description. 
# 
# Parameters:
#   HTML string
# 
# Returns:
#   Ref to list of programmes
# 
sub programmes_from_html($) {
    die 'usage: programmes_from_html(html string)' if @_ != 1;
    my $html = shift;

    # Turn the HTML into a list of bold/italic/plain bits of text
    my $bits = boldit($html);

    # Split this into programmes - each programme starts with a time.
    # Also split at 'Ananova' to separate out the trailing cruft.
    # 
    my $progs = splitlist(sub { istime($_[0]->{TEXT})
				  or $_[0]->{TEXT} =~ /Ananova/ },
			  $bits );
    
    # Remove the cruft, leaving just the programmes.
    my @progs = grep { @$_ and $_->[0]->{TEXT} !~ /Ananova/ } @$progs;
    
    # Turn each list of bits of text into a proper set of programme
    # details.
    # 
    my @r;
    foreach (@progs) {
	my $e = extract_prog($_);
	push @r, $e if defined $e;
    }
    
    # Convert the 12 hour times into proper date-times.
    date_programmes(\@r, get_date_from_page($html));

    return \@r;
}


# date_programmes()
# 
# Given a list of programme details (from extract_prog()) and the date
# of this listing, remove the silly 12 hour times and add proper time
# and date for each programme.
# 
# Parameters:
#   reference to list of programme details
#   date (in Date::Manip format)
# 
# Modifies the list passed in, so that each programme no longer has
# {'time'} but has {'date'} instead.
# 
sub date_programmes($$) {
    die 'usage: date_programmes(ref to list of programmes, date)'
      if @_ != 2;
    my ($progs, $date) = @_;

    my $prev_date;
    my $base_day = $date;
    my $day_later = ParseDateDelta('+1 day') or die;
  
    foreach (@$progs) {
	my $t = timecvt($_->{'time'});
	
	# Calculate the time and day of the programme
	my $time_delta = ParseDateDelta("$t:00") or die;
	my $err;
	my $prog_date = DateCalc($base_day, $time_delta, \$err);
	die "error from DateCalc(): $err" if defined $err;
	
	if (defined $prev_date
	    and (Date_Cmp($prev_date, $prog_date) > 0))
        {
	    # Seem to have jumped backwards in time.  Must be the next
	    # day.
	    # 
	    my $err;
	    $base_day = DateCalc($base_day, $day_later, \$err);
	    die "error from DateCalc(): $err" if defined $err;
	    $prog_date = DateCalc($base_day, $time_delta, \$err);
	    die "error from DateCalc(): $err" if defined $err;
	}
    
	delete $_->{'time'};
	$_->{'date'} = $prog_date;
	$prev_date = $prog_date;
    }
}

    
# extract_prog
# 
# Given a programme as a ref to a list of bits of text, each with
# 'bold' and 'italic' flags, return [time, title, description].
# 
# NB the bits of text passed in must be _one_ programme.
# 
sub extract_prog($) {
    die 'usage: extract_prog(list of bits of text)' if @_ != 1;
    my $prog = shift;

    my ($time, $title, $sub_title, $desc, $director);
    foreach (@$prog) {
	my ($b, $i, $t) = @$_{'bold', 'italic', 'TEXT'};
	$t =~ s/^\s+//; $t =~ s/\s+$//; next if $t eq '';

	if ($b and not $i and istime($t)) {
	    die "time already set to $time but $t found"
	      if defined $time;
	    $time = $t;
	}
	elsif ($b and not $i and $t =~ /^\(.+\)$/) {
	    # (888) or similar, ignore
	}
	elsif ($b and not $i) {
	    $t =~ s!/! / !g;
	    if (not defined $title) {
		$title = $t;
	    }
	    else {
		# A small programme tacked onto the end of another,
		# for example Weather tacked onto the end of News.
		# Just ignore it for now - we do need a way to
		# represent such programmes though.
		# 
		warn "ignoring programme $t tacked onto $title";
	    }
	}
	elsif ($i and not $b) {
	    warn "italic text $t found, but no title yet - ignoring", next
	      if not defined $title;

	    $t =~ s!/! / !g;
	    if ($t =~ /^Generic[\s.]/) {
		# Ignore.
	    }
	    elsif ($t =~ /^Director: (.+)\.$/) {
		die "italic text $t found, but director already defined"
		  if defined $director;
		$director = $t;
	    }
	    else {
		# Must be sub-title.
		die "italic text $t found, but sub-title already defined"
		  if defined $sub_title;
		$sub_title = $t;
	    }
	}
	elsif (not $b and not $i) {
	    next if $t eq 'VIDEO REPORTS'; # ugh
	    if (not defined $desc) { $desc = $t }
	    else                   { $desc .= "; $t" }
	}
	else { die }
    }

    if (not defined $time) {
	if (defined $title) {
	    warn "discarding programme $title since no time found";
	    return undef;
	}
	else {
	    warn "found strange junk, discarding";
	}
    }
    $title = '(unknown title)' if not defined $title;
	
    if (defined $desc) {
	# Clean up some of the mess from the HTML
	$desc =~ s/\xa3((?:\d|,)*)/($1 ne '') ? "$1 pounds" : ''/ge;
	$desc =~ s/&nbsp;/ /g;
	$desc =~ s/&amp;/ & /g;
    }

    return { time => $time, title => $title,
	     sub_title => $sub_title, desc => $desc };
}


# boldit()
# 
# Convert HTML to a list of bits of text.  Each bit has 'bold' and
# 'italic' flags.  Bits which are inside <a> tags are ignored.
# 
# Parameters: string of HTML
# 
# Returns: ref to list of chunks, where each chunk looks like:
#   { 'bold' => x, 'italic' => x, 'TEXT' => text }
# 
sub boldit($) {
    die 'usage: boldit(html string)' if @_ != 1;
    my $html = shift;
    
    use HTML::TokeParser;
    my $p = new HTML::TokeParser(\$html) or die;
    my @r = ();

    my ($bold, $it) = (0, 0);
    while (my $t = $p->get_token()) {
	if    ($t->[0] eq 'S' and $t->[1] eq 'b') { $bold = 1 }
	elsif ($t->[0] eq 'S' and $t->[1] eq 'i') { $it   = 1 }
	elsif ($t->[0] eq 'S' and $t->[1] eq 'a') { $a    = 1 }
	elsif ($t->[0] eq 'E' and $t->[1] eq 'b') { $bold = 0 }
	elsif ($t->[0] eq 'E' and $t->[1] eq 'i') { $it   = 0 }
	elsif ($t->[0] eq 'E' and $t->[1] eq 'a') { $a    = 0 }
	elsif ($t->[0] eq 'T' and not $a) {
	    $t->[1] =~ s/^\s+//; $t->[1] =~ s/\s+$//;
	    next if $t->[1] eq '';
	    push @r, { bold => $bold, italic => $it,
		       TEXT => $t->[1] };
	}
    }

    return \@r;
}


# splitlist()
# 
# Split a list at particular elements.
# 
# Parameters:
#   subroutine that given an element, returns true or false
#   ref to list
# 
# Returns:
#   ref to list of refs to sublists
# 
# The first sublist starts at the first element of the input list, and
# continues up to but not including the first element that gave true;
# the second sublist starts at this point, and so on.
# 
sub splitlist($$) {
    die 'usage: splitlist(sub, ref to list)' if @_ != 2;
    my ($p, $l) = @_;
    my @r = ();

    my @firstlist = ();
    while (@$l and not $p->($l->[0])) {
	push @firstlist, (shift @$l);
    }
    push @r, \@firstlist;
    
    while (@$l) {
	my @sublist;
	@sublist = ();
	push @sublist, (shift @$l);
	while (@$l and not $p->($l->[0])) {
	    push @sublist, (shift @$l);
	}
	push @r, \@sublist;
    }
    
    return \@r;
}


# istime()
# 
sub istime($) {
    die 'usage: istime(possible time string)' if @_ != 1;
    local $_ = shift;
    return /^(\d\d?)[.:]?(\d\d)(am|pm)$/;
}


# timecvt()
# 
# Convert a 12 hour time to 24 hour.
# 
sub timecvt($) {
    die 'usage: timecvt(12 hour time string)' if @_ != 1;
    local $_ = shift;
    s/\s+//;
    my ($hours, $mins, $ampm) = /^(\d\d?)[.:]?(\d\d)(am|pm)$/
      or die "bad time $_";
    if ($ampm eq 'am') {
	if (1 <= $hours and $hours < 12) {
	    $hours = $hours;      # 5am = 05:00
	}
	elsif ($hours == 12) {
	    $hours = 0;           # 12am = 00:00
	}
	else { die "bad number of hours $hours" }
    }
    elsif ($ampm eq 'pm') {
	if ($hours == 12) {
	    $hours = 12;          # 12pm = 12:00
	}
	elsif (1 <= $hours and $hours < 12) {
	    $hours = 12 + $hours; # 5pm = 17:00
	}
	else { die "bad number of hours $hours" }
    }
    else { die }
    
    return sprintf('%02d:%02d', $hours, $mins);
}


# get_date_from_page()
# 
sub get_date_from_page($) {
    die 'usage: get_date_from_page(html string)' if @_ != 1;
    my $html = shift;

    my $date;
    my $p = HTML::TokeParser->new(\$html) or die;
    while (my $token = $p->get_tag('span')) {
	if ($token->[1]->{class} eq 'story-headline') {
	    my $text = $p->get_trimmed_text("/span");
	    die "date already set to $date, but headline $text found"
	      if defined $date;
	    $date = ParseDate($text)
	      or die "bad date string $text\n";
	}
    }
    return $date;
}


# write_programme()
# 
# Write details for a single programme as XML.
# 
# Parameters:
#   XML::Writer object
#   reference to hash of programme details (a 'programme')
# 
sub write_programme($$) {
    die 'usage: write_programme(XML::Writer, programme)' if @_ != 2;
    my ($w, $p) = @_;
    
    my ($channel, $start, $end, $title, $sub_title, $desc, $director)
      = @$p{qw(channel date end title sub_title desc director)};
    
    if (defined $end) {
	$w->startTag('programme', start   => $start,
		                  stop    => $end,
		                  channel => $channel );
    }
    else {
	$w->startTag('programme', start   => $start,
			          channel => $channel );
    }

    $w->dataElement('title', $title, lang => $LANG);
    $w->dataElement('sub_title', $sub_title, lang => $LANG)
      if defined $sub_title;

    # Write the description.  I'd like to line-wrap this so that the
    # generated XML is pleasant to read.  I have a private version of
    # XML::Writer which supports a dataElement_block() method for
    # nicely formatted output, but for the time being we'll just use
    # the standard version.  One day I will tidy up what I wrote and
    # submit it to the XML::Writer maintainer.
    # 
#    $w->dataElement_block('desc', $desc, lang => $LANG)
#      if defined $desc;
    $w->dataElement('desc', $desc, lang => $LANG)
      if defined $desc;

    if (defined $director) {
	$w->startTag('credits');
	$w->dataElement('director', $director);
	$w->endTag('credits');
    }

    $w->dataElement('language', $LANG);
    $w->endTag('programme');
}
