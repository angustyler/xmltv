#!/usr/bin/perl

# This is an early version of a script to grab TV listings for Canadians
# There is some work required on your part in order to get this to work for you.# First go to http://www.tvguide.ca and set up an account for yourself.
# (don't worry, they don't ask for any personal info besides your postal code,
# and of course you can use fake names)
# After that go set up your preferences(choose what cable service you have,etc)
# that should take you to a grid with some listings on the screen. Click on 
# preferences at the top of the screen.
# now click on layout grid, near the bottom of the screen.
# switch the channels deep to 100.   (You can choose less if you want)
# switch the hours wide to 6. (we want to grab a lot of info off of each page)
# choose expanded titles, and program description. 
#            #I will add more functionality later, but for now just these.
# click on layout Grid.
# now click on Listings.
# This will take a while to load...for me it is about a 400 KB document.
# Now look at the URL, highlight the part after ...profileID= until the end,
# cut and paste that below to the serviceID variable.
# that should be it!  
#
#
# If you have problems with this, or would like to send a patch, I (Mike Redan)
# wrote this script (some copied from Ed). 
# You can reach me at mike@jeke.fdns.net
# 
# Ed: I've changed this script a little from Mike Redan's version, so you
# might want to mail me first at epa98@doc.ic.ac.uk.  I'll forward the
# message to Mike if necessary.

use strict;

use LWP::Simple;
use XML::Writer;
use Time::Local;
use Date::Manip;
use Fcntl;

eval { require Memoize };
if ($@) {
    warn "could not load Memoize module, cannot cache web pages";
}
else {
    # Getting web pages is memoized, but they expire after 24 hours
    Memoize::memoize('get', SCALAR_CACHE => ['TIE', 'Memoize::Expire',
					     LIFETIME => 24 * 60 * 60,
					     TIE => [ 'DB_File',
						      'web_cache.db',
						      O_RDWR | O_CREAT,
						      0666 ] ]);
}

# --------------- The line below is where you paste your long string of crap.
# You must enclose it in quotes like the one that is in there now.
my $ServiceID='%2476%247B%2490%2475%2490%2490&WSN=WSERVER22&UserID=%2476%2476%2489%2471%248C%2488';

# enter your time zone below:
my $time_zone = "EST";
#how many 6 hour listings do you want to download? (default is 4 days worth)
my $how_many = 6;

#shouldn't have to change this:
my $url="http://tvguidelive.clicktv.com/listings.asp?profileID=";

# Prototype declarations
sub get_end_time;
sub add_time();
sub write_programme($$$$$$$);

# What language the pages are in.  This has no real effect :-)
#my $LANG = 'en';
my ($month, $day, $year, $default_hour, $default_minute);
my $id;
my $next_time_slot;
my $raw_listings;

  Date_Init();
my $writer = new XML::Writer(DATA_MODE   => 1,
			     DATA_INDENT => 2 );
$writer->xmlDecl("iso-8859-1");
{ local $^W = 0; $writer->doctype('tv', undef, 'xmltv.dtd') }
$writer->startTag('tv');

#grab the first page worth of info.
  print STDERR "Downloading the first listings";
  $raw_listings = get($url . $ServiceID);
print STDERR "\n";

#grab the day/month/year of the first page downloaded.
  $raw_listings =~ m/&gDate\=(\d+)\w(\d+)\w(\d\d\d\d)/;
  $month = $1;
  $day   = $2;
  $year  = $3;
#proccess the show info,and spit it out to XML  
  print STDERR "Processing the first listings\n";
  get_show_info($raw_listings);
  print STDERR "Finished processing the first listings\n\n";

#grab the "ID" number from the URL
  $ServiceID =~ /profileID=(.*?)&cid=/;
  $id = $1;

#This loop will grab listings for consecutive 6 hour time slots, according to
#the user defined variable $how_many  
  for (my $x = 0; $x < $how_many; $x++) {
#adds 6 hours to $default_hour, so we know what the next web page is we need.
    add_time();
    ($next_time_slot) = split (/&cid=/,$ServiceID);
#create the URL it is that we need to download from.
    $next_time_slot = $next_time_slot . "&WSN=WSERVER21&UserID=$id&gDate=$month\A$day\A$year&gHour=$default_hour&gChRow=1&gChRef=0&Nav=PrevGrid ";
    print STDERR "Downloading listings for $default_hour:00 on $day/$month/year";
    $raw_listings = get($url . $next_time_slot);
    print STDERR "\n";

    print STDERR "Processing listings for $default_hour:00 on $day/$month/$year\n";
    get_show_info($raw_listings);
    print STDERR "Finished processing listings for $default_hour:00 on $day/$month/$year\n\n";
  } 

$writer->endTag('tv');
$writer->end();

sub get_show_info  {
$_ = shift;
my $chan_name;
my $chan_num;
my $i;
my $len_of_show;
my $name_of_show;
my $show_descrip;
my $sub_title;
my @start_time;
my $time_now_hour;
my $time_now_minute;
my $time;
my $end_time;

#grab the first time
    s/(\d+):(\d+).*?([ap])\.m\..*?\n//;
    $default_hour = $1;
    if ($3 eq 'p') {
      $default_hour += 12;
    }
    $default_minute = $2;
    $_ = $';

  while (1) {
    @start_time[3] = $default_hour;
    @start_time[4] = $default_minute; 
    @start_time[0] = $year;
    @start_time[1] = $month;
    @start_time[2] = $day;
#get the channel number:
    s/^.*?color\=\#\d+\>(\d+)&nbsp;(<a href.*?>)?//;
    $chan_num = $1;

#grab the call sign of the channel
#-------this is not used in the output file, so we can just comment it
#-------out for now, it may be useful in the future
#    s/^(.*?)<//;
#    $chan_name = $1;

# This loop will gather all show info on each line.
    while (m/^.*?detail\.asp.*?\n/) {
      $time         = undef;
      $name_of_show = undef;
      $sub_title    = undef;
      $show_descrip = undef;
      s/^.*?colspan\=(\d)//;
#pushing the length of show on
      @start_time[5] = $1; 

      s/^.*?prog_ref.*?>(.*?)<\/a>//;
      $name_of_show = $1;

      $sub_title = $1 if (m/^.?.?<i>(.*?)<\/i/);

      s/^.*?<font.*?>//;
      unless (/^</) {
        s/^(.*?)<//;
        $show_descrip = $1;
      }
      for ($i = 0; $i < 5; $i++) {
        $time = sprintf("%s%.2d", $time, $start_time[$i]);
      }
      $time = $time . " " . $time_zone;
      $show_descrip =~ s/&/and/g;
      $sub_title =~ s/&/and/g;
      $name_of_show =~ s/&/and/g;
      ($end_time, $start_time[3], $start_time[4], $start_time[2], $start_time[1]        , $start_time[0]) = get_end_time (@start_time);
      write_programme($writer,$chan_num,$name_of_show,$show_descrip,$time, $end_time, $sub_title);
    } #end of internal while
    s/(^.*?\n)//;
    if (m/^.*?\/table.*?\n/) {last};
  }
}   

#  get_end_time()
#
#  add the length of the show to current time to get when the show ends.
#
#  Parameters:
#  accept the @start_time array.
#
#  return the a properly formatted endtime (of the shape 199811041400)
#  also return the start time of the next show in hours/minutes
#
sub get_end_time {
my ($end_time, $time, $new_hour, $new_minute);
my ($year, $month, $day, $time_now_hour, $time_now_minute, $len_of_show) = @_;

#figure out the endtime, convert to seconds, add the time, convert back
  $end_time = localtime(Date_SecsSince1970GMT($month,$day,$year,$time_now_hour,
                       $time_now_minute, 0) + ($len_of_show * 30 * 60));

#$end_time now looks a little funny, convert back to standard format
  ($month, $day, $time, $year) = (split ' ', $end_time)[1 .. 4];

 $month = 1 + index('JanFebMarAprMayJunJulAugSepOctNovDec', $month)/3;
#get rid of the : imbedded in the time.
  ($new_hour, $new_minute) = split(/:/, $time);
 
  my $end_time = sprintf '%d%.2d%.2d%.2d%.2d %s' => $year, $month,
            $day, $new_hour, $new_minute, $time_zone;

  return ($end_time, $new_hour, $new_minute, $day, $month, $year);
} #end of sub get_time

# add_time will add 6 hours on to the date stored in the global variables 
# month, day, year and default_hour
#
#
sub add_time () {
my $end_time;
my $time;

  $end_time = localtime(Date_SecsSince1970GMT($month,$day,$year,$default_hour,
                       $default_minute, 0) + (6 * 60 * 60));

  ($month, $day, $time, $year) = (split ' ', $end_time)[1 .. 4];
  ($default_hour, $default_minute) = split(/:/, $time);
  $month = 1 + index('JanFebMarAprMayJunJulAugSepOctNovDec', $month)/3;
}


# write_programme()
# 
# Write details for a single programme as XML.
# 
# Parameters:
#   XML::Writer object
#   Various programme details
# 
sub write_programme($$$$$$$) {
    die 'usage: write_programme(XML::Writer, programme)' if @_ != 7;

    my ($w, $channel, $title, $desc, $start, $end, $sub_title) = @_;
        my ($director);
    # The dates are converted to the appropriate timezone for output.
    if (defined $end) {
	$w->startTag('programme', start   => $start,
			          stop    => $end,
		                  channel => $channel );
    }
    else {
	$w->startTag('programme', start   => $start,
			          channel => $channel );
    }

    $w->dataElement('title', $title); #, lang => $LANG);
    $w->dataElement('sub-title', $sub_title) #, lang => $LANG)
      if defined $sub_title;

#    $w->dataElement_block('desc', $desc) #, lang => $LANG)
#      if defined $desc;
    $w->dataElement('desc', $desc) #, lang => $LANG)
      if defined $desc;

    if (defined $director) {
	$w->startTag('credits');
	$w->dataElement('director', $director);
	$w->endTag('credits');
    }

#    $w->dataElement('language', $LANG);
    $w->endTag('programme');
}
