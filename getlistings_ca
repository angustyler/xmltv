#!/usr/bin/perl -w
#
# This script scrapes www.clicktv.com, while trying to remain
# compatible with www.tvguide.ca which shares the same user
# Profiles, but produces the schedule listings in a slightly
# different format. Update: tvguide.ca have changed their
# format and is problem no longer supported.
#
# Clicktv supports both Canadian and US listings.
#
# ----------------------------------------------------------------------------
# "THE BEER-WARE LICENSE" (Revision 42):
# <jerry@matilda.com> wrote this file.  As long as you retain this notice you
# can do whatever you want with this stuff. If we meet some day, and you think
# this stuff is worth it, you can buy me a beer in return.   
# ----------------------------------------------------------------------------
# always wanted to use this licence, thanks Poul-Henning Kamp.
#
# Feel free to contact me with comments, contributions,
# and the like. jerry@matilda.com
#
# $Log: getlistings_ca,v $
# Revision 1.6  2001/11/11 16:44:19  epaepa
# Whoops, just realized that the last changelog message would itself get
# keyword-expanded, causing no end of confusion.  I had to perform some
# emergency censorship of funny dollar signs.
#
# Revision 1.5  2001/11/11 16:41:05  epaepa
# Rearranged (or added) comments at the start of each file, so the
# description is near the top and the changelog near the bottom.  Added
# Log: lines to get an automatically updated changelog from now on; I
# hope it works.
#
#
# older ChangeLog entries:
# 2001-09-06  Jerry Veldhuis, jerry@matilda.com
#	- started ChangeLog
#	- version updated to V0.3
#	- fixed 'Use of uninitialized value at ./getlistings_ca line 601.'
#	  which occurs when --programs is used on command line
#	- deals with case where --programs is used to specify one output
#	  file for multiple days of program listings.
#	- renamed $writer_g to $Pwriter_g, while adding $Poutput_g.
#	- changed --trackQualifiers and --dumpQualifiers
#	  --trackQualifiers must be used on commandline to enable db, defaults
#	  to off.
#	  --dumpQualifiers now requires a db file to dump.
#	- fixed and prettied up usage (use --help to see)
#	- moved 'use ' directives to top of script to make it more
#	  obvious what required packages are.
#	- identifies case were reading of schedule failed, and
#	  cleans up afterward.
#	- replaced URL we ship with, with one with only 6 channels
#	- now puts 'source-*' and 'generator-*' entries in 'tv' entry
#	  instead of 'source' and 'author'
#
# 2001-09-13  Jerry Veldhuis, jerry@matilda.com
#	- added --serviceURL to command line instead of force script modification
#
# 2001-10-03  Jerry Veldhuis, jerry@matilda.com
#	- reversed logic to see if schedule reading succeeded, would exit with 1 without
#	  any program/channels in output unless you wanted the whole day
#	  (startHour 0 to endHour 24).
#	- moved writeXMLHeader subroutine prior to calls to fix warning from perl saying
#	  it coudn't check routine prototypes.
#
# 2001-10-20  Jerry Veldhuis, jerry@matilda.com
#	- hacked to grab from tvguide.ca instead of clicktv.com
#	- renamed from getlistings_na to _ca
#	- bug - instructions are a mess
#

use strict;
use Fcntl qw(:DEFAULT);
use XML::Writer;
use IO;
use Getopt::Long;
use ClickListings;

my $VersionID="getlistings_ca V0.5";

if ( $ClickListings::ParseTable::VersionID ne "ClickListings V0.2" ) {
    die "$VersionID requires ClickListings V0.2";
}

# Note: I decided not to cache any program listings html pages like
#       other xmltv scripts since I'm reading multiple listings and
#       resolving programs that span listings, so if one is out of date
#       the script may fail.
#
# To use this script you must:
#  1. visit www.clicktv.com and setup a membership. 
#     a) In "Login Settings", its important to:
#        - set your postal code / zip correctly
#        - set your 'Observes Daylight Saving' setting appropriately
#     b) In "Line-up Settings", choose your service.
#     c) In "Line-up Arrangement", choose to channels you
#        want to include in the channel "display" list.
#     d) In "Layout Grid" set
#        - channels deep to "All"
#        - hours wide to "6 hours" (script should work with any setting
#          but this minimizes the # of www page requests)
#        - "tick" the details you wish included in the output.
#          (only tested with all ticked)
#          Note: a future version might include a way to control what
#          details are ignored when writting output.
#
#  2. click on "Listing" button 
#     a) verify the text above the date/time selections near the top
#        of the page reads your location, date/time and timezone
#        is correct.
#     b) copy/paste the URL into $URL below.  (The example URL
#        supplied is mine, but you really should change it.)
#	 An alternative is to use '--serviceURL' on command line.
#

# Warning !!! your URL may change if you update your settings later.
#my $URL = 'http://www.clicktv.com/listings.asp?CID=TVD&profileID=%247B%2477%2490%2479%248C%2487&WSN=WSERVER20&UserID=%2479%2477%2488%247A%2491%2489';
my $URL = 'http://tvlistings.tvguidelive.com/listing/gridlisting.asp?UID={5E9C238D-F399-4DA4-BEB1-52D3C7BA5776}';

#
#     c) If your not interested in the entire days schedule, you
#        can either specify a range on the cmd line (useing -start and -end)
#        or you can modify the '$StartHour' and '$EndHour' values below.
#        see "Output Hours" section for details.

#
# Output Days
# -----------
# Set the number of days of listings to output. ClickTV like most
# sources only support up to 14 days in advance.
#
# The number of days included may be set at run-time via the command line.
#
my $Days=14;

#
# Output Hours
# ------------
# These settings are used to help refine the hours included in output.
# They are really the range of programming your interested in. A schedule
# request only requires a starting hour, and the number of
# hours in the resulting schedule are determined by YOUR preferences 
# setting at the www site. So the 'start' hour is really hour used in that
# first request. The 'end' hour is the hour that must appear (or at least the 
# start of the 'end' hour) in the schedule for the schedule retrieval to
# consider itself finished.
#
# Unless you enable 'include partial listings', the default settings (include
# being off) means the the output will include all programs that start at
# or after the 'start' hour and end prior to or at 'end' hour.
#
# A 24 hour clock is used to define the 'start' and 'end' hours.
# The 'start' hour must be between 0 (== 12am) and 23 (11pm), and
# 'end' hour may be any value greater than 'start' hour and < 30. 'End' hours
# greater than 24 allow you to ensure programs that start at 12pm, or even
# 1am (that same night) are included in the output.
#
# Other filtering techniques should be used to more finely tune theN
# output as needed.
#
# Warning: using a 'start' value <6 and a 'end' value that is > 24 may
# result in programs appearing more than once if running for more than one
# day.
#
# Warning: endhour > 24 is only useful when you grabbing one day
#
# 'start' and 'end' hours may be set at run-time via the command line.
#
my $StartHour=0;
my $EndHour=24;

#
# Partial Programs
# ----------------
# If you want programs that end after, but start prior to the 'start'
# (defined above) and programs that start prior but don't end until after
# 'end' hour (defined above) set '$IncludePartialPrograms' to non-zero.
# Since xmltv format doesn't support partial program listings (or at least
# programs that don't have a start time), the program title is prepended
# with "(<- cont)" or appended with "(cont ->)" as appropriate.
#
# Using this feature isn't recommended since this violates the xmltv
# specificatoin and results in programs with modified titles, and unreliable
# start and end dates.
#
my $IncludePartialPrograms=0;

# Program Details
# ------------------
# ClickTV only categorizes programs in the schedule grid by colour
# coding the entires into 5 categories. Currently: Movies, Sports, Kids Show,
# Music, Specials and Sci-Fi. The fact that these didn't seem useful to
# me and the html decode would have been hell, I decided to instead add
# an option to get the details for every program containing a url link.
# The detail page includes a much more diverse group of categories
# and subcategories.
#
# WARNING: an extra html page for each program can be VERY expensive
# both in time and bandwidth. Before permanently enabling, run once
# with and once without to determine if its right for you.
#
# Since the extra page is so expensive, an option of creating a details
# cache helps by caching a minimal version of the details (post parsing)
# keyed on the program title. Using the cache based on the program title
# gets you what you asked for, fast and possibly wrong answers, since there
# are certainly cases where the program title is the same for two completly
# different programs. If you want the right answers pay the price and disable
# the cache.
# 
# to disable the cache, set ExpandedDetailsCacheName to undef or an empty
# string.
my $ExpandedDetails=0;
my $ExpandedDetailsCacheName="progDetails.db";

# Output Format(s)
# ----------------
# Currently the only support output format XMLTV.
# Future version may include html, or csv files...
#
# By default, a file channels.xml is written which contains data about
# the channels found, in XMLTV's channels.dtd format.
#
my $Format="xmltv";
my $programsFile="";
my $channelsFile="channels.xml";

#
# Unidentified Program Detail/Qualifiers
# --------------------------------------
# program details and qualifiers can optionally be stored to a
# "unidentified qualifiers" database so you don't see the same
# parse warning for these more than once.
# use --trackQualifiers db
#
# If you want, you can use --dumpQualifiers and submit these for
# possible additions the list of qualifiers that are understood.
#

sub Usage
{
    print STDERR "usage: $0 [options]\n";
    print STDERR "where options is:\n";
    print STDERR "   --programs <file>\n";
    print STDERR "       specify programs.xml file in xml format\n";
    print STDERR "       <file> may contain Date::Manip::Unix substitutions\n";
    print STDERR "       for instance, use --programs \"prog-%d%m%Y.xml\" to separate output by day.\n";
    print STDERR "       if no --programs is specified stdout is used\n";
    print STDERR "\n";
    print STDERR "   --channels <file>\n";
    print STDERR "       specify channels.xml <file>\n";
    print STDERR "       <file> follows the similar rules to -programs (not sure why)\n";
    print STDERR "       default is 'channels.xml', empty string means don't write channels file  \n";
    print STDERR "\n";
    print STDERR "   --startHour x\n";
    print STDERR "       specify starting hour (24 hour clock, default $StartHour)\n";
    print STDERR "\n";
    print STDERR "   --endHour y\n";
    print STDERR "       specify ending hour (can be >24 for next day, default $EndHour)\n";
    print STDERR "\n";
    print STDERR "   --days n\n";
    print STDERR "       specify number of days to include in output (default $Days)\n";
    print STDERR "\n";
    print STDERR "   --serviceURL url\n";
    print STDERR "       specify serviceURL url (replaces script default)\n";
    print STDERR "\n";
    print STDERR "   --trackQualifiers <path2db>\n";
    print STDERR "       specify the DB_File database to store unidentified program\n";
    print STDERR "       qualifiers in\n";
    print STDERR "\n";
    print STDERR "   --dumpQualifiers db\n";
    print STDERR "       dump unidentified qualifiers database 'db'\n";
}

use vars qw/ $opt_programs $opt_channels $opt_startHour $opt_endHour $opt_days $opt_serviceURL $opt_trackQualifiers $opt_dumpQualifiers/;

if ( ! GetOptions('programs=s', 'channels=s', 'startHour=i', 'endHour=i', 'days=i', 'serviceURL=s',
		   'trackQualifiers=s', 'dumpQualifiers=s') ) {
    Usage();
    exit(1);
}

$opt_programs=$programsFile if ( !defined($opt_programs) );
$opt_channels=$channelsFile if ( !defined($opt_channels) );
$opt_startHour=$StartHour if ( !defined($opt_startHour) );
$opt_endHour=$EndHour if ( !defined($opt_endHour) );
$opt_days=$Days if ( !defined($opt_days) );
$opt_serviceURL=$URL if ( !defined($opt_serviceURL) );

my $ServiceID;
if ( $opt_serviceURL =~ /[?&](UID=[^&]+)/ ) {
    $ServiceID = $1;
}
else {
    die "cannot find UID in Service ID URL $opt_serviceURL";
}

if ( defined($opt_dumpQualifiers) ) {
    use DB_File;

    if ( !defined($opt_trackQualifiers) ) {
	die "you need to specify --trackQualifiers on the command line";
    }

    my %hash;
    tie (%hash, "DB_File", $opt_dumpQualifiers, O_RDWR, 0444) || die "$opt_dumpQualifiers: $!";
    
    print STDERR "List of identified qualifiers that are not understood:\n";
    foreach my $key (keys %hash) {
	print STDERR "\t$key\n";
    }
    untie %hash;
    exit(0);
}

if ( $opt_startHour < 0 || $opt_startHour > 23 ) {
    print STDERR "specified startHour must be between 0 and 23\n";
    Usage();
    exit(1);
}
if ( $opt_endHour < 1 || $opt_endHour > 30 ) {
    print STDERR "specified endHour must be between 1 and 30\n";
    Usage();
    exit(1);
}
if ( $opt_endHour < $opt_startHour ) {
    print STDERR "specified endHour must be greater than startHour\n";
    Usage();
    exit(1);
}

if ( $opt_days < 0 || $opt_days > 14 ) {
    print STDERR "specified days must be between 1 and 14\n";
    Usage();
    exit(1);
}

STDOUT->autoflush(1);

# specify source host site for getting listings.
# I originally intended to support www.tvguide.ca as well, but
# as of late, they've changed their format. (again).
# They use to just proxy the tables from clicktv, but no longer.
my $SourceHost="tvlistings.tvguidelive.com";

my ($y,$m,$d,$h,$mn,$s)=&Date::Manip::Date_Split(&Date::Manip::ParseDateString("now"));
my $startNDay=&Date::Manip::Date_DayOfYear($m,$d,$y);

if ( 0 ) {
    # used for testing... 
    ($y,$m,$d,$h,$mn,$s)=&Date::Manip::Date_Split(&Date::Manip::ParseDateString("June 17, 2001"));
    $startNDay=&Date::Manip::Date_DayOfYear($m,$d,$y);
    #$startDate=&Date::Manip::Date_SecsSince1970($m,$d,$y,0,0,1);
}

# hash for unidentified program qualifiers
# used to reduce otherwise repeated warnings
my %undefQualifiers;

# track qualifiers to db file if specified.
# if database exists, it is used to remove repeated warnings
# across invokations of getlistings_ca.
if ( defined($opt_trackQualifiers) ) { 
    use DB_File;
    tie (%undefQualifiers, "DB_File", $opt_trackQualifiers, O_RDWR|O_CREAT) || die "$opt_trackQualifiers: $!";
}

# initalize global XML::Writer if we're writting programs to stdout
# or if all programs are to being output'd to a single file.
# The later allows us to use --programs tv.xml with more than one
# days listings.
my $Pwriter_g;

# Poutput_g is only used if we are writting all Programs to the same file.
my $Poutput_g;

my @FilesWeOpened_g;

sub writeXMLHeader($)
{
    my $writer=shift;

    $writer->xmlDecl("ISO-8859-1", "1.0");
    $writer->doctype('tv', undef, 'xmltv.dtd');
    $writer->startTag('tv',
		      date                  =>&Date::Manip::UnixDate("now","%T on %b %e, %Y"),
		      'source-info-url'     =>"http://$SourceHost",
		      'source-info-name'    =>"ClickTV",
		      #'source-data-url'     =>"http://$SourceHost/listings.asp?$ServiceID",
		      'source-data-url'     =>"http://$SourceHost/listing/gridlisting.asp?$ServiceID",
		      'generator-info-name' =>"$VersionID",
		      'generator-info-url'  =>'http://www.doc.ic.ac.uk/~epa98/work/apps/xmltv/');
}

if ( !length($opt_programs) ) {
    print STDERR "writing Programs to stdout\n";
    $Pwriter_g = new XML::Writer(DATA_MODE => 1, DATA_INDENT => 2 );
    writeXMLHeader($Pwriter_g);
}
elsif ( &Date::Manip::UnixDate("now","$opt_programs") eq $opt_programs ) {
    print STDERR "writing Programs to $opt_programs\n";
    $Poutput_g = new IO::File("> $opt_programs") || die "$opt_programs: $!";
    push(@FilesWeOpened_g, $opt_programs);
    $Pwriter_g = new XML::Writer(OUTPUT=>$Poutput_g,
				 DATA_MODE => 1, DATA_INDENT => 2 );
    writeXMLHeader($Pwriter_g);
}

my $failed=0;

# special case if you want all the listings for multiple days
# if so, we grab and resolve "spanning" programs in the listings by
# requesting multiple days in one call
if ( $opt_startHour == 0 && $opt_endHour == 24 ) {
    my $lg=new ClickListings('ServiceID' => $ServiceID,
			     'URLBase' => "http://$SourceHost/listing/gridlisting.asp",
			     'DetailURLBase' => "http://$SourceHost/detail.asp",
			     'undefQualifiers' => \%undefQualifiers);

    # build an array of the dates we should collect
    my @dates;
    for (my $nday=0; $nday<$opt_days ; $nday++) {
	push(@dates, [$opt_startHour, $opt_endHour, $startNDay+$nday, $y]);
    }
    if ( $lg->readSchedule(@dates) == 0 ) {
	$failed++;
    }
    else {
	$lg->expandDetails($ExpandedDetailsCacheName) if ( $ExpandedDetails );

	# set time zone for date conversions
      Date::Manip::Date_SetConfigVariable('TZ', $lg->{TimeZone});
      Date::Manip::Date_Init();
	
	updateChannelIds($lg);
	writeOutChannels($lg);
	writeOutPrograms($lg);
    }
}

# otherwise we'll don't need to resolve programs that span days, so
# we instead loop over the days, and produce output for each
else {
    # build an array of the dates we should collect
    for (my $nday=0; $nday<$opt_days ; $nday++) {
	my $lg=new ClickListings('ServiceID' => $ServiceID,
				 'URLBase' => "http://$SourceHost/listing/gridlisting.asp",
				 'DetailURLBase' => "http://$SourceHost/detail.asp",
				 'undefQualifiers' => \%undefQualifiers);
	
	if ( $lg->readSchedule([$opt_startHour, $opt_endHour, $startNDay+$nday, $y]) == 0 ) {
	    $failed++;
	}
	else {
	    $lg->expandDetails($ExpandedDetailsCacheName) if ( $ExpandedDetails );

	    # set time zone for date conversions
	  Date::Manip::Date_SetConfigVariable('TZ', $lg->{TimeZone});
	  Date::Manip::Date_Init();
	    
	    updateChannelIds($lg);
	    writeOutChannels($lg);
	    writeOutPrograms($lg);
	}
    }
}

#
# untie db file if needed
if ( defined($opt_trackQualifiers) ) { 
    untie(%undefQualifiers);
}

if ( defined($Pwriter_g) ) {
    $Pwriter_g->endTag('tv');
    $Pwriter_g->end();
    $Poutput_g->close() if ( defined($Poutput_g) );
}

if ( $failed != 0 ) {
    #print STDERR "cleaning up..\n";
    if ( @FilesWeOpened_g ) {
	for my $file (@FilesWeOpened_g) {
	    if ( -f $file ) {
		#print STDERR "   removing $file\n";
		unlink($file);
	    }
	}
    }
    exit(1);
}
exit(0);

sub updateChannelIds
{
    my ($lg)=@_;

    my @Channels=$lg->getChannelList();
    for (my $chindex=0 ; $chindex< scalar(@Channels) ; $chindex++) {
	my $channel=$Channels[$chindex];
	if ( defined($channel->{localStation}) ) {
	    $channel->{xml_id}="$channel->{number} $channel->{localStation}";
	}
	else {
	    $channel->{xml_id}=$channel->{number};
	}
    }
}

# write the channels in xml format
sub writeOutChannels
{
    my ($lg)=@_;

    my $filename=&Date::Manip::UnixDate($lg->getProgramStartTime(),"$opt_channels");

    if ( $filename eq "" ) {
	return;
    }

    print STDERR "writing Channels to $filename\n";
    my $output = new IO::File("> $filename") || die "$filename: $!";
    push(@FilesWeOpened_g, $filename);

    my $writer = new XML::Writer(OUTPUT=>$output, DATA_MODE => 1, DATA_INDENT => 2 );
    $writer->xmlDecl("ISO-8859-1", "1.0");
    $writer->doctype('channels', undef, 'channels.dtd');

    if ( 1 ) {
	$writer->startTag('channels');
    }
    else {
	# I've request this change the channels.xml, we'll wait for a decision
	# before nenabling it :)
	$writer->startTag('channels',
			  date=>&Date::Manip::UnixDate("now","%T on %b %e, %Y"),
			  source=>"$SourceHost",
			  author=>"$VersionID");
    }
    my @Channels=$lg->getChannelList();
    for (my $chindex=0 ; $chindex< scalar(@Channels) ; $chindex++) {
	my $channel=$Channels[$chindex];
	$writer->startTag('channel', id=> $channel->{xml_id});

	if ( defined($channel->{affiliate}) ) {
	    $writer->dataElement('display-name', "Channel $channel->{xml_id} ($channel->{affiliate})");
	}
	else {
	    $writer->dataElement('display-name', "Channel $channel->{xml_id}");
	}
	# not supported as of yet
	#$writer->dataElement('url', $channel->{url}) if ( defined($channel->{url}) );
	$writer->endTag('channel');
    }
    $writer->endTag('channels');
    $writer->end();
    $output->close();
}

sub writeOutPrograms
{
    my ($lg)=@_;

    my $output;
    my $writer;

    if ( defined($Pwriter_g) ) {
	$writer=$Pwriter_g;
    }
    else {
	my $filename=&Date::Manip::UnixDate($lg->getProgramStartTime(),"$opt_programs");
	if ( $opt_programs eq $filename ) {
	    die "This case should have been caught before here";
	}

	print STDERR "writing Programs to $filename\n";
	$output = new IO::File("> $filename") || die "$filename: $!";
	push(@FilesWeOpened_g, $filename);
	$writer = new XML::Writer(OUTPUT=>$output, DATA_MODE => 1, DATA_INDENT => 2 );

	writeXMLHeader($writer);
    }

    my @Channels=$lg->getChannelList();
    for (my $chindex=0 ; $chindex< scalar(@Channels) ; $chindex++) {
	my @progs=$lg->getProgramsOnChannel($chindex);
	
	foreach my $p (@progs) {
	    my $prog=$p->{program};
	    my $title=$prog->{title};
	    
	    #print STDERR "storing $title..\n";

	    if ( defined($p->{contFromPreviousListing}) ) {
		if ( !$IncludePartialPrograms ) {
		    #print STDERR "warning: not including program $prog->{title} which starts previous to listing\n";
		    next;
		}
		$title="(<-cont) $title";
	    }
	    if ( defined($p->{contToNextListing}) ) {
		if ( !$IncludePartialPrograms ) {
		    #print STDERR "warning: not including program $prog->{title} which ends past listing boundaries\n";
		    next;
		}
		$title="$title (cont->)";
	    }
	    
	    $writer->startTag('programme', start=> $p->{start}, stop => $p->{end}, channel=> "$p->{channel}->{xml_id}");
	    $writer->dataElement('title', $title);
	    $writer->dataElement('sub-title', $prog->{subtitle}) if ( defined($prog->{subtitle}) );
	    $writer->dataElement('desc', $prog->{desc}) if ( defined($prog->{desc}) );
		
	    if ( defined($prog->{director}) || defined($prog->{actors}) ) {
		$writer->startTag('credits');
		$writer->dataElement('director', $prog->{director}) if ( defined($prog->{director}) );
		if ( defined($prog->{actors}) ) {
		    foreach my $actor (@{$prog->{actors}}) {
			$writer->dataElement('actor', $actor);
		    }
		}
		$writer->endTag('credits');
	    }
	    $writer->dataElement('date', $prog->{year}) if ( defined($prog->{year}) );
	    
	    if ( defined($prog->{category}) ) {
		foreach my $cat(@{$prog->{category}}) {
		    $writer->dataElement('category', $cat);
		}
	    }
	    # hunt for things in the "qualifiers bucket" where alot of things fall.
	    if ( defined($prog->{qualifiers}) ) {
		if ( defined($prog->{qualifiers}->{PaidProgram}) ) {
		    # FIXME I don't that payment counts as a
		    # 'category'.  Though there should probably be
		    # some way to include it.  -- epa98@doc.ic.ac.uk
		    # 
		    $writer->dataElement('category', "advertisement");
		}
		if ( defined($prog->{qualifiers}->{Language}) ) {
		    if ( defined($prog->{qualifiers}->{Dubbed}) ) {
			$writer->dataElement('orig-language', $prog->{qualifiers}->{Language});
		    }
		    else {
			$writer->dataElement('language', $prog->{qualifiers}->{Language});
		    }
		}
		
		if ( defined($prog->{qualifiers}->{Taped}) ) {
		    # nowhere to put this
		}
		if ( defined($prog->{qualifiers}->{InProgress}) ) {
		    # nowhere to put this
		}
		if ( defined($prog->{qualifiers}->{PartInfo}) ) {
		    # nowhere to put this
		    # comes in the form of "Part 1 of 2"
		}
		if ( defined($prog->{qualifiers}->{Live}) ) {
		    # nowhere to put this
		}
		if ( defined($prog->{qualifiers}->{Animated}) ) {
		    # nowhere to put this 
		}
		if ( defined($prog->{qualifiers}->{HDTV}) ) {
		    # nowhere to put this 
		}
		if ( defined($prog->{qualifiers}->{BlackAndWhite}) ) {
		    $writer->startTag('video');
		    $writer->dataElement('colour', 'no');
		    $writer->endTag('video');
		}
		if ( defined($prog->{qualifiers}->{InStereo}) ) {
		    $writer->startTag('audio');
		    $writer->dataElement('stereo', '');
		    $writer->endTag('audio');
		}
		if ( defined($prog->{qualifiers}->{PremiereShowing}) ) {
		    $writer->dataElement('premiere',$prog->{qualifiers}->{PremiereShowing});
		}
		if ( defined($prog->{qualifiers}->{LastShowing}) ) {
		    $writer->dataElement('last-chance',$prog->{qualifiers}->{LastShowing});
		}

		if ( defined($prog->{qualifiers}->{Subtitles}) ) {
		    $writer->dataElement('subtitles', '', 'type' => "onscreen");
		}
		elsif ( defined($prog->{qualifiers}->{ClosedCaptioned}) ) {
		    $writer->dataElement('subtitles', '', 'type' => "teletext");
		}
	    }
	    if ( defined($prog->{ratings_VCHIP}) ) {
		if ( defined($prog->{ratings_VCHIP_Expanded}) ) {
		    $writer->dataElement('rating', "$prog->{ratings_VCHIP} $prog->{ratings_VCHIP_Expanded}", system =>'VCHIP');
		}
		else {
		    $writer->dataElement('rating', "$prog->{ratings_VCHIP}", 'system' =>'VCHIP');
		}
	    }
	    $writer->dataElement('rating', "$prog->{ratings_MPAA}", 'system' =>'MPAA') if ( defined($prog->{ratings_MPAA}) );

	    if ( defined($prog->{ratings_Warnings}) ) {
		my %hash;
		foreach my $k ( sort @{$prog->{ratings_Warnings}}) {
		    $hash{$k}=1;
		}
		foreach my $k ( keys %hash ) {
		    $writer->dataElement('rating', "$k", 'system' =>'General Warning');
		}
	    }
	    if ( defined($prog->{stars_rating}) ) {
		# nowhere to put this yet.
		# comes in the form of a rating out fraction out of 4
	    }
	    $writer->endTag('programme');
	}
    }
    if ( defined($Pwriter_g) && $writer != $Pwriter_g ) {
	$writer->endTag('tv');
	$writer->end();
	$output->close();
    }
}




